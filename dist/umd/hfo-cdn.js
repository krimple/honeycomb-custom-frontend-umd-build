(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
    typeof define === 'function' && define.amd ? define(['exports'], factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.HNY = {}));
})(this, (function (exports) { 'use strict';

    /*
     * Copyright The OpenTelemetry Authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      https://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    // Updates to this file should also be replicated to @opentelemetry/core too.
    /**
     * - globalThis (New standard)
     * - self (Will return the current window instance for supported browsers)
     * - window (fallback for older browser implementations)
     * - global (NodeJS implementation)
     * - <object> (When all else fails)
     */
    /** only globals that common to node and browsers are allowed */
    // eslint-disable-next-line node/no-unsupported-features/es-builtins, no-undef
    var _globalThis$2 = typeof globalThis === 'object' ? globalThis : typeof self === 'object' ? self : typeof window === 'object' ? window : typeof global === 'object' ? global : {};

    /*
     * Copyright The OpenTelemetry Authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      https://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    // this is autogenerated file, see scripts/version-update.js
    var VERSION$5 = '1.9.0';

    /*
     * Copyright The OpenTelemetry Authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      https://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    var re = /^(\d+)\.(\d+)\.(\d+)(-(.+))?$/;
    /**
     * Create a function to test an API version to see if it is compatible with the provided ownVersion.
     *
     * The returned function has the following semantics:
     * - Exact match is always compatible
     * - Major versions must match exactly
     *    - 1.x package cannot use global 2.x package
     *    - 2.x package cannot use global 1.x package
     * - The minor version of the API module requesting access to the global API must be less than or equal to the minor version of this API
     *    - 1.3 package may use 1.4 global because the later global contains all functions 1.3 expects
     *    - 1.4 package may NOT use 1.3 global because it may try to call functions which don't exist on 1.3
     * - If the major version is 0, the minor version is treated as the major and the patch is treated as the minor
     * - Patch and build tag differences are not considered at this time
     *
     * @param ownVersion version which should be checked against
     */
    function _makeCompatibilityCheck(ownVersion) {
      var acceptedVersions = new Set([ownVersion]);
      var rejectedVersions = new Set();
      var myVersionMatch = ownVersion.match(re);
      if (!myVersionMatch) {
        // we cannot guarantee compatibility so we always return noop
        return function () {
          return false;
        };
      }
      var ownVersionParsed = {
        major: +myVersionMatch[1],
        minor: +myVersionMatch[2],
        patch: +myVersionMatch[3],
        prerelease: myVersionMatch[4]
      };
      // if ownVersion has a prerelease tag, versions must match exactly
      if (ownVersionParsed.prerelease != null) {
        return function isExactmatch(globalVersion) {
          return globalVersion === ownVersion;
        };
      }
      function _reject(v) {
        rejectedVersions.add(v);
        return false;
      }
      function _accept(v) {
        acceptedVersions.add(v);
        return true;
      }
      return function isCompatible(globalVersion) {
        if (acceptedVersions.has(globalVersion)) {
          return true;
        }
        if (rejectedVersions.has(globalVersion)) {
          return false;
        }
        var globalVersionMatch = globalVersion.match(re);
        if (!globalVersionMatch) {
          // cannot parse other version
          // we cannot guarantee compatibility so we always noop
          return _reject(globalVersion);
        }
        var globalVersionParsed = {
          major: +globalVersionMatch[1],
          minor: +globalVersionMatch[2],
          patch: +globalVersionMatch[3],
          prerelease: globalVersionMatch[4]
        };
        // if globalVersion has a prerelease tag, versions must match exactly
        if (globalVersionParsed.prerelease != null) {
          return _reject(globalVersion);
        }
        // major versions must match
        if (ownVersionParsed.major !== globalVersionParsed.major) {
          return _reject(globalVersion);
        }
        if (ownVersionParsed.major === 0) {
          if (ownVersionParsed.minor === globalVersionParsed.minor && ownVersionParsed.patch <= globalVersionParsed.patch) {
            return _accept(globalVersion);
          }
          return _reject(globalVersion);
        }
        if (ownVersionParsed.minor <= globalVersionParsed.minor) {
          return _accept(globalVersion);
        }
        return _reject(globalVersion);
      };
    }
    /**
     * Test an API version to see if it is compatible with this API.
     *
     * - Exact match is always compatible
     * - Major versions must match exactly
     *    - 1.x package cannot use global 2.x package
     *    - 2.x package cannot use global 1.x package
     * - The minor version of the API module requesting access to the global API must be less than or equal to the minor version of this API
     *    - 1.3 package may use 1.4 global because the later global contains all functions 1.3 expects
     *    - 1.4 package may NOT use 1.3 global because it may try to call functions which don't exist on 1.3
     * - If the major version is 0, the minor version is treated as the major and the patch is treated as the minor
     * - Patch and build tag differences are not considered at this time
     *
     * @param version version of the API requesting an instance of the global API
     */
    var isCompatible = _makeCompatibilityCheck(VERSION$5);

    /*
     * Copyright The OpenTelemetry Authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      https://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    var major = VERSION$5.split('.')[0];
    var GLOBAL_OPENTELEMETRY_API_KEY = Symbol.for("opentelemetry.js.api." + major);
    var _global$1 = _globalThis$2;
    function registerGlobal(type, instance, diag, allowOverride) {
      var _a;
      if (allowOverride === void 0) {
        allowOverride = false;
      }
      var api = _global$1[GLOBAL_OPENTELEMETRY_API_KEY] = (_a = _global$1[GLOBAL_OPENTELEMETRY_API_KEY]) !== null && _a !== void 0 ? _a : {
        version: VERSION$5
      };
      if (!allowOverride && api[type]) {
        // already registered an API of this type
        var err = new Error("@opentelemetry/api: Attempted duplicate registration of API: " + type);
        diag.error(err.stack || err.message);
        return false;
      }
      if (api.version !== VERSION$5) {
        // All registered APIs must be of the same version exactly
        var err = new Error("@opentelemetry/api: Registration of version v" + api.version + " for " + type + " does not match previously registered API v" + VERSION$5);
        diag.error(err.stack || err.message);
        return false;
      }
      api[type] = instance;
      diag.debug("@opentelemetry/api: Registered a global for " + type + " v" + VERSION$5 + ".");
      return true;
    }
    function getGlobal(type) {
      var _a, _b;
      var globalVersion = (_a = _global$1[GLOBAL_OPENTELEMETRY_API_KEY]) === null || _a === void 0 ? void 0 : _a.version;
      if (!globalVersion || !isCompatible(globalVersion)) {
        return;
      }
      return (_b = _global$1[GLOBAL_OPENTELEMETRY_API_KEY]) === null || _b === void 0 ? void 0 : _b[type];
    }
    function unregisterGlobal(type, diag) {
      diag.debug("@opentelemetry/api: Unregistering a global for " + type + " v" + VERSION$5 + ".");
      var api = _global$1[GLOBAL_OPENTELEMETRY_API_KEY];
      if (api) {
        delete api[type];
      }
    }

    /*
     * Copyright The OpenTelemetry Authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      https://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    var __read$i = undefined && undefined.__read || function (o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m) return o;
      var i = m.call(o),
        r,
        ar = [],
        e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
      } catch (error) {
        e = {
          error: error
        };
      } finally {
        try {
          if (r && !r.done && (m = i["return"])) m.call(i);
        } finally {
          if (e) throw e.error;
        }
      }
      return ar;
    };
    var __spreadArray$8 = undefined && undefined.__spreadArray || function (to, from, pack) {
      if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
          if (!ar) ar = Array.prototype.slice.call(from, 0, i);
          ar[i] = from[i];
        }
      }
      return to.concat(ar || Array.prototype.slice.call(from));
    };
    /**
     * Component Logger which is meant to be used as part of any component which
     * will add automatically additional namespace in front of the log message.
     * It will then forward all message to global diag logger
     * @example
     * const cLogger = diag.createComponentLogger({ namespace: '@opentelemetry/instrumentation-http' });
     * cLogger.debug('test');
     * // @opentelemetry/instrumentation-http test
     */
    var DiagComponentLogger = /** @class */function () {
      function DiagComponentLogger(props) {
        this._namespace = props.namespace || 'DiagComponentLogger';
      }
      DiagComponentLogger.prototype.debug = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        return logProxy('debug', this._namespace, args);
      };
      DiagComponentLogger.prototype.error = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        return logProxy('error', this._namespace, args);
      };
      DiagComponentLogger.prototype.info = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        return logProxy('info', this._namespace, args);
      };
      DiagComponentLogger.prototype.warn = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        return logProxy('warn', this._namespace, args);
      };
      DiagComponentLogger.prototype.verbose = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        return logProxy('verbose', this._namespace, args);
      };
      return DiagComponentLogger;
    }();
    function logProxy(funcName, namespace, args) {
      var logger = getGlobal('diag');
      // shortcut if logger not set
      if (!logger) {
        return;
      }
      args.unshift(namespace);
      return logger[funcName].apply(logger, __spreadArray$8([], __read$i(args), false));
    }

    /*
     * Copyright The OpenTelemetry Authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      https://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    /**
     * Defines the available internal logging levels for the diagnostic logger, the numeric values
     * of the levels are defined to match the original values from the initial LogLevel to avoid
     * compatibility/migration issues for any implementation that assume the numeric ordering.
     */
    var DiagLogLevel;
    (function (DiagLogLevel) {
      /** Diagnostic Logging level setting to disable all logging (except and forced logs) */
      DiagLogLevel[DiagLogLevel["NONE"] = 0] = "NONE";
      /** Identifies an error scenario */
      DiagLogLevel[DiagLogLevel["ERROR"] = 30] = "ERROR";
      /** Identifies a warning scenario */
      DiagLogLevel[DiagLogLevel["WARN"] = 50] = "WARN";
      /** General informational log message */
      DiagLogLevel[DiagLogLevel["INFO"] = 60] = "INFO";
      /** General debug log message */
      DiagLogLevel[DiagLogLevel["DEBUG"] = 70] = "DEBUG";
      /**
       * Detailed trace level logging should only be used for development, should only be set
       * in a development environment.
       */
      DiagLogLevel[DiagLogLevel["VERBOSE"] = 80] = "VERBOSE";
      /** Used to set the logging level to include all logging */
      DiagLogLevel[DiagLogLevel["ALL"] = 9999] = "ALL";
    })(DiagLogLevel || (DiagLogLevel = {}));

    /*
     * Copyright The OpenTelemetry Authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      https://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    function createLogLevelDiagLogger(maxLevel, logger) {
      if (maxLevel < DiagLogLevel.NONE) {
        maxLevel = DiagLogLevel.NONE;
      } else if (maxLevel > DiagLogLevel.ALL) {
        maxLevel = DiagLogLevel.ALL;
      }
      // In case the logger is null or undefined
      logger = logger || {};
      function _filterFunc(funcName, theLevel) {
        var theFunc = logger[funcName];
        if (typeof theFunc === 'function' && maxLevel >= theLevel) {
          return theFunc.bind(logger);
        }
        return function () {};
      }
      return {
        error: _filterFunc('error', DiagLogLevel.ERROR),
        warn: _filterFunc('warn', DiagLogLevel.WARN),
        info: _filterFunc('info', DiagLogLevel.INFO),
        debug: _filterFunc('debug', DiagLogLevel.DEBUG),
        verbose: _filterFunc('verbose', DiagLogLevel.VERBOSE)
      };
    }

    /*
     * Copyright The OpenTelemetry Authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      https://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    var __read$h = undefined && undefined.__read || function (o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m) return o;
      var i = m.call(o),
        r,
        ar = [],
        e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
      } catch (error) {
        e = {
          error: error
        };
      } finally {
        try {
          if (r && !r.done && (m = i["return"])) m.call(i);
        } finally {
          if (e) throw e.error;
        }
      }
      return ar;
    };
    var __spreadArray$7 = undefined && undefined.__spreadArray || function (to, from, pack) {
      if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
          if (!ar) ar = Array.prototype.slice.call(from, 0, i);
          ar[i] = from[i];
        }
      }
      return to.concat(ar || Array.prototype.slice.call(from));
    };
    var API_NAME$4 = 'diag';
    /**
     * Singleton object which represents the entry point to the OpenTelemetry internal
     * diagnostic API
     */
    var DiagAPI = /** @class */function () {
      /**
       * Private internal constructor
       * @private
       */
      function DiagAPI() {
        function _logProxy(funcName) {
          return function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
              args[_i] = arguments[_i];
            }
            var logger = getGlobal('diag');
            // shortcut if logger not set
            if (!logger) return;
            return logger[funcName].apply(logger, __spreadArray$7([], __read$h(args), false));
          };
        }
        // Using self local variable for minification purposes as 'this' cannot be minified
        var self = this;
        // DiagAPI specific functions
        var setLogger = function (logger, optionsOrLogLevel) {
          var _a, _b, _c;
          if (optionsOrLogLevel === void 0) {
            optionsOrLogLevel = {
              logLevel: DiagLogLevel.INFO
            };
          }
          if (logger === self) {
            // There isn't much we can do here.
            // Logging to the console might break the user application.
            // Try to log to self. If a logger was previously registered it will receive the log.
            var err = new Error('Cannot use diag as the logger for itself. Please use a DiagLogger implementation like ConsoleDiagLogger or a custom implementation');
            self.error((_a = err.stack) !== null && _a !== void 0 ? _a : err.message);
            return false;
          }
          if (typeof optionsOrLogLevel === 'number') {
            optionsOrLogLevel = {
              logLevel: optionsOrLogLevel
            };
          }
          var oldLogger = getGlobal('diag');
          var newLogger = createLogLevelDiagLogger((_b = optionsOrLogLevel.logLevel) !== null && _b !== void 0 ? _b : DiagLogLevel.INFO, logger);
          // There already is an logger registered. We'll let it know before overwriting it.
          if (oldLogger && !optionsOrLogLevel.suppressOverrideMessage) {
            var stack = (_c = new Error().stack) !== null && _c !== void 0 ? _c : '<failed to generate stacktrace>';
            oldLogger.warn("Current logger will be overwritten from " + stack);
            newLogger.warn("Current logger will overwrite one already registered from " + stack);
          }
          return registerGlobal('diag', newLogger, self, true);
        };
        self.setLogger = setLogger;
        self.disable = function () {
          unregisterGlobal(API_NAME$4, self);
        };
        self.createComponentLogger = function (options) {
          return new DiagComponentLogger(options);
        };
        self.verbose = _logProxy('verbose');
        self.debug = _logProxy('debug');
        self.info = _logProxy('info');
        self.warn = _logProxy('warn');
        self.error = _logProxy('error');
      }
      /** Get the singleton instance of the DiagAPI API */
      DiagAPI.instance = function () {
        if (!this._instance) {
          this._instance = new DiagAPI();
        }
        return this._instance;
      };
      return DiagAPI;
    }();

    /*
     * Copyright The OpenTelemetry Authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      https://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    var __read$g = undefined && undefined.__read || function (o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m) return o;
      var i = m.call(o),
        r,
        ar = [],
        e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
      } catch (error) {
        e = {
          error: error
        };
      } finally {
        try {
          if (r && !r.done && (m = i["return"])) m.call(i);
        } finally {
          if (e) throw e.error;
        }
      }
      return ar;
    };
    var __values$8 = undefined && undefined.__values || function (o) {
      var s = typeof Symbol === "function" && Symbol.iterator,
        m = s && o[s],
        i = 0;
      if (m) return m.call(o);
      if (o && typeof o.length === "number") return {
        next: function () {
          if (o && i >= o.length) o = void 0;
          return {
            value: o && o[i++],
            done: !o
          };
        }
      };
      throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    };
    var BaggageImpl = /** @class */function () {
      function BaggageImpl(entries) {
        this._entries = entries ? new Map(entries) : new Map();
      }
      BaggageImpl.prototype.getEntry = function (key) {
        var entry = this._entries.get(key);
        if (!entry) {
          return undefined;
        }
        return Object.assign({}, entry);
      };
      BaggageImpl.prototype.getAllEntries = function () {
        return Array.from(this._entries.entries()).map(function (_a) {
          var _b = __read$g(_a, 2),
            k = _b[0],
            v = _b[1];
          return [k, v];
        });
      };
      BaggageImpl.prototype.setEntry = function (key, entry) {
        var newBaggage = new BaggageImpl(this._entries);
        newBaggage._entries.set(key, entry);
        return newBaggage;
      };
      BaggageImpl.prototype.removeEntry = function (key) {
        var newBaggage = new BaggageImpl(this._entries);
        newBaggage._entries.delete(key);
        return newBaggage;
      };
      BaggageImpl.prototype.removeEntries = function () {
        var e_1, _a;
        var keys = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          keys[_i] = arguments[_i];
        }
        var newBaggage = new BaggageImpl(this._entries);
        try {
          for (var keys_1 = __values$8(keys), keys_1_1 = keys_1.next(); !keys_1_1.done; keys_1_1 = keys_1.next()) {
            var key = keys_1_1.value;
            newBaggage._entries.delete(key);
          }
        } catch (e_1_1) {
          e_1 = {
            error: e_1_1
          };
        } finally {
          try {
            if (keys_1_1 && !keys_1_1.done && (_a = keys_1.return)) _a.call(keys_1);
          } finally {
            if (e_1) throw e_1.error;
          }
        }
        return newBaggage;
      };
      BaggageImpl.prototype.clear = function () {
        return new BaggageImpl();
      };
      return BaggageImpl;
    }();

    /*
     * Copyright The OpenTelemetry Authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      https://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    /**
     * Symbol used to make BaggageEntryMetadata an opaque type
     */
    var baggageEntryMetadataSymbol = Symbol('BaggageEntryMetadata');

    /*
     * Copyright The OpenTelemetry Authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      https://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    var diag$1 = DiagAPI.instance();
    /**
     * Create a new Baggage with optional entries
     *
     * @param entries An array of baggage entries the new baggage should contain
     */
    function createBaggage(entries) {
      if (entries === void 0) {
        entries = {};
      }
      return new BaggageImpl(new Map(Object.entries(entries)));
    }
    /**
     * Create a serializable BaggageEntryMetadata object from a string.
     *
     * @param str string metadata. Format is currently not defined by the spec and has no special meaning.
     *
     */
    function baggageEntryMetadataFromString(str) {
      if (typeof str !== 'string') {
        diag$1.error("Cannot create baggage metadata from unknown type: " + typeof str);
        str = '';
      }
      return {
        __TYPE__: baggageEntryMetadataSymbol,
        toString: function () {
          return str;
        }
      };
    }

    /*
     * Copyright The OpenTelemetry Authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      https://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    /** Get a key to uniquely identify a context value */
    function createContextKey(description) {
      // The specification states that for the same input, multiple calls should
      // return different keys. Due to the nature of the JS dependency management
      // system, this creates problems where multiple versions of some package
      // could hold different keys for the same property.
      //
      // Therefore, we use Symbol.for which returns the same key for the same input.
      return Symbol.for(description);
    }
    var BaseContext = /** @class */function () {
      /**
       * Construct a new context which inherits values from an optional parent context.
       *
       * @param parentContext a context from which to inherit values
       */
      function BaseContext(parentContext) {
        // for minification
        var self = this;
        self._currentContext = parentContext ? new Map(parentContext) : new Map();
        self.getValue = function (key) {
          return self._currentContext.get(key);
        };
        self.setValue = function (key, value) {
          var context = new BaseContext(self._currentContext);
          context._currentContext.set(key, value);
          return context;
        };
        self.deleteValue = function (key) {
          var context = new BaseContext(self._currentContext);
          context._currentContext.delete(key);
          return context;
        };
      }
      return BaseContext;
    }();
    /** The root context is used as the default parent context when there is no active context */
    var ROOT_CONTEXT = new BaseContext();

    /*
     * Copyright The OpenTelemetry Authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      https://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    var consoleMap = [{
      n: 'error',
      c: 'error'
    }, {
      n: 'warn',
      c: 'warn'
    }, {
      n: 'info',
      c: 'info'
    }, {
      n: 'debug',
      c: 'debug'
    }, {
      n: 'verbose',
      c: 'trace'
    }];
    /**
     * A simple Immutable Console based diagnostic logger which will output any messages to the Console.
     * If you want to limit the amount of logging to a specific level or lower use the
     * {@link createLogLevelDiagLogger}
     */
    var DiagConsoleLogger = /** @class */function () {
      function DiagConsoleLogger() {
        function _consoleFunc(funcName) {
          return function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
              args[_i] = arguments[_i];
            }
            if (console) {
              // Some environments only expose the console when the F12 developer console is open
              // eslint-disable-next-line no-console
              var theFunc = console[funcName];
              if (typeof theFunc !== 'function') {
                // Not all environments support all functions
                // eslint-disable-next-line no-console
                theFunc = console.log;
              }
              // One last final check
              if (typeof theFunc === 'function') {
                return theFunc.apply(console, args);
              }
            }
          };
        }
        for (var i = 0; i < consoleMap.length; i++) {
          this[consoleMap[i].n] = _consoleFunc(consoleMap[i].c);
        }
      }
      return DiagConsoleLogger;
    }();

    /*
     * Copyright The OpenTelemetry Authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      https://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    var __extends$9 = undefined && undefined.__extends || function () {
      var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf || {
          __proto__: []
        } instanceof Array && function (d, b) {
          d.__proto__ = b;
        } || function (d, b) {
          for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
        };
        return extendStatics(d, b);
      };
      return function (d, b) {
        if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    /**
     * NoopMeter is a noop implementation of the {@link Meter} interface. It reuses
     * constant NoopMetrics for all of its methods.
     */
    var NoopMeter = /** @class */function () {
      function NoopMeter() {}
      /**
       * @see {@link Meter.createGauge}
       */
      NoopMeter.prototype.createGauge = function (_name, _options) {
        return NOOP_GAUGE_METRIC;
      };
      /**
       * @see {@link Meter.createHistogram}
       */
      NoopMeter.prototype.createHistogram = function (_name, _options) {
        return NOOP_HISTOGRAM_METRIC;
      };
      /**
       * @see {@link Meter.createCounter}
       */
      NoopMeter.prototype.createCounter = function (_name, _options) {
        return NOOP_COUNTER_METRIC;
      };
      /**
       * @see {@link Meter.createUpDownCounter}
       */
      NoopMeter.prototype.createUpDownCounter = function (_name, _options) {
        return NOOP_UP_DOWN_COUNTER_METRIC;
      };
      /**
       * @see {@link Meter.createObservableGauge}
       */
      NoopMeter.prototype.createObservableGauge = function (_name, _options) {
        return NOOP_OBSERVABLE_GAUGE_METRIC;
      };
      /**
       * @see {@link Meter.createObservableCounter}
       */
      NoopMeter.prototype.createObservableCounter = function (_name, _options) {
        return NOOP_OBSERVABLE_COUNTER_METRIC;
      };
      /**
       * @see {@link Meter.createObservableUpDownCounter}
       */
      NoopMeter.prototype.createObservableUpDownCounter = function (_name, _options) {
        return NOOP_OBSERVABLE_UP_DOWN_COUNTER_METRIC;
      };
      /**
       * @see {@link Meter.addBatchObservableCallback}
       */
      NoopMeter.prototype.addBatchObservableCallback = function (_callback, _observables) {};
      /**
       * @see {@link Meter.removeBatchObservableCallback}
       */
      NoopMeter.prototype.removeBatchObservableCallback = function (_callback) {};
      return NoopMeter;
    }();
    var NoopMetric = /** @class */function () {
      function NoopMetric() {}
      return NoopMetric;
    }();
    var NoopCounterMetric = /** @class */function (_super) {
      __extends$9(NoopCounterMetric, _super);
      function NoopCounterMetric() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      NoopCounterMetric.prototype.add = function (_value, _attributes) {};
      return NoopCounterMetric;
    }(NoopMetric);
    var NoopUpDownCounterMetric = /** @class */function (_super) {
      __extends$9(NoopUpDownCounterMetric, _super);
      function NoopUpDownCounterMetric() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      NoopUpDownCounterMetric.prototype.add = function (_value, _attributes) {};
      return NoopUpDownCounterMetric;
    }(NoopMetric);
    var NoopGaugeMetric = /** @class */function (_super) {
      __extends$9(NoopGaugeMetric, _super);
      function NoopGaugeMetric() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      NoopGaugeMetric.prototype.record = function (_value, _attributes) {};
      return NoopGaugeMetric;
    }(NoopMetric);
    var NoopHistogramMetric = /** @class */function (_super) {
      __extends$9(NoopHistogramMetric, _super);
      function NoopHistogramMetric() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      NoopHistogramMetric.prototype.record = function (_value, _attributes) {};
      return NoopHistogramMetric;
    }(NoopMetric);
    var NoopObservableMetric = /** @class */function () {
      function NoopObservableMetric() {}
      NoopObservableMetric.prototype.addCallback = function (_callback) {};
      NoopObservableMetric.prototype.removeCallback = function (_callback) {};
      return NoopObservableMetric;
    }();
    var NoopObservableCounterMetric = /** @class */function (_super) {
      __extends$9(NoopObservableCounterMetric, _super);
      function NoopObservableCounterMetric() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      return NoopObservableCounterMetric;
    }(NoopObservableMetric);
    var NoopObservableGaugeMetric = /** @class */function (_super) {
      __extends$9(NoopObservableGaugeMetric, _super);
      function NoopObservableGaugeMetric() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      return NoopObservableGaugeMetric;
    }(NoopObservableMetric);
    var NoopObservableUpDownCounterMetric = /** @class */function (_super) {
      __extends$9(NoopObservableUpDownCounterMetric, _super);
      function NoopObservableUpDownCounterMetric() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      return NoopObservableUpDownCounterMetric;
    }(NoopObservableMetric);
    var NOOP_METER = new NoopMeter();
    // Synchronous instruments
    var NOOP_COUNTER_METRIC = new NoopCounterMetric();
    var NOOP_GAUGE_METRIC = new NoopGaugeMetric();
    var NOOP_HISTOGRAM_METRIC = new NoopHistogramMetric();
    var NOOP_UP_DOWN_COUNTER_METRIC = new NoopUpDownCounterMetric();
    // Asynchronous instruments
    var NOOP_OBSERVABLE_COUNTER_METRIC = new NoopObservableCounterMetric();
    var NOOP_OBSERVABLE_GAUGE_METRIC = new NoopObservableGaugeMetric();
    var NOOP_OBSERVABLE_UP_DOWN_COUNTER_METRIC = new NoopObservableUpDownCounterMetric();

    /*
     * Copyright The OpenTelemetry Authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      https://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    var defaultTextMapGetter = {
      get: function (carrier, key) {
        if (carrier == null) {
          return undefined;
        }
        return carrier[key];
      },
      keys: function (carrier) {
        if (carrier == null) {
          return [];
        }
        return Object.keys(carrier);
      }
    };
    var defaultTextMapSetter = {
      set: function (carrier, key, value) {
        if (carrier == null) {
          return;
        }
        carrier[key] = value;
      }
    };

    /*
     * Copyright The OpenTelemetry Authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      https://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    var __read$f = undefined && undefined.__read || function (o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m) return o;
      var i = m.call(o),
        r,
        ar = [],
        e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
      } catch (error) {
        e = {
          error: error
        };
      } finally {
        try {
          if (r && !r.done && (m = i["return"])) m.call(i);
        } finally {
          if (e) throw e.error;
        }
      }
      return ar;
    };
    var __spreadArray$6 = undefined && undefined.__spreadArray || function (to, from, pack) {
      if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
          if (!ar) ar = Array.prototype.slice.call(from, 0, i);
          ar[i] = from[i];
        }
      }
      return to.concat(ar || Array.prototype.slice.call(from));
    };
    var NoopContextManager = /** @class */function () {
      function NoopContextManager() {}
      NoopContextManager.prototype.active = function () {
        return ROOT_CONTEXT;
      };
      NoopContextManager.prototype.with = function (_context, fn, thisArg) {
        var args = [];
        for (var _i = 3; _i < arguments.length; _i++) {
          args[_i - 3] = arguments[_i];
        }
        return fn.call.apply(fn, __spreadArray$6([thisArg], __read$f(args), false));
      };
      NoopContextManager.prototype.bind = function (_context, target) {
        return target;
      };
      NoopContextManager.prototype.enable = function () {
        return this;
      };
      NoopContextManager.prototype.disable = function () {
        return this;
      };
      return NoopContextManager;
    }();

    /*
     * Copyright The OpenTelemetry Authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      https://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    var __read$e = undefined && undefined.__read || function (o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m) return o;
      var i = m.call(o),
        r,
        ar = [],
        e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
      } catch (error) {
        e = {
          error: error
        };
      } finally {
        try {
          if (r && !r.done && (m = i["return"])) m.call(i);
        } finally {
          if (e) throw e.error;
        }
      }
      return ar;
    };
    var __spreadArray$5 = undefined && undefined.__spreadArray || function (to, from, pack) {
      if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
          if (!ar) ar = Array.prototype.slice.call(from, 0, i);
          ar[i] = from[i];
        }
      }
      return to.concat(ar || Array.prototype.slice.call(from));
    };
    var API_NAME$3 = 'context';
    var NOOP_CONTEXT_MANAGER = new NoopContextManager();
    /**
     * Singleton object which represents the entry point to the OpenTelemetry Context API
     */
    var ContextAPI = /** @class */function () {
      /** Empty private constructor prevents end users from constructing a new instance of the API */
      function ContextAPI() {}
      /** Get the singleton instance of the Context API */
      ContextAPI.getInstance = function () {
        if (!this._instance) {
          this._instance = new ContextAPI();
        }
        return this._instance;
      };
      /**
       * Set the current context manager.
       *
       * @returns true if the context manager was successfully registered, else false
       */
      ContextAPI.prototype.setGlobalContextManager = function (contextManager) {
        return registerGlobal(API_NAME$3, contextManager, DiagAPI.instance());
      };
      /**
       * Get the currently active context
       */
      ContextAPI.prototype.active = function () {
        return this._getContextManager().active();
      };
      /**
       * Execute a function with an active context
       *
       * @param context context to be active during function execution
       * @param fn function to execute in a context
       * @param thisArg optional receiver to be used for calling fn
       * @param args optional arguments forwarded to fn
       */
      ContextAPI.prototype.with = function (context, fn, thisArg) {
        var _a;
        var args = [];
        for (var _i = 3; _i < arguments.length; _i++) {
          args[_i - 3] = arguments[_i];
        }
        return (_a = this._getContextManager()).with.apply(_a, __spreadArray$5([context, fn, thisArg], __read$e(args), false));
      };
      /**
       * Bind a context to a target function or event emitter
       *
       * @param context context to bind to the event emitter or function. Defaults to the currently active context
       * @param target function or event emitter to bind
       */
      ContextAPI.prototype.bind = function (context, target) {
        return this._getContextManager().bind(context, target);
      };
      ContextAPI.prototype._getContextManager = function () {
        return getGlobal(API_NAME$3) || NOOP_CONTEXT_MANAGER;
      };
      /** Disable and remove the global context manager */
      ContextAPI.prototype.disable = function () {
        this._getContextManager().disable();
        unregisterGlobal(API_NAME$3, DiagAPI.instance());
      };
      return ContextAPI;
    }();

    /*
     * Copyright The OpenTelemetry Authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      https://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    var TraceFlags;
    (function (TraceFlags) {
      /** Represents no flag set. */
      TraceFlags[TraceFlags["NONE"] = 0] = "NONE";
      /** Bit to represent whether trace is sampled in trace flags. */
      TraceFlags[TraceFlags["SAMPLED"] = 1] = "SAMPLED";
    })(TraceFlags || (TraceFlags = {}));

    /*
     * Copyright The OpenTelemetry Authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      https://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    var INVALID_SPANID = '0000000000000000';
    var INVALID_TRACEID = '00000000000000000000000000000000';
    var INVALID_SPAN_CONTEXT = {
      traceId: INVALID_TRACEID,
      spanId: INVALID_SPANID,
      traceFlags: TraceFlags.NONE
    };

    /*
     * Copyright The OpenTelemetry Authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      https://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    /**
     * The NonRecordingSpan is the default {@link Span} that is used when no Span
     * implementation is available. All operations are no-op including context
     * propagation.
     */
    var NonRecordingSpan = /** @class */function () {
      function NonRecordingSpan(_spanContext) {
        if (_spanContext === void 0) {
          _spanContext = INVALID_SPAN_CONTEXT;
        }
        this._spanContext = _spanContext;
      }
      // Returns a SpanContext.
      NonRecordingSpan.prototype.spanContext = function () {
        return this._spanContext;
      };
      // By default does nothing
      NonRecordingSpan.prototype.setAttribute = function (_key, _value) {
        return this;
      };
      // By default does nothing
      NonRecordingSpan.prototype.setAttributes = function (_attributes) {
        return this;
      };
      // By default does nothing
      NonRecordingSpan.prototype.addEvent = function (_name, _attributes) {
        return this;
      };
      NonRecordingSpan.prototype.addLink = function (_link) {
        return this;
      };
      NonRecordingSpan.prototype.addLinks = function (_links) {
        return this;
      };
      // By default does nothing
      NonRecordingSpan.prototype.setStatus = function (_status) {
        return this;
      };
      // By default does nothing
      NonRecordingSpan.prototype.updateName = function (_name) {
        return this;
      };
      // By default does nothing
      NonRecordingSpan.prototype.end = function (_endTime) {};
      // isRecording always returns false for NonRecordingSpan.
      NonRecordingSpan.prototype.isRecording = function () {
        return false;
      };
      // By default does nothing
      NonRecordingSpan.prototype.recordException = function (_exception, _time) {};
      return NonRecordingSpan;
    }();

    /*
     * Copyright The OpenTelemetry Authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      https://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    /**
     * span key
     */
    var SPAN_KEY = createContextKey('OpenTelemetry Context Key SPAN');
    /**
     * Return the span if one exists
     *
     * @param context context to get span from
     */
    function getSpan(context) {
      return context.getValue(SPAN_KEY) || undefined;
    }
    /**
     * Gets the span from the current context, if one exists.
     */
    function getActiveSpan() {
      return getSpan(ContextAPI.getInstance().active());
    }
    /**
     * Set the span on a context
     *
     * @param context context to use as parent
     * @param span span to set active
     */
    function setSpan(context, span) {
      return context.setValue(SPAN_KEY, span);
    }
    /**
     * Remove current span stored in the context
     *
     * @param context context to delete span from
     */
    function deleteSpan(context) {
      return context.deleteValue(SPAN_KEY);
    }
    /**
     * Wrap span context in a NoopSpan and set as span in a new
     * context
     *
     * @param context context to set active span on
     * @param spanContext span context to be wrapped
     */
    function setSpanContext(context, spanContext) {
      return setSpan(context, new NonRecordingSpan(spanContext));
    }
    /**
     * Get the span context of the span if it exists.
     *
     * @param context context to get values from
     */
    function getSpanContext(context) {
      var _a;
      return (_a = getSpan(context)) === null || _a === void 0 ? void 0 : _a.spanContext();
    }

    /*
     * Copyright The OpenTelemetry Authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      https://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    var VALID_TRACEID_REGEX = /^([0-9a-f]{32})$/i;
    var VALID_SPANID_REGEX = /^[0-9a-f]{16}$/i;
    function isValidTraceId(traceId) {
      return VALID_TRACEID_REGEX.test(traceId) && traceId !== INVALID_TRACEID;
    }
    function isValidSpanId(spanId) {
      return VALID_SPANID_REGEX.test(spanId) && spanId !== INVALID_SPANID;
    }
    /**
     * Returns true if this {@link SpanContext} is valid.
     * @return true if this {@link SpanContext} is valid.
     */
    function isSpanContextValid(spanContext) {
      return isValidTraceId(spanContext.traceId) && isValidSpanId(spanContext.spanId);
    }
    /**
     * Wrap the given {@link SpanContext} in a new non-recording {@link Span}
     *
     * @param spanContext span context to be wrapped
     * @returns a new non-recording {@link Span} with the provided context
     */
    function wrapSpanContext(spanContext) {
      return new NonRecordingSpan(spanContext);
    }

    /*
     * Copyright The OpenTelemetry Authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      https://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    var contextApi = ContextAPI.getInstance();
    /**
     * No-op implementations of {@link Tracer}.
     */
    var NoopTracer = /** @class */function () {
      function NoopTracer() {}
      // startSpan starts a noop span.
      NoopTracer.prototype.startSpan = function (name, options, context) {
        if (context === void 0) {
          context = contextApi.active();
        }
        var root = Boolean(options === null || options === void 0 ? void 0 : options.root);
        if (root) {
          return new NonRecordingSpan();
        }
        var parentFromContext = context && getSpanContext(context);
        if (isSpanContext(parentFromContext) && isSpanContextValid(parentFromContext)) {
          return new NonRecordingSpan(parentFromContext);
        } else {
          return new NonRecordingSpan();
        }
      };
      NoopTracer.prototype.startActiveSpan = function (name, arg2, arg3, arg4) {
        var opts;
        var ctx;
        var fn;
        if (arguments.length < 2) {
          return;
        } else if (arguments.length === 2) {
          fn = arg2;
        } else if (arguments.length === 3) {
          opts = arg2;
          fn = arg3;
        } else {
          opts = arg2;
          ctx = arg3;
          fn = arg4;
        }
        var parentContext = ctx !== null && ctx !== void 0 ? ctx : contextApi.active();
        var span = this.startSpan(name, opts, parentContext);
        var contextWithSpanSet = setSpan(parentContext, span);
        return contextApi.with(contextWithSpanSet, fn, undefined, span);
      };
      return NoopTracer;
    }();
    function isSpanContext(spanContext) {
      return typeof spanContext === 'object' && typeof spanContext['spanId'] === 'string' && typeof spanContext['traceId'] === 'string' && typeof spanContext['traceFlags'] === 'number';
    }

    /*
     * Copyright The OpenTelemetry Authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      https://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    var NOOP_TRACER = new NoopTracer();
    /**
     * Proxy tracer provided by the proxy tracer provider
     */
    var ProxyTracer = /** @class */function () {
      function ProxyTracer(_provider, name, version, options) {
        this._provider = _provider;
        this.name = name;
        this.version = version;
        this.options = options;
      }
      ProxyTracer.prototype.startSpan = function (name, options, context) {
        return this._getTracer().startSpan(name, options, context);
      };
      ProxyTracer.prototype.startActiveSpan = function (_name, _options, _context, _fn) {
        var tracer = this._getTracer();
        return Reflect.apply(tracer.startActiveSpan, tracer, arguments);
      };
      /**
       * Try to get a tracer from the proxy tracer provider.
       * If the proxy tracer provider has no delegate, return a noop tracer.
       */
      ProxyTracer.prototype._getTracer = function () {
        if (this._delegate) {
          return this._delegate;
        }
        var tracer = this._provider.getDelegateTracer(this.name, this.version, this.options);
        if (!tracer) {
          return NOOP_TRACER;
        }
        this._delegate = tracer;
        return this._delegate;
      };
      return ProxyTracer;
    }();

    /*
     * Copyright The OpenTelemetry Authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      https://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    /**
     * An implementation of the {@link TracerProvider} which returns an impotent
     * Tracer for all calls to `getTracer`.
     *
     * All operations are no-op.
     */
    var NoopTracerProvider = /** @class */function () {
      function NoopTracerProvider() {}
      NoopTracerProvider.prototype.getTracer = function (_name, _version, _options) {
        return new NoopTracer();
      };
      return NoopTracerProvider;
    }();

    /*
     * Copyright The OpenTelemetry Authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      https://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    var NOOP_TRACER_PROVIDER = new NoopTracerProvider();
    /**
     * Tracer provider which provides {@link ProxyTracer}s.
     *
     * Before a delegate is set, tracers provided are NoOp.
     *   When a delegate is set, traces are provided from the delegate.
     *   When a delegate is set after tracers have already been provided,
     *   all tracers already provided will use the provided delegate implementation.
     */
    var ProxyTracerProvider = /** @class */function () {
      function ProxyTracerProvider() {}
      /**
       * Get a {@link ProxyTracer}
       */
      ProxyTracerProvider.prototype.getTracer = function (name, version, options) {
        var _a;
        return (_a = this.getDelegateTracer(name, version, options)) !== null && _a !== void 0 ? _a : new ProxyTracer(this, name, version, options);
      };
      ProxyTracerProvider.prototype.getDelegate = function () {
        var _a;
        return (_a = this._delegate) !== null && _a !== void 0 ? _a : NOOP_TRACER_PROVIDER;
      };
      /**
       * Set the delegate tracer provider
       */
      ProxyTracerProvider.prototype.setDelegate = function (delegate) {
        this._delegate = delegate;
      };
      ProxyTracerProvider.prototype.getDelegateTracer = function (name, version, options) {
        var _a;
        return (_a = this._delegate) === null || _a === void 0 ? void 0 : _a.getTracer(name, version, options);
      };
      return ProxyTracerProvider;
    }();

    /*
     * Copyright The OpenTelemetry Authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      https://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    /**
     * @deprecated use the one declared in @opentelemetry/sdk-trace-base instead.
     * A sampling decision that determines how a {@link Span} will be recorded
     * and collected.
     */
    var SamplingDecision$1;
    (function (SamplingDecision) {
      /**
       * `Span.isRecording() === false`, span will not be recorded and all events
       * and attributes will be dropped.
       */
      SamplingDecision[SamplingDecision["NOT_RECORD"] = 0] = "NOT_RECORD";
      /**
       * `Span.isRecording() === true`, but `Sampled` flag in {@link TraceFlags}
       * MUST NOT be set.
       */
      SamplingDecision[SamplingDecision["RECORD"] = 1] = "RECORD";
      /**
       * `Span.isRecording() === true` AND `Sampled` flag in {@link TraceFlags}
       * MUST be set.
       */
      SamplingDecision[SamplingDecision["RECORD_AND_SAMPLED"] = 2] = "RECORD_AND_SAMPLED";
    })(SamplingDecision$1 || (SamplingDecision$1 = {}));

    /*
     * Copyright The OpenTelemetry Authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      https://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    var SpanKind;
    (function (SpanKind) {
      /** Default value. Indicates that the span is used internally. */
      SpanKind[SpanKind["INTERNAL"] = 0] = "INTERNAL";
      /**
       * Indicates that the span covers server-side handling of an RPC or other
       * remote request.
       */
      SpanKind[SpanKind["SERVER"] = 1] = "SERVER";
      /**
       * Indicates that the span covers the client-side wrapper around an RPC or
       * other remote request.
       */
      SpanKind[SpanKind["CLIENT"] = 2] = "CLIENT";
      /**
       * Indicates that the span describes producer sending a message to a
       * broker. Unlike client and server, there is no direct critical path latency
       * relationship between producer and consumer spans.
       */
      SpanKind[SpanKind["PRODUCER"] = 3] = "PRODUCER";
      /**
       * Indicates that the span describes consumer receiving a message from a
       * broker. Unlike client and server, there is no direct critical path latency
       * relationship between producer and consumer spans.
       */
      SpanKind[SpanKind["CONSUMER"] = 4] = "CONSUMER";
    })(SpanKind || (SpanKind = {}));

    /**
     * An enumeration of status codes.
     */
    var SpanStatusCode;
    (function (SpanStatusCode) {
      /**
       * The default status.
       */
      SpanStatusCode[SpanStatusCode["UNSET"] = 0] = "UNSET";
      /**
       * The operation has been validated by an Application developer or
       * Operator to have completed successfully.
       */
      SpanStatusCode[SpanStatusCode["OK"] = 1] = "OK";
      /**
       * The operation contains an error.
       */
      SpanStatusCode[SpanStatusCode["ERROR"] = 2] = "ERROR";
    })(SpanStatusCode || (SpanStatusCode = {}));

    /*
     * Copyright The OpenTelemetry Authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      https://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    // Split module-level variable definition into separate files to allow
    // tree-shaking on each api instance.
    /** Entrypoint for context API */
    var context = ContextAPI.getInstance();

    /*
     * Copyright The OpenTelemetry Authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      https://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    // Split module-level variable definition into separate files to allow
    // tree-shaking on each api instance.
    /**
     * Entrypoint for Diag API.
     * Defines Diagnostic handler used for internal diagnostic logging operations.
     * The default provides a Noop DiagLogger implementation which may be changed via the
     * diag.setLogger(logger: DiagLogger) function.
     */
    var diag = DiagAPI.instance();

    /*
     * Copyright The OpenTelemetry Authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      https://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    /**
     * An implementation of the {@link MeterProvider} which returns an impotent Meter
     * for all calls to `getMeter`
     */
    var NoopMeterProvider = /** @class */function () {
      function NoopMeterProvider() {}
      NoopMeterProvider.prototype.getMeter = function (_name, _version, _options) {
        return NOOP_METER;
      };
      return NoopMeterProvider;
    }();
    var NOOP_METER_PROVIDER = new NoopMeterProvider();

    /*
     * Copyright The OpenTelemetry Authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      https://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    var API_NAME$2 = 'metrics';
    /**
     * Singleton object which represents the entry point to the OpenTelemetry Metrics API
     */
    var MetricsAPI = /** @class */function () {
      /** Empty private constructor prevents end users from constructing a new instance of the API */
      function MetricsAPI() {}
      /** Get the singleton instance of the Metrics API */
      MetricsAPI.getInstance = function () {
        if (!this._instance) {
          this._instance = new MetricsAPI();
        }
        return this._instance;
      };
      /**
       * Set the current global meter provider.
       * Returns true if the meter provider was successfully registered, else false.
       */
      MetricsAPI.prototype.setGlobalMeterProvider = function (provider) {
        return registerGlobal(API_NAME$2, provider, DiagAPI.instance());
      };
      /**
       * Returns the global meter provider.
       */
      MetricsAPI.prototype.getMeterProvider = function () {
        return getGlobal(API_NAME$2) || NOOP_METER_PROVIDER;
      };
      /**
       * Returns a meter from the global meter provider.
       */
      MetricsAPI.prototype.getMeter = function (name, version, options) {
        return this.getMeterProvider().getMeter(name, version, options);
      };
      /** Remove the global meter provider */
      MetricsAPI.prototype.disable = function () {
        unregisterGlobal(API_NAME$2, DiagAPI.instance());
      };
      return MetricsAPI;
    }();

    /*
     * Copyright The OpenTelemetry Authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      https://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    // Split module-level variable definition into separate files to allow
    // tree-shaking on each api instance.
    /** Entrypoint for metrics API */
    var metrics = MetricsAPI.getInstance();

    /*
     * Copyright The OpenTelemetry Authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      https://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    /**
     * No-op implementations of {@link TextMapPropagator}.
     */
    var NoopTextMapPropagator = /** @class */function () {
      function NoopTextMapPropagator() {}
      /** Noop inject function does nothing */
      NoopTextMapPropagator.prototype.inject = function (_context, _carrier) {};
      /** Noop extract function does nothing and returns the input context */
      NoopTextMapPropagator.prototype.extract = function (context, _carrier) {
        return context;
      };
      NoopTextMapPropagator.prototype.fields = function () {
        return [];
      };
      return NoopTextMapPropagator;
    }();

    /*
     * Copyright The OpenTelemetry Authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      https://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    /**
     * Baggage key
     */
    var BAGGAGE_KEY = createContextKey('OpenTelemetry Baggage Key');
    /**
     * Retrieve the current baggage from the given context
     *
     * @param {Context} Context that manage all context values
     * @returns {Baggage} Extracted baggage from the context
     */
    function getBaggage(context) {
      return context.getValue(BAGGAGE_KEY) || undefined;
    }
    /**
     * Retrieve the current baggage from the active/current context
     *
     * @returns {Baggage} Extracted baggage from the context
     */
    function getActiveBaggage() {
      return getBaggage(ContextAPI.getInstance().active());
    }
    /**
     * Store a baggage in the given context
     *
     * @param {Context} Context that manage all context values
     * @param {Baggage} baggage that will be set in the actual context
     */
    function setBaggage(context, baggage) {
      return context.setValue(BAGGAGE_KEY, baggage);
    }
    /**
     * Delete the baggage stored in the given context
     *
     * @param {Context} Context that manage all context values
     */
    function deleteBaggage(context) {
      return context.deleteValue(BAGGAGE_KEY);
    }

    /*
     * Copyright The OpenTelemetry Authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      https://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    var API_NAME$1 = 'propagation';
    var NOOP_TEXT_MAP_PROPAGATOR = new NoopTextMapPropagator();
    /**
     * Singleton object which represents the entry point to the OpenTelemetry Propagation API
     */
    var PropagationAPI = /** @class */function () {
      /** Empty private constructor prevents end users from constructing a new instance of the API */
      function PropagationAPI() {
        this.createBaggage = createBaggage;
        this.getBaggage = getBaggage;
        this.getActiveBaggage = getActiveBaggage;
        this.setBaggage = setBaggage;
        this.deleteBaggage = deleteBaggage;
      }
      /** Get the singleton instance of the Propagator API */
      PropagationAPI.getInstance = function () {
        if (!this._instance) {
          this._instance = new PropagationAPI();
        }
        return this._instance;
      };
      /**
       * Set the current propagator.
       *
       * @returns true if the propagator was successfully registered, else false
       */
      PropagationAPI.prototype.setGlobalPropagator = function (propagator) {
        return registerGlobal(API_NAME$1, propagator, DiagAPI.instance());
      };
      /**
       * Inject context into a carrier to be propagated inter-process
       *
       * @param context Context carrying tracing data to inject
       * @param carrier carrier to inject context into
       * @param setter Function used to set values on the carrier
       */
      PropagationAPI.prototype.inject = function (context, carrier, setter) {
        if (setter === void 0) {
          setter = defaultTextMapSetter;
        }
        return this._getGlobalPropagator().inject(context, carrier, setter);
      };
      /**
       * Extract context from a carrier
       *
       * @param context Context which the newly created context will inherit from
       * @param carrier Carrier to extract context from
       * @param getter Function used to extract keys from a carrier
       */
      PropagationAPI.prototype.extract = function (context, carrier, getter) {
        if (getter === void 0) {
          getter = defaultTextMapGetter;
        }
        return this._getGlobalPropagator().extract(context, carrier, getter);
      };
      /**
       * Return a list of all fields which may be used by the propagator.
       */
      PropagationAPI.prototype.fields = function () {
        return this._getGlobalPropagator().fields();
      };
      /** Remove the global propagator */
      PropagationAPI.prototype.disable = function () {
        unregisterGlobal(API_NAME$1, DiagAPI.instance());
      };
      PropagationAPI.prototype._getGlobalPropagator = function () {
        return getGlobal(API_NAME$1) || NOOP_TEXT_MAP_PROPAGATOR;
      };
      return PropagationAPI;
    }();

    /*
     * Copyright The OpenTelemetry Authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      https://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    // Split module-level variable definition into separate files to allow
    // tree-shaking on each api instance.
    /** Entrypoint for propagation API */
    var propagation = PropagationAPI.getInstance();

    /*
     * Copyright The OpenTelemetry Authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      https://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    var API_NAME = 'trace';
    /**
     * Singleton object which represents the entry point to the OpenTelemetry Tracing API
     */
    var TraceAPI = /** @class */function () {
      /** Empty private constructor prevents end users from constructing a new instance of the API */
      function TraceAPI() {
        this._proxyTracerProvider = new ProxyTracerProvider();
        this.wrapSpanContext = wrapSpanContext;
        this.isSpanContextValid = isSpanContextValid;
        this.deleteSpan = deleteSpan;
        this.getSpan = getSpan;
        this.getActiveSpan = getActiveSpan;
        this.getSpanContext = getSpanContext;
        this.setSpan = setSpan;
        this.setSpanContext = setSpanContext;
      }
      /** Get the singleton instance of the Trace API */
      TraceAPI.getInstance = function () {
        if (!this._instance) {
          this._instance = new TraceAPI();
        }
        return this._instance;
      };
      /**
       * Set the current global tracer.
       *
       * @returns true if the tracer provider was successfully registered, else false
       */
      TraceAPI.prototype.setGlobalTracerProvider = function (provider) {
        var success = registerGlobal(API_NAME, this._proxyTracerProvider, DiagAPI.instance());
        if (success) {
          this._proxyTracerProvider.setDelegate(provider);
        }
        return success;
      };
      /**
       * Returns the global tracer provider.
       */
      TraceAPI.prototype.getTracerProvider = function () {
        return getGlobal(API_NAME) || this._proxyTracerProvider;
      };
      /**
       * Returns a tracer from the global tracer provider.
       */
      TraceAPI.prototype.getTracer = function (name, version) {
        return this.getTracerProvider().getTracer(name, version);
      };
      /** Remove the global tracer provider */
      TraceAPI.prototype.disable = function () {
        unregisterGlobal(API_NAME, DiagAPI.instance());
        this._proxyTracerProvider = new ProxyTracerProvider();
      };
      return TraceAPI;
    }();

    /*
     * Copyright The OpenTelemetry Authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      https://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    // Split module-level variable definition into separate files to allow
    // tree-shaking on each api instance.
    /** Entrypoint for trace API */
    var trace = TraceAPI.getInstance();

    /*
     * Copyright The OpenTelemetry Authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      https://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    var NoopLogger = /** @class */function () {
      function NoopLogger() {}
      NoopLogger.prototype.emit = function (_logRecord) {};
      return NoopLogger;
    }();
    var NOOP_LOGGER = new NoopLogger();

    /*
     * Copyright The OpenTelemetry Authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      https://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    var NoopLoggerProvider = /** @class */function () {
      function NoopLoggerProvider() {}
      NoopLoggerProvider.prototype.getLogger = function (_name, _version, _options) {
        return new NoopLogger();
      };
      return NoopLoggerProvider;
    }();
    var NOOP_LOGGER_PROVIDER = new NoopLoggerProvider();

    /*
     * Copyright The OpenTelemetry Authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      https://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    var ProxyLogger = /** @class */function () {
      function ProxyLogger(_provider, name, version, options) {
        this._provider = _provider;
        this.name = name;
        this.version = version;
        this.options = options;
      }
      /**
       * Emit a log record. This method should only be used by log appenders.
       *
       * @param logRecord
       */
      ProxyLogger.prototype.emit = function (logRecord) {
        this._getLogger().emit(logRecord);
      };
      /**
       * Try to get a logger from the proxy logger provider.
       * If the proxy logger provider has no delegate, return a noop logger.
       */
      ProxyLogger.prototype._getLogger = function () {
        if (this._delegate) {
          return this._delegate;
        }
        var logger = this._provider.getDelegateLogger(this.name, this.version, this.options);
        if (!logger) {
          return NOOP_LOGGER;
        }
        this._delegate = logger;
        return this._delegate;
      };
      return ProxyLogger;
    }();

    /*
     * Copyright The OpenTelemetry Authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      https://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    var ProxyLoggerProvider = /** @class */function () {
      function ProxyLoggerProvider() {}
      ProxyLoggerProvider.prototype.getLogger = function (name, version, options) {
        var _a;
        return (_a = this.getDelegateLogger(name, version, options)) !== null && _a !== void 0 ? _a : new ProxyLogger(this, name, version, options);
      };
      ProxyLoggerProvider.prototype.getDelegate = function () {
        var _a;
        return (_a = this._delegate) !== null && _a !== void 0 ? _a : NOOP_LOGGER_PROVIDER;
      };
      /**
       * Set the delegate logger provider
       */
      ProxyLoggerProvider.prototype.setDelegate = function (delegate) {
        this._delegate = delegate;
      };
      ProxyLoggerProvider.prototype.getDelegateLogger = function (name, version, options) {
        var _a;
        return (_a = this._delegate) === null || _a === void 0 ? void 0 : _a.getLogger(name, version, options);
      };
      return ProxyLoggerProvider;
    }();

    /*
     * Copyright The OpenTelemetry Authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      https://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    // Updates to this file should also be replicated to @opentelemetry/api and
    // @opentelemetry/core too.
    /**
     * - globalThis (New standard)
     * - self (Will return the current window instance for supported browsers)
     * - window (fallback for older browser implementations)
     * - global (NodeJS implementation)
     * - <object> (When all else fails)
     */
    /** only globals that common to node and browsers are allowed */
    // eslint-disable-next-line node/no-unsupported-features/es-builtins, no-undef
    var _globalThis$1 = typeof globalThis === 'object' ? globalThis : typeof self === 'object' ? self : typeof window === 'object' ? window : typeof global === 'object' ? global : {};

    /*
     * Copyright The OpenTelemetry Authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      https://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    var GLOBAL_LOGS_API_KEY = Symbol.for('io.opentelemetry.js.api.logs');
    var _global = _globalThis$1;
    /**
     * Make a function which accepts a version integer and returns the instance of an API if the version
     * is compatible, or a fallback version (usually NOOP) if it is not.
     *
     * @param requiredVersion Backwards compatibility version which is required to return the instance
     * @param instance Instance which should be returned if the required version is compatible
     * @param fallback Fallback instance, usually NOOP, which will be returned if the required version is not compatible
     */
    function makeGetter(requiredVersion, instance, fallback) {
      return function (version) {
        return version === requiredVersion ? instance : fallback;
      };
    }
    /**
     * A number which should be incremented each time a backwards incompatible
     * change is made to the API. This number is used when an API package
     * attempts to access the global API to ensure it is getting a compatible
     * version. If the global API is not compatible with the API package
     * attempting to get it, a NOOP API implementation will be returned.
     */
    var API_BACKWARDS_COMPATIBILITY_VERSION = 1;

    /*
     * Copyright The OpenTelemetry Authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      https://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    var LogsAPI = /** @class */function () {
      function LogsAPI() {
        this._proxyLoggerProvider = new ProxyLoggerProvider();
      }
      LogsAPI.getInstance = function () {
        if (!this._instance) {
          this._instance = new LogsAPI();
        }
        return this._instance;
      };
      LogsAPI.prototype.setGlobalLoggerProvider = function (provider) {
        if (_global[GLOBAL_LOGS_API_KEY]) {
          return this.getLoggerProvider();
        }
        _global[GLOBAL_LOGS_API_KEY] = makeGetter(API_BACKWARDS_COMPATIBILITY_VERSION, provider, NOOP_LOGGER_PROVIDER);
        this._proxyLoggerProvider.setDelegate(provider);
        return provider;
      };
      /**
       * Returns the global logger provider.
       *
       * @returns LoggerProvider
       */
      LogsAPI.prototype.getLoggerProvider = function () {
        var _a, _b;
        return (_b = (_a = _global[GLOBAL_LOGS_API_KEY]) === null || _a === void 0 ? void 0 : _a.call(_global, API_BACKWARDS_COMPATIBILITY_VERSION)) !== null && _b !== void 0 ? _b : this._proxyLoggerProvider;
      };
      /**
       * Returns a logger from the global logger provider.
       *
       * @returns Logger
       */
      LogsAPI.prototype.getLogger = function (name, version, options) {
        return this.getLoggerProvider().getLogger(name, version, options);
      };
      /** Remove the global logger provider */
      LogsAPI.prototype.disable = function () {
        delete _global[GLOBAL_LOGS_API_KEY];
        this._proxyLoggerProvider = new ProxyLoggerProvider();
      };
      return LogsAPI;
    }();

    /*
     * Copyright The OpenTelemetry Authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      https://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    var logs = LogsAPI.getInstance();

    /*
     * Copyright The OpenTelemetry Authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      https://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    /**
     * Enable instrumentations
     * @param instrumentations
     * @param tracerProvider
     * @param meterProvider
     */
    function enableInstrumentations(instrumentations, tracerProvider, meterProvider, loggerProvider) {
      for (var i = 0, j = instrumentations.length; i < j; i++) {
        var instrumentation = instrumentations[i];
        if (tracerProvider) {
          instrumentation.setTracerProvider(tracerProvider);
        }
        if (meterProvider) {
          instrumentation.setMeterProvider(meterProvider);
        }
        if (loggerProvider && instrumentation.setLoggerProvider) {
          instrumentation.setLoggerProvider(loggerProvider);
        }
        // instrumentations have been already enabled during creation
        // so enable only if user prevented that by setting enabled to false
        // this is to prevent double enabling but when calling register all
        // instrumentations should be now enabled
        if (!instrumentation.getConfig().enabled) {
          instrumentation.enable();
        }
      }
    }
    /**
     * Disable instrumentations
     * @param instrumentations
     */
    function disableInstrumentations(instrumentations) {
      instrumentations.forEach(function (instrumentation) {
        return instrumentation.disable();
      });
    }

    /*
     * Copyright The OpenTelemetry Authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      https://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    /**
     * It will register instrumentations and plugins
     * @param options
     * @return returns function to unload instrumentation and plugins that were
     *   registered
     */
    function registerInstrumentations(options) {
      var _a, _b;
      var tracerProvider = options.tracerProvider || trace.getTracerProvider();
      var meterProvider = options.meterProvider || metrics.getMeterProvider();
      var loggerProvider = options.loggerProvider || logs.getLoggerProvider();
      var instrumentations = (_b = (_a = options.instrumentations) === null || _a === void 0 ? void 0 : _a.flat()) !== null && _b !== void 0 ? _b : [];
      enableInstrumentations(instrumentations, tracerProvider, meterProvider, loggerProvider);
      return function () {
        disableInstrumentations(instrumentations);
      };
    }

    var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

    function getDefaultExportFromCjs (x) {
    	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
    }

    var shimmer_1;
    var hasRequiredShimmer;
    function requireShimmer() {
      if (hasRequiredShimmer) return shimmer_1;
      hasRequiredShimmer = 1;
      function isFunction(funktion) {
        return typeof funktion === 'function';
      }

      // Default to complaining loudly when things don't go according to plan.
      var logger = console.error.bind(console);

      // Sets a property on an object, preserving its enumerability.
      // This function assumes that the property is already writable.
      function defineProperty(obj, name, value) {
        var enumerable = !!obj[name] && obj.propertyIsEnumerable(name);
        Object.defineProperty(obj, name, {
          configurable: true,
          enumerable: enumerable,
          writable: true,
          value: value
        });
      }

      // Keep initialization idempotent.
      function shimmer(options) {
        if (options && options.logger) {
          if (!isFunction(options.logger)) logger("new logger isn't a function, not replacing");else logger = options.logger;
        }
      }
      function wrap(nodule, name, wrapper) {
        if (!nodule || !nodule[name]) {
          logger('no original function ' + name + ' to wrap');
          return;
        }
        if (!wrapper) {
          logger('no wrapper function');
          logger(new Error().stack);
          return;
        }
        if (!isFunction(nodule[name]) || !isFunction(wrapper)) {
          logger('original object and wrapper must be functions');
          return;
        }
        var original = nodule[name];
        var wrapped = wrapper(original, name);
        defineProperty(wrapped, '__original', original);
        defineProperty(wrapped, '__unwrap', function () {
          if (nodule[name] === wrapped) defineProperty(nodule, name, original);
        });
        defineProperty(wrapped, '__wrapped', true);
        defineProperty(nodule, name, wrapped);
        return wrapped;
      }
      function massWrap(nodules, names, wrapper) {
        if (!nodules) {
          logger('must provide one or more modules to patch');
          logger(new Error().stack);
          return;
        } else if (!Array.isArray(nodules)) {
          nodules = [nodules];
        }
        if (!(names && Array.isArray(names))) {
          logger('must provide one or more functions to wrap on modules');
          return;
        }
        nodules.forEach(function (nodule) {
          names.forEach(function (name) {
            wrap(nodule, name, wrapper);
          });
        });
      }
      function unwrap(nodule, name) {
        if (!nodule || !nodule[name]) {
          logger('no function to unwrap.');
          logger(new Error().stack);
          return;
        }
        if (!nodule[name].__unwrap) {
          logger('no original to unwrap to -- has ' + name + ' already been unwrapped?');
        } else {
          return nodule[name].__unwrap();
        }
      }
      function massUnwrap(nodules, names) {
        if (!nodules) {
          logger('must provide one or more modules to patch');
          logger(new Error().stack);
          return;
        } else if (!Array.isArray(nodules)) {
          nodules = [nodules];
        }
        if (!(names && Array.isArray(names))) {
          logger('must provide one or more functions to unwrap on modules');
          return;
        }
        nodules.forEach(function (nodule) {
          names.forEach(function (name) {
            unwrap(nodule, name);
          });
        });
      }
      shimmer.wrap = wrap;
      shimmer.massWrap = massWrap;
      shimmer.unwrap = unwrap;
      shimmer.massUnwrap = massUnwrap;
      shimmer_1 = shimmer;
      return shimmer_1;
    }

    var shimmerExports = requireShimmer();

    /*
     * Copyright The OpenTelemetry Authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      https://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    var __assign$3 = undefined && undefined.__assign || function () {
      __assign$3 = Object.assign || function (t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
      };
      return __assign$3.apply(this, arguments);
    };
    /**
     * Base abstract internal class for instrumenting node and web plugins
     */
    var InstrumentationAbstract$1 = /** @class */function () {
      function InstrumentationAbstract(instrumentationName, instrumentationVersion, config) {
        this.instrumentationName = instrumentationName;
        this.instrumentationVersion = instrumentationVersion;
        this._config = {};
        /* Api to wrap instrumented method */
        this._wrap = shimmerExports.wrap;
        /* Api to unwrap instrumented methods */
        this._unwrap = shimmerExports.unwrap;
        /* Api to mass wrap instrumented method */
        this._massWrap = shimmerExports.massWrap;
        /* Api to mass unwrap instrumented methods */
        this._massUnwrap = shimmerExports.massUnwrap;
        this.setConfig(config);
        this._diag = diag.createComponentLogger({
          namespace: instrumentationName
        });
        this._tracer = trace.getTracer(instrumentationName, instrumentationVersion);
        this._meter = metrics.getMeter(instrumentationName, instrumentationVersion);
        this._logger = logs.getLogger(instrumentationName, instrumentationVersion);
        this._updateMetricInstruments();
      }
      Object.defineProperty(InstrumentationAbstract.prototype, "meter", {
        /* Returns meter */
        get: function () {
          return this._meter;
        },
        enumerable: false,
        configurable: true
      });
      /**
       * Sets MeterProvider to this plugin
       * @param meterProvider
       */
      InstrumentationAbstract.prototype.setMeterProvider = function (meterProvider) {
        this._meter = meterProvider.getMeter(this.instrumentationName, this.instrumentationVersion);
        this._updateMetricInstruments();
      };
      Object.defineProperty(InstrumentationAbstract.prototype, "logger", {
        /* Returns logger */
        get: function () {
          return this._logger;
        },
        enumerable: false,
        configurable: true
      });
      /**
       * Sets LoggerProvider to this plugin
       * @param loggerProvider
       */
      InstrumentationAbstract.prototype.setLoggerProvider = function (loggerProvider) {
        this._logger = loggerProvider.getLogger(this.instrumentationName, this.instrumentationVersion);
      };
      /**
       * @experimental
       *
       * Get module definitions defined by {@link init}.
       * This can be used for experimental compile-time instrumentation.
       *
       * @returns an array of {@link InstrumentationModuleDefinition}
       */
      InstrumentationAbstract.prototype.getModuleDefinitions = function () {
        var _a;
        var initResult = (_a = this.init()) !== null && _a !== void 0 ? _a : [];
        if (!Array.isArray(initResult)) {
          return [initResult];
        }
        return initResult;
      };
      /**
       * Sets the new metric instruments with the current Meter.
       */
      InstrumentationAbstract.prototype._updateMetricInstruments = function () {
        return;
      };
      /* Returns InstrumentationConfig */
      InstrumentationAbstract.prototype.getConfig = function () {
        return this._config;
      };
      /**
       * Sets InstrumentationConfig to this plugin
       * @param config
       */
      InstrumentationAbstract.prototype.setConfig = function (config) {
        // copy config first level properties to ensure they are immutable.
        // nested properties are not copied, thus are mutable from the outside.
        this._config = __assign$3({
          enabled: true
        }, config);
      };
      /**
       * Sets TraceProvider to this plugin
       * @param tracerProvider
       */
      InstrumentationAbstract.prototype.setTracerProvider = function (tracerProvider) {
        this._tracer = tracerProvider.getTracer(this.instrumentationName, this.instrumentationVersion);
      };
      Object.defineProperty(InstrumentationAbstract.prototype, "tracer", {
        /* Returns tracer */
        get: function () {
          return this._tracer;
        },
        enumerable: false,
        configurable: true
      });
      /**
       * Execute span customization hook, if configured, and log any errors.
       * Any semantics of the trigger and info are defined by the specific instrumentation.
       * @param hookHandler The optional hook handler which the user has configured via instrumentation config
       * @param triggerName The name of the trigger for executing the hook for logging purposes
       * @param span The span to which the hook should be applied
       * @param info The info object to be passed to the hook, with useful data the hook may use
       */
      InstrumentationAbstract.prototype._runSpanCustomizationHook = function (hookHandler, triggerName, span, info) {
        if (!hookHandler) {
          return;
        }
        try {
          hookHandler(span, info);
        } catch (e) {
          this._diag.error("Error running span customization hook due to exception in handler", {
            triggerName: triggerName
          }, e);
        }
      };
      return InstrumentationAbstract;
    }();

    /*
     * Copyright The OpenTelemetry Authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      https://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    var __extends$8 = undefined && undefined.__extends || function () {
      var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf || {
          __proto__: []
        } instanceof Array && function (d, b) {
          d.__proto__ = b;
        } || function (d, b) {
          for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
        };
        return extendStatics(d, b);
      };
      return function (d, b) {
        if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    /**
     * Base abstract class for instrumenting web plugins
     */
    var InstrumentationBase = /** @class */function (_super) {
      __extends$8(InstrumentationBase, _super);
      function InstrumentationBase(instrumentationName, instrumentationVersion, config) {
        var _this = _super.call(this, instrumentationName, instrumentationVersion, config) || this;
        if (_this._config.enabled) {
          _this.enable();
        }
        return _this;
      }
      return InstrumentationBase;
    }(InstrumentationAbstract$1);

    /*
     * Copyright The OpenTelemetry Authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      https://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    undefined && undefined.__awaiter || function (thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function (resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    undefined && undefined.__generator || function (thisArg, body) {
      var _ = {
          label: 0,
          sent: function () {
            if (t[0] & 1) throw t[1];
            return t[1];
          },
          trys: [],
          ops: []
        },
        f,
        y,
        t,
        g;
      return g = {
        next: verb(0),
        "throw": verb(1),
        "return": verb(2)
      }, typeof Symbol === "function" && (g[Symbol.iterator] = function () {
        return this;
      }), g;
      function verb(n) {
        return function (v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
          if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
          if (y = 0, t) op = [op[0] & 2, t.value];
          switch (op[0]) {
            case 0:
            case 1:
              t = op;
              break;
            case 4:
              _.label++;
              return {
                value: op[1],
                done: false
              };
            case 5:
              _.label++;
              y = op[1];
              op = [0];
              continue;
            case 7:
              op = _.ops.pop();
              _.trys.pop();
              continue;
            default:
              if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                _ = 0;
                continue;
              }
              if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                _.label = op[1];
                break;
              }
              if (op[0] === 6 && _.label < t[1]) {
                _.label = t[1];
                t = op;
                break;
              }
              if (t && _.label < t[2]) {
                _.label = t[2];
                _.ops.push(op);
                break;
              }
              if (t[2]) _.ops.pop();
              _.trys.pop();
              continue;
          }
          op = body.call(thisArg, _);
        } catch (e) {
          op = [6, e];
          y = 0;
        } finally {
          f = t = 0;
        }
        if (op[0] & 5) throw op[1];
        return {
          value: op[0] ? op[1] : void 0,
          done: true
        };
      }
    };
    /**
     * function to execute patched function and being able to catch errors
     * @param execute - function to be executed
     * @param onFinish - callback to run when execute finishes
     */
    function safeExecuteInTheMiddle(execute, onFinish, preventThrowingError) {
      var error;
      var result;
      try {
        result = execute();
      } catch (e) {
        error = e;
      } finally {
        onFinish(error, result);
        // eslint-disable-next-line no-unsafe-finally
        return result;
      }
    }
    /**
     * Checks if certain function has been already wrapped
     * @param func
     */
    function isWrapped(func) {
      return typeof func === 'function' && typeof func.__original === 'function' && typeof func.__unwrap === 'function' && func.__wrapped === true;
    }

    /*
     * Copyright The OpenTelemetry Authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      https://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    var TMP_SERVICE_NAME$1 = 'service.name';
    var TMP_TELEMETRY_SDK_NAME$1 = 'telemetry.sdk.name';
    var TMP_TELEMETRY_SDK_LANGUAGE$1 = 'telemetry.sdk.language';
    var TMP_TELEMETRY_SDK_VERSION$1 = 'telemetry.sdk.version';
    /**
     * Logical name of the service.
     *
     * Note: MUST be the same for all instances of horizontally scaled services. If the value was not specified, SDKs MUST fallback to `unknown_service:` concatenated with [`process.executable.name`](process.md#process), e.g. `unknown_service:bash`. If `process.executable.name` is not available, the value MUST be set to `unknown_service`.
     *
     * @deprecated Use ATTR_SERVICE_NAME.
     */
    var SEMRESATTRS_SERVICE_NAME$1 = TMP_SERVICE_NAME$1;
    /**
     * The name of the telemetry SDK as defined above.
     *
     * @deprecated Use ATTR_TELEMETRY_SDK_NAME.
     */
    var SEMRESATTRS_TELEMETRY_SDK_NAME$1 = TMP_TELEMETRY_SDK_NAME$1;
    /**
     * The language of the telemetry SDK.
     *
     * @deprecated Use ATTR_TELEMETRY_SDK_LANGUAGE.
     */
    var SEMRESATTRS_TELEMETRY_SDK_LANGUAGE$1 = TMP_TELEMETRY_SDK_LANGUAGE$1;
    /**
     * The version string of the telemetry SDK.
     *
     * @deprecated Use ATTR_TELEMETRY_SDK_VERSION.
     */
    var SEMRESATTRS_TELEMETRY_SDK_VERSION$1 = TMP_TELEMETRY_SDK_VERSION$1;

    /*
     * Copyright The OpenTelemetry Authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      https://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    var SUPPRESS_TRACING_KEY = createContextKey('OpenTelemetry SDK Context Key SUPPRESS_TRACING');
    function suppressTracing(context) {
      return context.setValue(SUPPRESS_TRACING_KEY, true);
    }
    function isTracingSuppressed(context) {
      return context.getValue(SUPPRESS_TRACING_KEY) === true;
    }

    /*
     * Copyright The OpenTelemetry Authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      https://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    var BAGGAGE_KEY_PAIR_SEPARATOR = '=';
    var BAGGAGE_PROPERTIES_SEPARATOR = ';';
    var BAGGAGE_ITEMS_SEPARATOR = ',';
    // Name of the http header used to propagate the baggage
    var BAGGAGE_HEADER = 'baggage';
    // Maximum number of name-value pairs allowed by w3c spec
    var BAGGAGE_MAX_NAME_VALUE_PAIRS = 180;
    // Maximum number of bytes per a single name-value pair allowed by w3c spec
    var BAGGAGE_MAX_PER_NAME_VALUE_PAIRS = 4096;
    // Maximum total length of all name-value pairs allowed by w3c spec
    var BAGGAGE_MAX_TOTAL_LENGTH = 8192;

    var __read$d = undefined && undefined.__read || function (o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m) return o;
      var i = m.call(o),
        r,
        ar = [],
        e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
      } catch (error) {
        e = {
          error: error
        };
      } finally {
        try {
          if (r && !r.done && (m = i["return"])) m.call(i);
        } finally {
          if (e) throw e.error;
        }
      }
      return ar;
    };
    function serializeKeyPairs(keyPairs) {
      return keyPairs.reduce(function (hValue, current) {
        var value = "" + hValue + (hValue !== '' ? BAGGAGE_ITEMS_SEPARATOR : '') + current;
        return value.length > BAGGAGE_MAX_TOTAL_LENGTH ? hValue : value;
      }, '');
    }
    function getKeyPairs(baggage) {
      return baggage.getAllEntries().map(function (_a) {
        var _b = __read$d(_a, 2),
          key = _b[0],
          value = _b[1];
        var entry = encodeURIComponent(key) + "=" + encodeURIComponent(value.value);
        // include opaque metadata if provided
        // NOTE: we intentionally don't URI-encode the metadata - that responsibility falls on the metadata implementation
        if (value.metadata !== undefined) {
          entry += BAGGAGE_PROPERTIES_SEPARATOR + value.metadata.toString();
        }
        return entry;
      });
    }
    function parsePairKeyValue(entry) {
      var valueProps = entry.split(BAGGAGE_PROPERTIES_SEPARATOR);
      if (valueProps.length <= 0) return;
      var keyPairPart = valueProps.shift();
      if (!keyPairPart) return;
      var separatorIndex = keyPairPart.indexOf(BAGGAGE_KEY_PAIR_SEPARATOR);
      if (separatorIndex <= 0) return;
      var key = decodeURIComponent(keyPairPart.substring(0, separatorIndex).trim());
      var value = decodeURIComponent(keyPairPart.substring(separatorIndex + 1).trim());
      var metadata;
      if (valueProps.length > 0) {
        metadata = baggageEntryMetadataFromString(valueProps.join(BAGGAGE_PROPERTIES_SEPARATOR));
      }
      return {
        key: key,
        value: value,
        metadata: metadata
      };
    }

    /*
     * Copyright The OpenTelemetry Authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      https://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    /**
     * Propagates {@link Baggage} through Context format propagation.
     *
     * Based on the Baggage specification:
     * https://w3c.github.io/baggage/
     */
    var W3CBaggagePropagator = /** @class */function () {
      function W3CBaggagePropagator() {}
      W3CBaggagePropagator.prototype.inject = function (context, carrier, setter) {
        var baggage = propagation.getBaggage(context);
        if (!baggage || isTracingSuppressed(context)) return;
        var keyPairs = getKeyPairs(baggage).filter(function (pair) {
          return pair.length <= BAGGAGE_MAX_PER_NAME_VALUE_PAIRS;
        }).slice(0, BAGGAGE_MAX_NAME_VALUE_PAIRS);
        var headerValue = serializeKeyPairs(keyPairs);
        if (headerValue.length > 0) {
          setter.set(carrier, BAGGAGE_HEADER, headerValue);
        }
      };
      W3CBaggagePropagator.prototype.extract = function (context, carrier, getter) {
        var headerValue = getter.get(carrier, BAGGAGE_HEADER);
        var baggageString = Array.isArray(headerValue) ? headerValue.join(BAGGAGE_ITEMS_SEPARATOR) : headerValue;
        if (!baggageString) return context;
        var baggage = {};
        if (baggageString.length === 0) {
          return context;
        }
        var pairs = baggageString.split(BAGGAGE_ITEMS_SEPARATOR);
        pairs.forEach(function (entry) {
          var keyPair = parsePairKeyValue(entry);
          if (keyPair) {
            var baggageEntry = {
              value: keyPair.value
            };
            if (keyPair.metadata) {
              baggageEntry.metadata = keyPair.metadata;
            }
            baggage[keyPair.key] = baggageEntry;
          }
        });
        if (Object.entries(baggage).length === 0) {
          return context;
        }
        return propagation.setBaggage(context, propagation.createBaggage(baggage));
      };
      W3CBaggagePropagator.prototype.fields = function () {
        return [BAGGAGE_HEADER];
      };
      return W3CBaggagePropagator;
    }();

    /*
     * Copyright The OpenTelemetry Authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      https://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    var __values$7 = undefined && undefined.__values || function (o) {
      var s = typeof Symbol === "function" && Symbol.iterator,
        m = s && o[s],
        i = 0;
      if (m) return m.call(o);
      if (o && typeof o.length === "number") return {
        next: function () {
          if (o && i >= o.length) o = void 0;
          return {
            value: o && o[i++],
            done: !o
          };
        }
      };
      throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    };
    var __read$c = undefined && undefined.__read || function (o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m) return o;
      var i = m.call(o),
        r,
        ar = [],
        e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
      } catch (error) {
        e = {
          error: error
        };
      } finally {
        try {
          if (r && !r.done && (m = i["return"])) m.call(i);
        } finally {
          if (e) throw e.error;
        }
      }
      return ar;
    };
    function sanitizeAttributes(attributes) {
      var e_1, _a;
      var out = {};
      if (typeof attributes !== 'object' || attributes == null) {
        return out;
      }
      try {
        for (var _b = __values$7(Object.entries(attributes)), _c = _b.next(); !_c.done; _c = _b.next()) {
          var _d = __read$c(_c.value, 2),
            key = _d[0],
            val = _d[1];
          if (!isAttributeKey(key)) {
            diag.warn("Invalid attribute key: " + key);
            continue;
          }
          if (!isAttributeValue(val)) {
            diag.warn("Invalid attribute value set for key: " + key);
            continue;
          }
          if (Array.isArray(val)) {
            out[key] = val.slice();
          } else {
            out[key] = val;
          }
        }
      } catch (e_1_1) {
        e_1 = {
          error: e_1_1
        };
      } finally {
        try {
          if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
        } finally {
          if (e_1) throw e_1.error;
        }
      }
      return out;
    }
    function isAttributeKey(key) {
      return typeof key === 'string' && key.length > 0;
    }
    function isAttributeValue(val) {
      if (val == null) {
        return true;
      }
      if (Array.isArray(val)) {
        return isHomogeneousAttributeValueArray(val);
      }
      return isValidPrimitiveAttributeValue(val);
    }
    function isHomogeneousAttributeValueArray(arr) {
      var e_2, _a;
      var type;
      try {
        for (var arr_1 = __values$7(arr), arr_1_1 = arr_1.next(); !arr_1_1.done; arr_1_1 = arr_1.next()) {
          var element = arr_1_1.value;
          // null/undefined elements are allowed
          if (element == null) continue;
          if (!type) {
            if (isValidPrimitiveAttributeValue(element)) {
              type = typeof element;
              continue;
            }
            // encountered an invalid primitive
            return false;
          }
          if (typeof element === type) {
            continue;
          }
          return false;
        }
      } catch (e_2_1) {
        e_2 = {
          error: e_2_1
        };
      } finally {
        try {
          if (arr_1_1 && !arr_1_1.done && (_a = arr_1.return)) _a.call(arr_1);
        } finally {
          if (e_2) throw e_2.error;
        }
      }
      return true;
    }
    function isValidPrimitiveAttributeValue(val) {
      switch (typeof val) {
        case 'number':
        case 'boolean':
        case 'string':
          return true;
      }
      return false;
    }

    /*
     * Copyright The OpenTelemetry Authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      https://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    /**
     * Returns a function that logs an error using the provided logger, or a
     * console logger if one was not provided.
     */
    function loggingErrorHandler() {
      return function (ex) {
        diag.error(stringifyException(ex));
      };
    }
    /**
     * Converts an exception into a string representation
     * @param {Exception} ex
     */
    function stringifyException(ex) {
      if (typeof ex === 'string') {
        return ex;
      } else {
        return JSON.stringify(flattenException(ex));
      }
    }
    /**
     * Flattens an exception into key-value pairs by traversing the prototype chain
     * and coercing values to strings. Duplicate properties will not be overwritten;
     * the first insert wins.
     */
    function flattenException(ex) {
      var result = {};
      var current = ex;
      while (current !== null) {
        Object.getOwnPropertyNames(current).forEach(function (propertyName) {
          if (result[propertyName]) return;
          var value = current[propertyName];
          if (value) {
            result[propertyName] = String(value);
          }
        });
        current = Object.getPrototypeOf(current);
      }
      return result;
    }

    /*
     * Copyright The OpenTelemetry Authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      https://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    /** The global error handler delegate */
    var delegateHandler = loggingErrorHandler();
    /**
     * Return the global error handler
     * @param {Exception} ex
     */
    function globalErrorHandler(ex) {
      try {
        delegateHandler(ex);
      } catch (_a) {} // eslint-disable-line no-empty
    }

    /*
     * Copyright The OpenTelemetry Authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      https://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    var TracesSamplerValues;
    (function (TracesSamplerValues) {
      TracesSamplerValues["AlwaysOff"] = "always_off";
      TracesSamplerValues["AlwaysOn"] = "always_on";
      TracesSamplerValues["ParentBasedAlwaysOff"] = "parentbased_always_off";
      TracesSamplerValues["ParentBasedAlwaysOn"] = "parentbased_always_on";
      TracesSamplerValues["ParentBasedTraceIdRatio"] = "parentbased_traceidratio";
      TracesSamplerValues["TraceIdRatio"] = "traceidratio";
    })(TracesSamplerValues || (TracesSamplerValues = {}));

    /*
     * Copyright The OpenTelemetry Authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      https://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    var DEFAULT_LIST_SEPARATOR = ',';
    /**
     * Environment interface to define all names
     */
    var ENVIRONMENT_BOOLEAN_KEYS = ['OTEL_SDK_DISABLED'];
    function isEnvVarABoolean(key) {
      return ENVIRONMENT_BOOLEAN_KEYS.indexOf(key) > -1;
    }
    var ENVIRONMENT_NUMBERS_KEYS = ['OTEL_BSP_EXPORT_TIMEOUT', 'OTEL_BSP_MAX_EXPORT_BATCH_SIZE', 'OTEL_BSP_MAX_QUEUE_SIZE', 'OTEL_BSP_SCHEDULE_DELAY', 'OTEL_BLRP_EXPORT_TIMEOUT', 'OTEL_BLRP_MAX_EXPORT_BATCH_SIZE', 'OTEL_BLRP_MAX_QUEUE_SIZE', 'OTEL_BLRP_SCHEDULE_DELAY', 'OTEL_ATTRIBUTE_VALUE_LENGTH_LIMIT', 'OTEL_ATTRIBUTE_COUNT_LIMIT', 'OTEL_SPAN_ATTRIBUTE_VALUE_LENGTH_LIMIT', 'OTEL_SPAN_ATTRIBUTE_COUNT_LIMIT', 'OTEL_LOGRECORD_ATTRIBUTE_VALUE_LENGTH_LIMIT', 'OTEL_LOGRECORD_ATTRIBUTE_COUNT_LIMIT', 'OTEL_SPAN_EVENT_COUNT_LIMIT', 'OTEL_SPAN_LINK_COUNT_LIMIT', 'OTEL_SPAN_ATTRIBUTE_PER_EVENT_COUNT_LIMIT', 'OTEL_SPAN_ATTRIBUTE_PER_LINK_COUNT_LIMIT', 'OTEL_EXPORTER_OTLP_TIMEOUT', 'OTEL_EXPORTER_OTLP_TRACES_TIMEOUT', 'OTEL_EXPORTER_OTLP_METRICS_TIMEOUT', 'OTEL_EXPORTER_OTLP_LOGS_TIMEOUT', 'OTEL_EXPORTER_JAEGER_AGENT_PORT'];
    function isEnvVarANumber(key) {
      return ENVIRONMENT_NUMBERS_KEYS.indexOf(key) > -1;
    }
    var ENVIRONMENT_LISTS_KEYS = ['OTEL_NO_PATCH_MODULES', 'OTEL_PROPAGATORS', 'OTEL_SEMCONV_STABILITY_OPT_IN'];
    function isEnvVarAList(key) {
      return ENVIRONMENT_LISTS_KEYS.indexOf(key) > -1;
    }
    var DEFAULT_ATTRIBUTE_VALUE_LENGTH_LIMIT = Infinity;
    var DEFAULT_ATTRIBUTE_COUNT_LIMIT = 128;
    var DEFAULT_SPAN_ATTRIBUTE_PER_EVENT_COUNT_LIMIT = 128;
    var DEFAULT_SPAN_ATTRIBUTE_PER_LINK_COUNT_LIMIT = 128;
    /**
     * Default environment variables
     */
    var DEFAULT_ENVIRONMENT = {
      OTEL_SDK_DISABLED: false,
      CONTAINER_NAME: '',
      ECS_CONTAINER_METADATA_URI_V4: '',
      ECS_CONTAINER_METADATA_URI: '',
      HOSTNAME: '',
      KUBERNETES_SERVICE_HOST: '',
      NAMESPACE: '',
      OTEL_BSP_EXPORT_TIMEOUT: 30000,
      OTEL_BSP_MAX_EXPORT_BATCH_SIZE: 512,
      OTEL_BSP_MAX_QUEUE_SIZE: 2048,
      OTEL_BSP_SCHEDULE_DELAY: 5000,
      OTEL_BLRP_EXPORT_TIMEOUT: 30000,
      OTEL_BLRP_MAX_EXPORT_BATCH_SIZE: 512,
      OTEL_BLRP_MAX_QUEUE_SIZE: 2048,
      OTEL_BLRP_SCHEDULE_DELAY: 5000,
      OTEL_EXPORTER_JAEGER_AGENT_HOST: '',
      OTEL_EXPORTER_JAEGER_AGENT_PORT: 6832,
      OTEL_EXPORTER_JAEGER_ENDPOINT: '',
      OTEL_EXPORTER_JAEGER_PASSWORD: '',
      OTEL_EXPORTER_JAEGER_USER: '',
      OTEL_EXPORTER_OTLP_ENDPOINT: '',
      OTEL_EXPORTER_OTLP_TRACES_ENDPOINT: '',
      OTEL_EXPORTER_OTLP_METRICS_ENDPOINT: '',
      OTEL_EXPORTER_OTLP_LOGS_ENDPOINT: '',
      OTEL_EXPORTER_OTLP_HEADERS: '',
      OTEL_EXPORTER_OTLP_TRACES_HEADERS: '',
      OTEL_EXPORTER_OTLP_METRICS_HEADERS: '',
      OTEL_EXPORTER_OTLP_LOGS_HEADERS: '',
      OTEL_EXPORTER_OTLP_TIMEOUT: 10000,
      OTEL_EXPORTER_OTLP_TRACES_TIMEOUT: 10000,
      OTEL_EXPORTER_OTLP_METRICS_TIMEOUT: 10000,
      OTEL_EXPORTER_OTLP_LOGS_TIMEOUT: 10000,
      OTEL_EXPORTER_ZIPKIN_ENDPOINT: 'http://localhost:9411/api/v2/spans',
      OTEL_LOG_LEVEL: DiagLogLevel.INFO,
      OTEL_NO_PATCH_MODULES: [],
      OTEL_PROPAGATORS: ['tracecontext', 'baggage'],
      OTEL_RESOURCE_ATTRIBUTES: '',
      OTEL_SERVICE_NAME: '',
      OTEL_ATTRIBUTE_VALUE_LENGTH_LIMIT: DEFAULT_ATTRIBUTE_VALUE_LENGTH_LIMIT,
      OTEL_ATTRIBUTE_COUNT_LIMIT: DEFAULT_ATTRIBUTE_COUNT_LIMIT,
      OTEL_SPAN_ATTRIBUTE_VALUE_LENGTH_LIMIT: DEFAULT_ATTRIBUTE_VALUE_LENGTH_LIMIT,
      OTEL_SPAN_ATTRIBUTE_COUNT_LIMIT: DEFAULT_ATTRIBUTE_COUNT_LIMIT,
      OTEL_LOGRECORD_ATTRIBUTE_VALUE_LENGTH_LIMIT: DEFAULT_ATTRIBUTE_VALUE_LENGTH_LIMIT,
      OTEL_LOGRECORD_ATTRIBUTE_COUNT_LIMIT: DEFAULT_ATTRIBUTE_COUNT_LIMIT,
      OTEL_SPAN_EVENT_COUNT_LIMIT: 128,
      OTEL_SPAN_LINK_COUNT_LIMIT: 128,
      OTEL_SPAN_ATTRIBUTE_PER_EVENT_COUNT_LIMIT: DEFAULT_SPAN_ATTRIBUTE_PER_EVENT_COUNT_LIMIT,
      OTEL_SPAN_ATTRIBUTE_PER_LINK_COUNT_LIMIT: DEFAULT_SPAN_ATTRIBUTE_PER_LINK_COUNT_LIMIT,
      OTEL_TRACES_EXPORTER: '',
      OTEL_TRACES_SAMPLER: TracesSamplerValues.ParentBasedAlwaysOn,
      OTEL_TRACES_SAMPLER_ARG: '',
      OTEL_LOGS_EXPORTER: '',
      OTEL_EXPORTER_OTLP_INSECURE: '',
      OTEL_EXPORTER_OTLP_TRACES_INSECURE: '',
      OTEL_EXPORTER_OTLP_METRICS_INSECURE: '',
      OTEL_EXPORTER_OTLP_LOGS_INSECURE: '',
      OTEL_EXPORTER_OTLP_CERTIFICATE: '',
      OTEL_EXPORTER_OTLP_TRACES_CERTIFICATE: '',
      OTEL_EXPORTER_OTLP_METRICS_CERTIFICATE: '',
      OTEL_EXPORTER_OTLP_LOGS_CERTIFICATE: '',
      OTEL_EXPORTER_OTLP_COMPRESSION: '',
      OTEL_EXPORTER_OTLP_TRACES_COMPRESSION: '',
      OTEL_EXPORTER_OTLP_METRICS_COMPRESSION: '',
      OTEL_EXPORTER_OTLP_LOGS_COMPRESSION: '',
      OTEL_EXPORTER_OTLP_CLIENT_KEY: '',
      OTEL_EXPORTER_OTLP_TRACES_CLIENT_KEY: '',
      OTEL_EXPORTER_OTLP_METRICS_CLIENT_KEY: '',
      OTEL_EXPORTER_OTLP_LOGS_CLIENT_KEY: '',
      OTEL_EXPORTER_OTLP_CLIENT_CERTIFICATE: '',
      OTEL_EXPORTER_OTLP_TRACES_CLIENT_CERTIFICATE: '',
      OTEL_EXPORTER_OTLP_METRICS_CLIENT_CERTIFICATE: '',
      OTEL_EXPORTER_OTLP_LOGS_CLIENT_CERTIFICATE: '',
      OTEL_EXPORTER_OTLP_PROTOCOL: 'http/protobuf',
      OTEL_EXPORTER_OTLP_TRACES_PROTOCOL: 'http/protobuf',
      OTEL_EXPORTER_OTLP_METRICS_PROTOCOL: 'http/protobuf',
      OTEL_EXPORTER_OTLP_LOGS_PROTOCOL: 'http/protobuf',
      OTEL_EXPORTER_OTLP_METRICS_TEMPORALITY_PREFERENCE: 'cumulative',
      OTEL_SEMCONV_STABILITY_OPT_IN: []
    };
    /**
     * @param key
     * @param environment
     * @param values
     */
    function parseBoolean(key, environment, values) {
      if (typeof values[key] === 'undefined') {
        return;
      }
      var value = String(values[key]);
      // support case-insensitive "true"
      environment[key] = value.toLowerCase() === 'true';
    }
    /**
     * Parses a variable as number with number validation
     * @param name
     * @param environment
     * @param values
     * @param min
     * @param max
     */
    function parseNumber(name, environment, values, min, max) {
      if (min === void 0) {
        min = -Infinity;
      }
      if (max === void 0) {
        max = Infinity;
      }
      if (typeof values[name] !== 'undefined') {
        var value = Number(values[name]);
        if (!isNaN(value)) {
          if (value < min) {
            environment[name] = min;
          } else if (value > max) {
            environment[name] = max;
          } else {
            environment[name] = value;
          }
        }
      }
    }
    /**
     * Parses list-like strings from input into output.
     * @param name
     * @param environment
     * @param values
     * @param separator
     */
    function parseStringList(name, output, input, separator) {
      if (separator === void 0) {
        separator = DEFAULT_LIST_SEPARATOR;
      }
      var givenValue = input[name];
      if (typeof givenValue === 'string') {
        output[name] = givenValue.split(separator).map(function (v) {
          return v.trim();
        });
      }
    }
    // The support string -> DiagLogLevel mappings
    var logLevelMap = {
      ALL: DiagLogLevel.ALL,
      VERBOSE: DiagLogLevel.VERBOSE,
      DEBUG: DiagLogLevel.DEBUG,
      INFO: DiagLogLevel.INFO,
      WARN: DiagLogLevel.WARN,
      ERROR: DiagLogLevel.ERROR,
      NONE: DiagLogLevel.NONE
    };
    /**
     * Environmentally sets log level if valid log level string is provided
     * @param key
     * @param environment
     * @param values
     */
    function setLogLevelFromEnv(key, environment, values) {
      var value = values[key];
      if (typeof value === 'string') {
        var theLevel = logLevelMap[value.toUpperCase()];
        if (theLevel != null) {
          environment[key] = theLevel;
        }
      }
    }
    /**
     * Parses environment values
     * @param values
     */
    function parseEnvironment(values) {
      var environment = {};
      for (var env in DEFAULT_ENVIRONMENT) {
        var key = env;
        switch (key) {
          case 'OTEL_LOG_LEVEL':
            setLogLevelFromEnv(key, environment, values);
            break;
          default:
            if (isEnvVarABoolean(key)) {
              parseBoolean(key, environment, values);
            } else if (isEnvVarANumber(key)) {
              parseNumber(key, environment, values);
            } else if (isEnvVarAList(key)) {
              parseStringList(key, environment, values);
            } else {
              var value = values[key];
              if (typeof value !== 'undefined' && value !== null) {
                environment[key] = String(value);
              }
            }
        }
      }
      return environment;
    }

    /*
     * Copyright The OpenTelemetry Authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      https://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    // Updates to this file should also be replicated to @opentelemetry/api too.
    /**
     * - globalThis (New standard)
     * - self (Will return the current window instance for supported browsers)
     * - window (fallback for older browser implementations)
     * - global (NodeJS implementation)
     * - <object> (When all else fails)
     */
    /** only globals that common to node and browsers are allowed */
    // eslint-disable-next-line node/no-unsupported-features/es-builtins, no-undef
    var _globalThis = typeof globalThis === 'object' ? globalThis : typeof self === 'object' ? self : typeof window === 'object' ? window : typeof global === 'object' ? global : {};

    /*
     * Copyright The OpenTelemetry Authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      https://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    /**
     * Gets the environment variables
     */
    function getEnv() {
      var globalEnv = parseEnvironment(_globalThis);
      return Object.assign({}, DEFAULT_ENVIRONMENT, globalEnv);
    }
    function getEnvWithoutDefaults() {
      return parseEnvironment(_globalThis);
    }

    /*
     * Copyright The OpenTelemetry Authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      https://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    function intValue(charCode) {
      // 0-9
      if (charCode >= 48 && charCode <= 57) {
        return charCode - 48;
      }
      // a-f
      if (charCode >= 97 && charCode <= 102) {
        return charCode - 87;
      }
      // A-F
      return charCode - 55;
    }
    function hexToBinary(hexStr) {
      var buf = new Uint8Array(hexStr.length / 2);
      var offset = 0;
      for (var i = 0; i < hexStr.length; i += 2) {
        var hi = intValue(hexStr.charCodeAt(i));
        var lo = intValue(hexStr.charCodeAt(i + 1));
        buf[offset++] = hi << 4 | lo;
      }
      return buf;
    }

    /*
     * Copyright The OpenTelemetry Authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      https://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    var otperformance = performance;

    /*
     * Copyright The OpenTelemetry Authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      https://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    // this is autogenerated file, see scripts/version-update.js
    var VERSION$4 = '1.30.1';

    /*
     * Copyright The OpenTelemetry Authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      https://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    var TMP_PROCESS_RUNTIME_NAME = 'process.runtime.name';
    var TMP_TELEMETRY_SDK_NAME = 'telemetry.sdk.name';
    var TMP_TELEMETRY_SDK_LANGUAGE = 'telemetry.sdk.language';
    var TMP_TELEMETRY_SDK_VERSION = 'telemetry.sdk.version';
    /**
     * The name of the runtime of this process. For compiled native binaries, this SHOULD be the name of the compiler.
     *
     * @deprecated Use ATTR_PROCESS_RUNTIME_NAME in [incubating entry-point]({@link https://github.com/open-telemetry/opentelemetry-js/blob/main/semantic-conventions/README.md#unstable-semconv}).
     */
    var SEMRESATTRS_PROCESS_RUNTIME_NAME = TMP_PROCESS_RUNTIME_NAME;
    /**
     * The name of the telemetry SDK as defined above.
     *
     * @deprecated Use ATTR_TELEMETRY_SDK_NAME.
     */
    var SEMRESATTRS_TELEMETRY_SDK_NAME = TMP_TELEMETRY_SDK_NAME;
    /**
     * The language of the telemetry SDK.
     *
     * @deprecated Use ATTR_TELEMETRY_SDK_LANGUAGE.
     */
    var SEMRESATTRS_TELEMETRY_SDK_LANGUAGE = TMP_TELEMETRY_SDK_LANGUAGE;
    /**
     * The version string of the telemetry SDK.
     *
     * @deprecated Use ATTR_TELEMETRY_SDK_VERSION.
     */
    var SEMRESATTRS_TELEMETRY_SDK_VERSION = TMP_TELEMETRY_SDK_VERSION;
    var TMP_TELEMETRYSDKLANGUAGEVALUES_WEBJS = 'webjs';
    /**
     * The language of the telemetry SDK.
     *
     * @deprecated Use TELEMETRY_SDK_LANGUAGE_VALUE_WEBJS.
     */
    var TELEMETRYSDKLANGUAGEVALUES_WEBJS = TMP_TELEMETRYSDKLANGUAGEVALUES_WEBJS;

    /*
     * Copyright The OpenTelemetry Authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      https://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    var _a$1;
    /** Constants describing the SDK in use */
    var SDK_INFO = (_a$1 = {}, _a$1[SEMRESATTRS_TELEMETRY_SDK_NAME] = 'opentelemetry', _a$1[SEMRESATTRS_PROCESS_RUNTIME_NAME] = 'browser', _a$1[SEMRESATTRS_TELEMETRY_SDK_LANGUAGE] = TELEMETRYSDKLANGUAGEVALUES_WEBJS, _a$1[SEMRESATTRS_TELEMETRY_SDK_VERSION] = VERSION$4, _a$1);

    /*
     * Copyright The OpenTelemetry Authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      https://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    function unrefTimer(_timer) {}

    /*
     * Copyright The OpenTelemetry Authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      https://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    var NANOSECOND_DIGITS = 9;
    var NANOSECOND_DIGITS_IN_MILLIS = 6;
    var MILLISECONDS_TO_NANOSECONDS = Math.pow(10, NANOSECOND_DIGITS_IN_MILLIS);
    var SECOND_TO_NANOSECONDS = Math.pow(10, NANOSECOND_DIGITS);
    /**
     * Converts a number of milliseconds from epoch to HrTime([seconds, remainder in nanoseconds]).
     * @param epochMillis
     */
    function millisToHrTime(epochMillis) {
      var epochSeconds = epochMillis / 1000;
      // Decimals only.
      var seconds = Math.trunc(epochSeconds);
      // Round sub-nanosecond accuracy to nanosecond.
      var nanos = Math.round(epochMillis % 1000 * MILLISECONDS_TO_NANOSECONDS);
      return [seconds, nanos];
    }
    function getTimeOrigin() {
      var timeOrigin = otperformance.timeOrigin;
      if (typeof timeOrigin !== 'number') {
        var perf = otperformance;
        timeOrigin = perf.timing && perf.timing.fetchStart;
      }
      return timeOrigin;
    }
    /**
     * Returns an hrtime calculated via performance component.
     * @param performanceNow
     */
    function hrTime(performanceNow) {
      var timeOrigin = millisToHrTime(getTimeOrigin());
      var now = millisToHrTime(typeof performanceNow === 'number' ? performanceNow : otperformance.now());
      return addHrTimes(timeOrigin, now);
    }
    /**
     *
     * Converts a TimeInput to an HrTime, defaults to _hrtime().
     * @param time
     */
    function timeInputToHrTime(time) {
      // process.hrtime
      if (isTimeInputHrTime(time)) {
        return time;
      } else if (typeof time === 'number') {
        // Must be a performance.now() if it's smaller than process start time.
        if (time < getTimeOrigin()) {
          return hrTime(time);
        } else {
          // epoch milliseconds or performance.timeOrigin
          return millisToHrTime(time);
        }
      } else if (time instanceof Date) {
        return millisToHrTime(time.getTime());
      } else {
        throw TypeError('Invalid input type');
      }
    }
    /**
     * Returns a duration of two hrTime.
     * @param startTime
     * @param endTime
     */
    function hrTimeDuration(startTime, endTime) {
      var seconds = endTime[0] - startTime[0];
      var nanos = endTime[1] - startTime[1];
      // overflow
      if (nanos < 0) {
        seconds -= 1;
        // negate
        nanos += SECOND_TO_NANOSECONDS;
      }
      return [seconds, nanos];
    }
    /**
     * Convert hrTime to nanoseconds.
     * @param time
     */
    function hrTimeToNanoseconds(time) {
      return time[0] * SECOND_TO_NANOSECONDS + time[1];
    }
    /**
     * check if time is HrTime
     * @param value
     */
    function isTimeInputHrTime(value) {
      return Array.isArray(value) && value.length === 2 && typeof value[0] === 'number' && typeof value[1] === 'number';
    }
    /**
     * check if input value is a correct types.TimeInput
     * @param value
     */
    function isTimeInput(value) {
      return isTimeInputHrTime(value) || typeof value === 'number' || value instanceof Date;
    }
    /**
     * Given 2 HrTime formatted times, return their sum as an HrTime.
     */
    function addHrTimes(time1, time2) {
      var out = [time1[0] + time2[0], time1[1] + time2[1]];
      // Nanoseconds
      if (out[1] >= SECOND_TO_NANOSECONDS) {
        out[1] -= SECOND_TO_NANOSECONDS;
        out[0] += 1;
      }
      return out;
    }

    /*
     * Copyright The OpenTelemetry Authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      https://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    var ExportResultCode;
    (function (ExportResultCode) {
      ExportResultCode[ExportResultCode["SUCCESS"] = 0] = "SUCCESS";
      ExportResultCode[ExportResultCode["FAILED"] = 1] = "FAILED";
    })(ExportResultCode || (ExportResultCode = {}));

    /*
     * Copyright The OpenTelemetry Authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      https://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    var __values$6 = undefined && undefined.__values || function (o) {
      var s = typeof Symbol === "function" && Symbol.iterator,
        m = s && o[s],
        i = 0;
      if (m) return m.call(o);
      if (o && typeof o.length === "number") return {
        next: function () {
          if (o && i >= o.length) o = void 0;
          return {
            value: o && o[i++],
            done: !o
          };
        }
      };
      throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    };
    /** Combines multiple propagators into a single propagator. */
    var CompositePropagator = /** @class */function () {
      /**
       * Construct a composite propagator from a list of propagators.
       *
       * @param [config] Configuration object for composite propagator
       */
      function CompositePropagator(config) {
        if (config === void 0) {
          config = {};
        }
        var _a;
        this._propagators = (_a = config.propagators) !== null && _a !== void 0 ? _a : [];
        this._fields = Array.from(new Set(this._propagators
        // older propagators may not have fields function, null check to be sure
        .map(function (p) {
          return typeof p.fields === 'function' ? p.fields() : [];
        }).reduce(function (x, y) {
          return x.concat(y);
        }, [])));
      }
      /**
       * Run each of the configured propagators with the given context and carrier.
       * Propagators are run in the order they are configured, so if multiple
       * propagators write the same carrier key, the propagator later in the list
       * will "win".
       *
       * @param context Context to inject
       * @param carrier Carrier into which context will be injected
       */
      CompositePropagator.prototype.inject = function (context, carrier, setter) {
        var e_1, _a;
        try {
          for (var _b = __values$6(this._propagators), _c = _b.next(); !_c.done; _c = _b.next()) {
            var propagator = _c.value;
            try {
              propagator.inject(context, carrier, setter);
            } catch (err) {
              diag.warn("Failed to inject with " + propagator.constructor.name + ". Err: " + err.message);
            }
          }
        } catch (e_1_1) {
          e_1 = {
            error: e_1_1
          };
        } finally {
          try {
            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
          } finally {
            if (e_1) throw e_1.error;
          }
        }
      };
      /**
       * Run each of the configured propagators with the given context and carrier.
       * Propagators are run in the order they are configured, so if multiple
       * propagators write the same context key, the propagator later in the list
       * will "win".
       *
       * @param context Context to add values to
       * @param carrier Carrier from which to extract context
       */
      CompositePropagator.prototype.extract = function (context, carrier, getter) {
        return this._propagators.reduce(function (ctx, propagator) {
          try {
            return propagator.extract(ctx, carrier, getter);
          } catch (err) {
            diag.warn("Failed to extract with " + propagator.constructor.name + ". Err: " + err.message);
          }
          return ctx;
        }, context);
      };
      CompositePropagator.prototype.fields = function () {
        // return a new array so our fields cannot be modified
        return this._fields.slice();
      };
      return CompositePropagator;
    }();

    /*
     * Copyright The OpenTelemetry Authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      https://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    var VALID_KEY_CHAR_RANGE = '[_0-9a-z-*/]';
    var VALID_KEY = "[a-z]" + VALID_KEY_CHAR_RANGE + "{0,255}";
    var VALID_VENDOR_KEY = "[a-z0-9]" + VALID_KEY_CHAR_RANGE + "{0,240}@[a-z]" + VALID_KEY_CHAR_RANGE + "{0,13}";
    var VALID_KEY_REGEX = new RegExp("^(?:" + VALID_KEY + "|" + VALID_VENDOR_KEY + ")$");
    var VALID_VALUE_BASE_REGEX = /^[ -~]{0,255}[!-~]$/;
    var INVALID_VALUE_COMMA_EQUAL_REGEX = /,|=/;
    /**
     * Key is opaque string up to 256 characters printable. It MUST begin with a
     * lowercase letter, and can only contain lowercase letters a-z, digits 0-9,
     * underscores _, dashes -, asterisks *, and forward slashes /.
     * For multi-tenant vendor scenarios, an at sign (@) can be used to prefix the
     * vendor name. Vendors SHOULD set the tenant ID at the beginning of the key.
     * see https://www.w3.org/TR/trace-context/#key
     */
    function validateKey(key) {
      return VALID_KEY_REGEX.test(key);
    }
    /**
     * Value is opaque string up to 256 characters printable ASCII RFC0020
     * characters (i.e., the range 0x20 to 0x7E) except comma , and =.
     */
    function validateValue(value) {
      return VALID_VALUE_BASE_REGEX.test(value) && !INVALID_VALUE_COMMA_EQUAL_REGEX.test(value);
    }

    /*
     * Copyright The OpenTelemetry Authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      https://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    var MAX_TRACE_STATE_ITEMS = 32;
    var MAX_TRACE_STATE_LEN = 512;
    var LIST_MEMBERS_SEPARATOR = ',';
    var LIST_MEMBER_KEY_VALUE_SPLITTER = '=';
    /**
     * TraceState must be a class and not a simple object type because of the spec
     * requirement (https://www.w3.org/TR/trace-context/#tracestate-field).
     *
     * Here is the list of allowed mutations:
     * - New key-value pair should be added into the beginning of the list
     * - The value of any key can be updated. Modified keys MUST be moved to the
     * beginning of the list.
     */
    var TraceState = /** @class */function () {
      function TraceState(rawTraceState) {
        this._internalState = new Map();
        if (rawTraceState) this._parse(rawTraceState);
      }
      TraceState.prototype.set = function (key, value) {
        // TODO: Benchmark the different approaches(map vs list) and
        // use the faster one.
        var traceState = this._clone();
        if (traceState._internalState.has(key)) {
          traceState._internalState.delete(key);
        }
        traceState._internalState.set(key, value);
        return traceState;
      };
      TraceState.prototype.unset = function (key) {
        var traceState = this._clone();
        traceState._internalState.delete(key);
        return traceState;
      };
      TraceState.prototype.get = function (key) {
        return this._internalState.get(key);
      };
      TraceState.prototype.serialize = function () {
        var _this = this;
        return this._keys().reduce(function (agg, key) {
          agg.push(key + LIST_MEMBER_KEY_VALUE_SPLITTER + _this.get(key));
          return agg;
        }, []).join(LIST_MEMBERS_SEPARATOR);
      };
      TraceState.prototype._parse = function (rawTraceState) {
        if (rawTraceState.length > MAX_TRACE_STATE_LEN) return;
        this._internalState = rawTraceState.split(LIST_MEMBERS_SEPARATOR).reverse() // Store in reverse so new keys (.set(...)) will be placed at the beginning
        .reduce(function (agg, part) {
          var listMember = part.trim(); // Optional Whitespace (OWS) handling
          var i = listMember.indexOf(LIST_MEMBER_KEY_VALUE_SPLITTER);
          if (i !== -1) {
            var key = listMember.slice(0, i);
            var value = listMember.slice(i + 1, part.length);
            if (validateKey(key) && validateValue(value)) {
              agg.set(key, value);
            }
          }
          return agg;
        }, new Map());
        // Because of the reverse() requirement, trunc must be done after map is created
        if (this._internalState.size > MAX_TRACE_STATE_ITEMS) {
          this._internalState = new Map(Array.from(this._internalState.entries()).reverse() // Use reverse same as original tracestate parse chain
          .slice(0, MAX_TRACE_STATE_ITEMS));
        }
      };
      TraceState.prototype._keys = function () {
        return Array.from(this._internalState.keys()).reverse();
      };
      TraceState.prototype._clone = function () {
        var traceState = new TraceState();
        traceState._internalState = new Map(this._internalState);
        return traceState;
      };
      return TraceState;
    }();

    /*
     * Copyright The OpenTelemetry Authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      https://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    var TRACE_PARENT_HEADER = 'traceparent';
    var TRACE_STATE_HEADER = 'tracestate';
    var VERSION$3 = '00';
    var VERSION_PART = '(?!ff)[\\da-f]{2}';
    var TRACE_ID_PART = '(?![0]{32})[\\da-f]{32}';
    var PARENT_ID_PART = '(?![0]{16})[\\da-f]{16}';
    var FLAGS_PART = '[\\da-f]{2}';
    var TRACE_PARENT_REGEX = new RegExp("^\\s?(" + VERSION_PART + ")-(" + TRACE_ID_PART + ")-(" + PARENT_ID_PART + ")-(" + FLAGS_PART + ")(-.*)?\\s?$");
    /**
     * Parses information from the [traceparent] span tag and converts it into {@link SpanContext}
     * @param traceParent - A meta property that comes from server.
     *     It should be dynamically generated server side to have the server's request trace Id,
     *     a parent span Id that was set on the server's request span,
     *     and the trace flags to indicate the server's sampling decision
     *     (01 = sampled, 00 = not sampled).
     *     for example: '{version}-{traceId}-{spanId}-{sampleDecision}'
     *     For more information see {@link https://www.w3.org/TR/trace-context/}
     */
    function parseTraceParent(traceParent) {
      var match = TRACE_PARENT_REGEX.exec(traceParent);
      if (!match) return null;
      // According to the specification the implementation should be compatible
      // with future versions. If there are more parts, we only reject it if it's using version 00
      // See https://www.w3.org/TR/trace-context/#versioning-of-traceparent
      if (match[1] === '00' && match[5]) return null;
      return {
        traceId: match[2],
        spanId: match[3],
        traceFlags: parseInt(match[4], 16)
      };
    }
    /**
     * Propagates {@link SpanContext} through Trace Context format propagation.
     *
     * Based on the Trace Context specification:
     * https://www.w3.org/TR/trace-context/
     */
    var W3CTraceContextPropagator = /** @class */function () {
      function W3CTraceContextPropagator() {}
      W3CTraceContextPropagator.prototype.inject = function (context, carrier, setter) {
        var spanContext = trace.getSpanContext(context);
        if (!spanContext || isTracingSuppressed(context) || !isSpanContextValid(spanContext)) return;
        var traceParent = VERSION$3 + "-" + spanContext.traceId + "-" + spanContext.spanId + "-0" + Number(spanContext.traceFlags || TraceFlags.NONE).toString(16);
        setter.set(carrier, TRACE_PARENT_HEADER, traceParent);
        if (spanContext.traceState) {
          setter.set(carrier, TRACE_STATE_HEADER, spanContext.traceState.serialize());
        }
      };
      W3CTraceContextPropagator.prototype.extract = function (context, carrier, getter) {
        var traceParentHeader = getter.get(carrier, TRACE_PARENT_HEADER);
        if (!traceParentHeader) return context;
        var traceParent = Array.isArray(traceParentHeader) ? traceParentHeader[0] : traceParentHeader;
        if (typeof traceParent !== 'string') return context;
        var spanContext = parseTraceParent(traceParent);
        if (!spanContext) return context;
        spanContext.isRemote = true;
        var traceStateHeader = getter.get(carrier, TRACE_STATE_HEADER);
        if (traceStateHeader) {
          // If more than one `tracestate` header is found, we merge them into a
          // single header.
          var state = Array.isArray(traceStateHeader) ? traceStateHeader.join(',') : traceStateHeader;
          spanContext.traceState = new TraceState(typeof state === 'string' ? state : undefined);
        }
        return trace.setSpanContext(context, spanContext);
      };
      W3CTraceContextPropagator.prototype.fields = function () {
        return [TRACE_PARENT_HEADER, TRACE_STATE_HEADER];
      };
      return W3CTraceContextPropagator;
    }();

    /*
     * Copyright The OpenTelemetry Authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      https://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    /* eslint-disable @typescript-eslint/no-explicit-any */
    /**
     * based on lodash in order to support esm builds without esModuleInterop.
     * lodash is using MIT License.
     **/
    var objectTag = '[object Object]';
    var nullTag = '[object Null]';
    var undefinedTag = '[object Undefined]';
    var funcProto = Function.prototype;
    var funcToString = funcProto.toString;
    var objectCtorString = funcToString.call(Object);
    var getPrototype = overArg(Object.getPrototypeOf, Object);
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var symToStringTag = Symbol ? Symbol.toStringTag : undefined;
    var nativeObjectToString = objectProto.toString;
    /**
     * Creates a unary function that invokes `func` with its argument transformed.
     *
     * @private
     * @param {Function} func The function to wrap.
     * @param {Function} transform The argument transform.
     * @returns {Function} Returns the new function.
     */
    function overArg(func, transform) {
      return function (arg) {
        return func(transform(arg));
      };
    }
    /**
     * Checks if `value` is a plain object, that is, an object created by the
     * `Object` constructor or one with a `[[Prototype]]` of `null`.
     *
     * @static
     * @memberOf _
     * @since 0.8.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     * }
     *
     * _.isPlainObject(new Foo);
     * // => false
     *
     * _.isPlainObject([1, 2, 3]);
     * // => false
     *
     * _.isPlainObject({ 'x': 0, 'y': 0 });
     * // => true
     *
     * _.isPlainObject(Object.create(null));
     * // => true
     */
    function isPlainObject(value) {
      if (!isObjectLike(value) || baseGetTag(value) !== objectTag) {
        return false;
      }
      var proto = getPrototype(value);
      if (proto === null) {
        return true;
      }
      var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;
      return typeof Ctor == 'function' && Ctor instanceof Ctor && funcToString.call(Ctor) === objectCtorString;
    }
    /**
     * Checks if `value` is object-like. A value is object-like if it's not `null`
     * and has a `typeof` result of "object".
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
     * @example
     *
     * _.isObjectLike({});
     * // => true
     *
     * _.isObjectLike([1, 2, 3]);
     * // => true
     *
     * _.isObjectLike(_.noop);
     * // => false
     *
     * _.isObjectLike(null);
     * // => false
     */
    function isObjectLike(value) {
      return value != null && typeof value == 'object';
    }
    /**
     * The base implementation of `getTag` without fallbacks for buggy environments.
     *
     * @private
     * @param {*} value The value to query.
     * @returns {string} Returns the `toStringTag`.
     */
    function baseGetTag(value) {
      if (value == null) {
        return value === undefined ? undefinedTag : nullTag;
      }
      return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
    }
    /**
     * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
     *
     * @private
     * @param {*} value The value to query.
     * @returns {string} Returns the raw `toStringTag`.
     */
    function getRawTag(value) {
      var isOwn = hasOwnProperty.call(value, symToStringTag),
        tag = value[symToStringTag];
      var unmasked = false;
      try {
        value[symToStringTag] = undefined;
        unmasked = true;
      } catch (e) {
        // silence
      }
      var result = nativeObjectToString.call(value);
      if (unmasked) {
        if (isOwn) {
          value[symToStringTag] = tag;
        } else {
          delete value[symToStringTag];
        }
      }
      return result;
    }
    /**
     * Converts `value` to a string using `Object.prototype.toString`.
     *
     * @private
     * @param {*} value The value to convert.
     * @returns {string} Returns the converted string.
     */
    function objectToString(value) {
      return nativeObjectToString.call(value);
    }

    /*
     * Copyright The OpenTelemetry Authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      https://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    /* eslint-disable @typescript-eslint/no-explicit-any */
    var MAX_LEVEL = 20;
    /**
     * Merges objects together
     * @param args - objects / values to be merged
     */
    function merge() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      var result = args.shift();
      var objects = new WeakMap();
      while (args.length > 0) {
        result = mergeTwoObjects(result, args.shift(), 0, objects);
      }
      return result;
    }
    function takeValue(value) {
      if (isArray(value)) {
        return value.slice();
      }
      return value;
    }
    /**
     * Merges two objects
     * @param one - first object
     * @param two - second object
     * @param level - current deep level
     * @param objects - objects holder that has been already referenced - to prevent
     * cyclic dependency
     */
    function mergeTwoObjects(one, two, level, objects) {
      if (level === void 0) {
        level = 0;
      }
      var result;
      if (level > MAX_LEVEL) {
        return undefined;
      }
      level++;
      if (isPrimitive(one) || isPrimitive(two) || isFunction(two)) {
        result = takeValue(two);
      } else if (isArray(one)) {
        result = one.slice();
        if (isArray(two)) {
          for (var i = 0, j = two.length; i < j; i++) {
            result.push(takeValue(two[i]));
          }
        } else if (isObject(two)) {
          var keys = Object.keys(two);
          for (var i = 0, j = keys.length; i < j; i++) {
            var key = keys[i];
            result[key] = takeValue(two[key]);
          }
        }
      } else if (isObject(one)) {
        if (isObject(two)) {
          if (!shouldMerge(one, two)) {
            return two;
          }
          result = Object.assign({}, one);
          var keys = Object.keys(two);
          for (var i = 0, j = keys.length; i < j; i++) {
            var key = keys[i];
            var twoValue = two[key];
            if (isPrimitive(twoValue)) {
              if (typeof twoValue === 'undefined') {
                delete result[key];
              } else {
                // result[key] = takeValue(twoValue);
                result[key] = twoValue;
              }
            } else {
              var obj1 = result[key];
              var obj2 = twoValue;
              if (wasObjectReferenced(one, key, objects) || wasObjectReferenced(two, key, objects)) {
                delete result[key];
              } else {
                if (isObject(obj1) && isObject(obj2)) {
                  var arr1 = objects.get(obj1) || [];
                  var arr2 = objects.get(obj2) || [];
                  arr1.push({
                    obj: one,
                    key: key
                  });
                  arr2.push({
                    obj: two,
                    key: key
                  });
                  objects.set(obj1, arr1);
                  objects.set(obj2, arr2);
                }
                result[key] = mergeTwoObjects(result[key], twoValue, level, objects);
              }
            }
          }
        } else {
          result = two;
        }
      }
      return result;
    }
    /**
     * Function to check if object has been already reference
     * @param obj
     * @param key
     * @param objects
     */
    function wasObjectReferenced(obj, key, objects) {
      var arr = objects.get(obj[key]) || [];
      for (var i = 0, j = arr.length; i < j; i++) {
        var info = arr[i];
        if (info.key === key && info.obj === obj) {
          return true;
        }
      }
      return false;
    }
    function isArray(value) {
      return Array.isArray(value);
    }
    function isFunction(value) {
      return typeof value === 'function';
    }
    function isObject(value) {
      return !isPrimitive(value) && !isArray(value) && !isFunction(value) && typeof value === 'object';
    }
    function isPrimitive(value) {
      return typeof value === 'string' || typeof value === 'number' || typeof value === 'boolean' || typeof value === 'undefined' || value instanceof Date || value instanceof RegExp || value === null;
    }
    function shouldMerge(one, two) {
      if (!isPlainObject(one) || !isPlainObject(two)) {
        return false;
      }
      return true;
    }

    var __values$5 = undefined && undefined.__values || function (o) {
      var s = typeof Symbol === "function" && Symbol.iterator,
        m = s && o[s],
        i = 0;
      if (m) return m.call(o);
      if (o && typeof o.length === "number") return {
        next: function () {
          if (o && i >= o.length) o = void 0;
          return {
            value: o && o[i++],
            done: !o
          };
        }
      };
      throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    };
    /*
     * Copyright The OpenTelemetry Authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      https://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    function urlMatches(url, urlToMatch) {
      if (typeof urlToMatch === 'string') {
        return url === urlToMatch;
      } else {
        return !!url.match(urlToMatch);
      }
    }
    /**
     * Check if {@param url} should be ignored when comparing against {@param ignoredUrls}
     * @param url
     * @param ignoredUrls
     */
    function isUrlIgnored(url, ignoredUrls) {
      var e_1, _a;
      if (!ignoredUrls) {
        return false;
      }
      try {
        for (var ignoredUrls_1 = __values$5(ignoredUrls), ignoredUrls_1_1 = ignoredUrls_1.next(); !ignoredUrls_1_1.done; ignoredUrls_1_1 = ignoredUrls_1.next()) {
          var ignoreUrl = ignoredUrls_1_1.value;
          if (urlMatches(url, ignoreUrl)) {
            return true;
          }
        }
      } catch (e_1_1) {
        e_1 = {
          error: e_1_1
        };
      } finally {
        try {
          if (ignoredUrls_1_1 && !ignoredUrls_1_1.done && (_a = ignoredUrls_1.return)) _a.call(ignoredUrls_1);
        } finally {
          if (e_1) throw e_1.error;
        }
      }
      return false;
    }

    /*
     * Copyright The OpenTelemetry Authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      https://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    var Deferred = /** @class */function () {
      function Deferred() {
        var _this = this;
        this._promise = new Promise(function (resolve, reject) {
          _this._resolve = resolve;
          _this._reject = reject;
        });
      }
      Object.defineProperty(Deferred.prototype, "promise", {
        get: function () {
          return this._promise;
        },
        enumerable: false,
        configurable: true
      });
      Deferred.prototype.resolve = function (val) {
        this._resolve(val);
      };
      Deferred.prototype.reject = function (err) {
        this._reject(err);
      };
      return Deferred;
    }();

    /*
     * Copyright The OpenTelemetry Authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      https://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    var __read$b = undefined && undefined.__read || function (o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m) return o;
      var i = m.call(o),
        r,
        ar = [],
        e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
      } catch (error) {
        e = {
          error: error
        };
      } finally {
        try {
          if (r && !r.done && (m = i["return"])) m.call(i);
        } finally {
          if (e) throw e.error;
        }
      }
      return ar;
    };
    var __spreadArray$4 = undefined && undefined.__spreadArray || function (to, from, pack) {
      if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
          if (!ar) ar = Array.prototype.slice.call(from, 0, i);
          ar[i] = from[i];
        }
      }
      return to.concat(ar || Array.prototype.slice.call(from));
    };
    /**
     * Bind the callback and only invoke the callback once regardless how many times `BindOnceFuture.call` is invoked.
     */
    var BindOnceFuture = /** @class */function () {
      function BindOnceFuture(_callback, _that) {
        this._callback = _callback;
        this._that = _that;
        this._isCalled = false;
        this._deferred = new Deferred();
      }
      Object.defineProperty(BindOnceFuture.prototype, "isCalled", {
        get: function () {
          return this._isCalled;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(BindOnceFuture.prototype, "promise", {
        get: function () {
          return this._deferred.promise;
        },
        enumerable: false,
        configurable: true
      });
      BindOnceFuture.prototype.call = function () {
        var _a;
        var _this = this;
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        if (!this._isCalled) {
          this._isCalled = true;
          try {
            Promise.resolve((_a = this._callback).call.apply(_a, __spreadArray$4([this._that], __read$b(args), false))).then(function (val) {
              return _this._deferred.resolve(val);
            }, function (err) {
              return _this._deferred.reject(err);
            });
          } catch (err) {
            this._deferred.reject(err);
          }
        }
        return this._deferred.promise;
      };
      return BindOnceFuture;
    }();

    /*
     * Copyright The OpenTelemetry Authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      https://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    function defaultServiceName() {
      return 'unknown_service';
    }

    /*
     * Copyright The OpenTelemetry Authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      https://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    var __assign$2 = undefined && undefined.__assign || function () {
      __assign$2 = Object.assign || function (t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
      };
      return __assign$2.apply(this, arguments);
    };
    var __awaiter$6 = undefined && undefined.__awaiter || function (thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function (resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator$6 = undefined && undefined.__generator || function (thisArg, body) {
      var _ = {
          label: 0,
          sent: function () {
            if (t[0] & 1) throw t[1];
            return t[1];
          },
          trys: [],
          ops: []
        },
        f,
        y,
        t,
        g;
      return g = {
        next: verb(0),
        "throw": verb(1),
        "return": verb(2)
      }, typeof Symbol === "function" && (g[Symbol.iterator] = function () {
        return this;
      }), g;
      function verb(n) {
        return function (v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
          if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
          if (y = 0, t) op = [op[0] & 2, t.value];
          switch (op[0]) {
            case 0:
            case 1:
              t = op;
              break;
            case 4:
              _.label++;
              return {
                value: op[1],
                done: false
              };
            case 5:
              _.label++;
              y = op[1];
              op = [0];
              continue;
            case 7:
              op = _.ops.pop();
              _.trys.pop();
              continue;
            default:
              if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                _ = 0;
                continue;
              }
              if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                _.label = op[1];
                break;
              }
              if (op[0] === 6 && _.label < t[1]) {
                _.label = t[1];
                t = op;
                break;
              }
              if (t && _.label < t[2]) {
                _.label = t[2];
                _.ops.push(op);
                break;
              }
              if (t[2]) _.ops.pop();
              _.trys.pop();
              continue;
          }
          op = body.call(thisArg, _);
        } catch (e) {
          op = [6, e];
          y = 0;
        } finally {
          f = t = 0;
        }
        if (op[0] & 5) throw op[1];
        return {
          value: op[0] ? op[1] : void 0,
          done: true
        };
      }
    };
    var __read$a = undefined && undefined.__read || function (o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m) return o;
      var i = m.call(o),
        r,
        ar = [],
        e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
      } catch (error) {
        e = {
          error: error
        };
      } finally {
        try {
          if (r && !r.done && (m = i["return"])) m.call(i);
        } finally {
          if (e) throw e.error;
        }
      }
      return ar;
    };
    /**
     * A Resource describes the entity for which a signals (metrics or trace) are
     * collected.
     */
    var Resource = /** @class */function () {
      function Resource(
      /**
       * A dictionary of attributes with string keys and values that provide
       * information about the entity as numbers, strings or booleans
       * TODO: Consider to add check/validation on attributes.
       */
      attributes, asyncAttributesPromise) {
        var _this = this;
        var _a;
        this._attributes = attributes;
        this.asyncAttributesPending = asyncAttributesPromise != null;
        this._syncAttributes = (_a = this._attributes) !== null && _a !== void 0 ? _a : {};
        this._asyncAttributesPromise = asyncAttributesPromise === null || asyncAttributesPromise === void 0 ? void 0 : asyncAttributesPromise.then(function (asyncAttributes) {
          _this._attributes = Object.assign({}, _this._attributes, asyncAttributes);
          _this.asyncAttributesPending = false;
          return asyncAttributes;
        }, function (err) {
          diag.debug("a resource's async attributes promise rejected: %s", err);
          _this.asyncAttributesPending = false;
          return {};
        });
      }
      /**
       * Returns an empty Resource
       */
      Resource.empty = function () {
        return Resource.EMPTY;
      };
      /**
       * Returns a Resource that identifies the SDK in use.
       */
      Resource.default = function () {
        var _a;
        return new Resource((_a = {}, _a[SEMRESATTRS_SERVICE_NAME$1] = defaultServiceName(), _a[SEMRESATTRS_TELEMETRY_SDK_LANGUAGE$1] = SDK_INFO[SEMRESATTRS_TELEMETRY_SDK_LANGUAGE$1], _a[SEMRESATTRS_TELEMETRY_SDK_NAME$1] = SDK_INFO[SEMRESATTRS_TELEMETRY_SDK_NAME$1], _a[SEMRESATTRS_TELEMETRY_SDK_VERSION$1] = SDK_INFO[SEMRESATTRS_TELEMETRY_SDK_VERSION$1], _a));
      };
      Object.defineProperty(Resource.prototype, "attributes", {
        get: function () {
          var _a;
          if (this.asyncAttributesPending) {
            diag.error('Accessing resource attributes before async attributes settled');
          }
          return (_a = this._attributes) !== null && _a !== void 0 ? _a : {};
        },
        enumerable: false,
        configurable: true
      });
      /**
       * Returns a promise that will never be rejected. Resolves when all async attributes have finished being added to
       * this Resource's attributes. This is useful in exporters to block until resource detection
       * has finished.
       */
      Resource.prototype.waitForAsyncAttributes = function () {
        return __awaiter$6(this, void 0, void 0, function () {
          return __generator$6(this, function (_a) {
            switch (_a.label) {
              case 0:
                if (!this.asyncAttributesPending) return [3 /*break*/, 2];
                return [4 /*yield*/, this._asyncAttributesPromise];
              case 1:
                _a.sent();
                _a.label = 2;
              case 2:
                return [2 /*return*/];
            }
          });
        });
      };
      /**
       * Returns a new, merged {@link Resource} by merging the current Resource
       * with the other Resource. In case of a collision, other Resource takes
       * precedence.
       *
       * @param other the Resource that will be merged with this.
       * @returns the newly merged Resource.
       */
      Resource.prototype.merge = function (other) {
        var _this = this;
        var _a;
        if (!other) return this;
        // SpanAttributes from other resource overwrite attributes from this resource.
        var mergedSyncAttributes = __assign$2(__assign$2({}, this._syncAttributes), (_a = other._syncAttributes) !== null && _a !== void 0 ? _a : other.attributes);
        if (!this._asyncAttributesPromise && !other._asyncAttributesPromise) {
          return new Resource(mergedSyncAttributes);
        }
        var mergedAttributesPromise = Promise.all([this._asyncAttributesPromise, other._asyncAttributesPromise]).then(function (_a) {
          var _b;
          var _c = __read$a(_a, 2),
            thisAsyncAttributes = _c[0],
            otherAsyncAttributes = _c[1];
          return __assign$2(__assign$2(__assign$2(__assign$2({}, _this._syncAttributes), thisAsyncAttributes), (_b = other._syncAttributes) !== null && _b !== void 0 ? _b : other.attributes), otherAsyncAttributes);
        });
        return new Resource(mergedSyncAttributes, mergedAttributesPromise);
      };
      Resource.EMPTY = new Resource({});
      return Resource;
    }();

    /*
     * Copyright The OpenTelemetry Authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      https://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    var isPromiseLike = function (val) {
      return val !== null && typeof val === 'object' && typeof val.then === 'function';
    };

    /*
     * Copyright The OpenTelemetry Authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      https://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    var __awaiter$5 = undefined && undefined.__awaiter || function (thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function (resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator$5 = undefined && undefined.__generator || function (thisArg, body) {
      var _ = {
          label: 0,
          sent: function () {
            if (t[0] & 1) throw t[1];
            return t[1];
          },
          trys: [],
          ops: []
        },
        f,
        y,
        t,
        g;
      return g = {
        next: verb(0),
        "throw": verb(1),
        "return": verb(2)
      }, typeof Symbol === "function" && (g[Symbol.iterator] = function () {
        return this;
      }), g;
      function verb(n) {
        return function (v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
          if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
          if (y = 0, t) op = [op[0] & 2, t.value];
          switch (op[0]) {
            case 0:
            case 1:
              t = op;
              break;
            case 4:
              _.label++;
              return {
                value: op[1],
                done: false
              };
            case 5:
              _.label++;
              y = op[1];
              op = [0];
              continue;
            case 7:
              op = _.ops.pop();
              _.trys.pop();
              continue;
            default:
              if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                _ = 0;
                continue;
              }
              if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                _.label = op[1];
                break;
              }
              if (op[0] === 6 && _.label < t[1]) {
                _.label = t[1];
                t = op;
                break;
              }
              if (t && _.label < t[2]) {
                _.label = t[2];
                _.ops.push(op);
                break;
              }
              if (t[2]) _.ops.pop();
              _.trys.pop();
              continue;
          }
          op = body.call(thisArg, _);
        } catch (e) {
          op = [6, e];
          y = 0;
        } finally {
          f = t = 0;
        }
        if (op[0] & 5) throw op[1];
        return {
          value: op[0] ? op[1] : void 0,
          done: true
        };
      }
    };
    /**
     * Runs all resource detectors synchronously, merging their results. In case of attribute collision later resources will take precedence.
     *
     * @param config Configuration for resource detection
     */
    var detectResourcesSync = function (config) {
      var _a;
      if (config === void 0) {
        config = {};
      }
      var resources = ((_a = config.detectors) !== null && _a !== void 0 ? _a : []).map(function (d) {
        try {
          var resourceOrPromise_1 = d.detect(config);
          var resource_1;
          if (isPromiseLike(resourceOrPromise_1)) {
            var createPromise = function () {
              return __awaiter$5(void 0, void 0, void 0, function () {
                var resolvedResource;
                var _a;
                return __generator$5(this, function (_b) {
                  switch (_b.label) {
                    case 0:
                      return [4 /*yield*/, resourceOrPromise_1];
                    case 1:
                      resolvedResource = _b.sent();
                      return [4 /*yield*/, (_a = resolvedResource.waitForAsyncAttributes) === null || _a === void 0 ? void 0 : _a.call(resolvedResource)];
                    case 2:
                      _b.sent();
                      return [2 /*return*/, resolvedResource.attributes];
                  }
                });
              });
            };
            resource_1 = new Resource({}, createPromise());
          } else {
            resource_1 = resourceOrPromise_1;
          }
          if (resource_1.waitForAsyncAttributes) {
            void resource_1.waitForAsyncAttributes().then(function () {
              return diag.debug(d.constructor.name + " found resource.", resource_1);
            });
          } else {
            diag.debug(d.constructor.name + " found resource.", resource_1);
          }
          return resource_1;
        } catch (e) {
          diag.error(d.constructor.name + " failed: " + e.message);
          return Resource.empty();
        }
      });
      var mergedResources = resources.reduce(function (acc, resource) {
        return acc.merge(resource);
      }, Resource.empty());
      if (mergedResources.waitForAsyncAttributes) {
        void mergedResources.waitForAsyncAttributes().then(function () {
          // Future check if verbose logging is enabled issue #1903
          logResources(resources);
        });
      }
      return mergedResources;
    };
    /**
     * Writes debug information about the detected resources to the logger defined in the resource detection config, if one is provided.
     *
     * @param resources The array of {@link Resource} that should be logged. Empty entries will be ignored.
     */
    var logResources = function (resources) {
      resources.forEach(function (resource) {
        // Print only populated resources
        if (Object.keys(resource.attributes).length > 0) {
          var resourceDebugString = JSON.stringify(resource.attributes, null, 4);
          diag.verbose(resourceDebugString);
        }
      });
    };

    /*
     * Copyright The OpenTelemetry Authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      https://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    var TMP_EXCEPTION_TYPE = 'exception.type';
    var TMP_EXCEPTION_MESSAGE = 'exception.message';
    var TMP_EXCEPTION_STACKTRACE = 'exception.stacktrace';
    /**
     * The type of the exception (its fully-qualified class name, if applicable). The dynamic type of the exception should be preferred over the static type in languages that support it.
     *
     * @deprecated Use ATTR_EXCEPTION_TYPE.
     */
    var SEMATTRS_EXCEPTION_TYPE = TMP_EXCEPTION_TYPE;
    /**
     * The exception message.
     *
     * @deprecated Use ATTR_EXCEPTION_MESSAGE.
     */
    var SEMATTRS_EXCEPTION_MESSAGE = TMP_EXCEPTION_MESSAGE;
    /**
     * A stacktrace as a string in the natural representation for the language runtime. The representation is to be determined and documented by each language SIG.
     *
     * @deprecated Use ATTR_EXCEPTION_STACKTRACE.
     */
    var SEMATTRS_EXCEPTION_STACKTRACE = TMP_EXCEPTION_STACKTRACE;

    /*
     * Copyright The OpenTelemetry Authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      https://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    // Event name definitions
    var ExceptionEventName = 'exception';

    /*
     * Copyright The OpenTelemetry Authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      https://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    var __assign$1 = undefined && undefined.__assign || function () {
      __assign$1 = Object.assign || function (t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
      };
      return __assign$1.apply(this, arguments);
    };
    var __values$4 = undefined && undefined.__values || function (o) {
      var s = typeof Symbol === "function" && Symbol.iterator,
        m = s && o[s],
        i = 0;
      if (m) return m.call(o);
      if (o && typeof o.length === "number") return {
        next: function () {
          if (o && i >= o.length) o = void 0;
          return {
            value: o && o[i++],
            done: !o
          };
        }
      };
      throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    };
    var __read$9 = undefined && undefined.__read || function (o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m) return o;
      var i = m.call(o),
        r,
        ar = [],
        e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
      } catch (error) {
        e = {
          error: error
        };
      } finally {
        try {
          if (r && !r.done && (m = i["return"])) m.call(i);
        } finally {
          if (e) throw e.error;
        }
      }
      return ar;
    };
    var __spreadArray$3 = undefined && undefined.__spreadArray || function (to, from, pack) {
      if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
          if (!ar) ar = Array.prototype.slice.call(from, 0, i);
          ar[i] = from[i];
        }
      }
      return to.concat(ar || Array.prototype.slice.call(from));
    };
    /**
     * This class represents a span.
     */
    var Span = /** @class */function () {
      /**
       * Constructs a new Span instance.
       *
       * @deprecated calling Span constructor directly is not supported. Please use tracer.startSpan.
       * */
      function Span(parentTracer, context, spanName, spanContext, kind, parentSpanId, links, startTime, _deprecatedClock,
      // keeping this argument even though it is unused to ensure backwards compatibility
      attributes) {
        if (links === void 0) {
          links = [];
        }
        this.attributes = {};
        this.links = [];
        this.events = [];
        this._droppedAttributesCount = 0;
        this._droppedEventsCount = 0;
        this._droppedLinksCount = 0;
        this.status = {
          code: SpanStatusCode.UNSET
        };
        this.endTime = [0, 0];
        this._ended = false;
        this._duration = [-1, -1];
        this.name = spanName;
        this._spanContext = spanContext;
        this.parentSpanId = parentSpanId;
        this.kind = kind;
        this.links = links;
        var now = Date.now();
        this._performanceStartTime = otperformance.now();
        this._performanceOffset = now - (this._performanceStartTime + getTimeOrigin());
        this._startTimeProvided = startTime != null;
        this.startTime = this._getTime(startTime !== null && startTime !== void 0 ? startTime : now);
        this.resource = parentTracer.resource;
        this.instrumentationLibrary = parentTracer.instrumentationLibrary;
        this._spanLimits = parentTracer.getSpanLimits();
        this._attributeValueLengthLimit = this._spanLimits.attributeValueLengthLimit || 0;
        if (attributes != null) {
          this.setAttributes(attributes);
        }
        this._spanProcessor = parentTracer.getActiveSpanProcessor();
        this._spanProcessor.onStart(this, context);
      }
      Span.prototype.spanContext = function () {
        return this._spanContext;
      };
      Span.prototype.setAttribute = function (key, value) {
        if (value == null || this._isSpanEnded()) return this;
        if (key.length === 0) {
          diag.warn("Invalid attribute key: " + key);
          return this;
        }
        if (!isAttributeValue(value)) {
          diag.warn("Invalid attribute value set for key: " + key);
          return this;
        }
        if (Object.keys(this.attributes).length >= this._spanLimits.attributeCountLimit && !Object.prototype.hasOwnProperty.call(this.attributes, key)) {
          this._droppedAttributesCount++;
          return this;
        }
        this.attributes[key] = this._truncateToSize(value);
        return this;
      };
      Span.prototype.setAttributes = function (attributes) {
        var e_1, _a;
        try {
          for (var _b = __values$4(Object.entries(attributes)), _c = _b.next(); !_c.done; _c = _b.next()) {
            var _d = __read$9(_c.value, 2),
              k = _d[0],
              v = _d[1];
            this.setAttribute(k, v);
          }
        } catch (e_1_1) {
          e_1 = {
            error: e_1_1
          };
        } finally {
          try {
            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
          } finally {
            if (e_1) throw e_1.error;
          }
        }
        return this;
      };
      /**
       *
       * @param name Span Name
       * @param [attributesOrStartTime] Span attributes or start time
       *     if type is {@type TimeInput} and 3rd param is undefined
       * @param [timeStamp] Specified time stamp for the event
       */
      Span.prototype.addEvent = function (name, attributesOrStartTime, timeStamp) {
        if (this._isSpanEnded()) return this;
        if (this._spanLimits.eventCountLimit === 0) {
          diag.warn('No events allowed.');
          this._droppedEventsCount++;
          return this;
        }
        if (this.events.length >= this._spanLimits.eventCountLimit) {
          if (this._droppedEventsCount === 0) {
            diag.debug('Dropping extra events.');
          }
          this.events.shift();
          this._droppedEventsCount++;
        }
        if (isTimeInput(attributesOrStartTime)) {
          if (!isTimeInput(timeStamp)) {
            timeStamp = attributesOrStartTime;
          }
          attributesOrStartTime = undefined;
        }
        var attributes = sanitizeAttributes(attributesOrStartTime);
        this.events.push({
          name: name,
          attributes: attributes,
          time: this._getTime(timeStamp),
          droppedAttributesCount: 0
        });
        return this;
      };
      Span.prototype.addLink = function (link) {
        this.links.push(link);
        return this;
      };
      Span.prototype.addLinks = function (links) {
        var _a;
        (_a = this.links).push.apply(_a, __spreadArray$3([], __read$9(links), false));
        return this;
      };
      Span.prototype.setStatus = function (status) {
        if (this._isSpanEnded()) return this;
        this.status = __assign$1({}, status);
        // When using try-catch, the caught "error" is of type `any`. When then assigning `any` to `status.message`,
        // TypeScript will not error. While this can happen during use of any API, it is more common on Span#setStatus()
        // as it's likely used in a catch-block. Therefore, we validate if `status.message` is actually a string, null, or
        // undefined to avoid an incorrect type causing issues downstream.
        if (this.status.message != null && typeof status.message !== 'string') {
          diag.warn("Dropping invalid status.message of type '" + typeof status.message + "', expected 'string'");
          delete this.status.message;
        }
        return this;
      };
      Span.prototype.updateName = function (name) {
        if (this._isSpanEnded()) return this;
        this.name = name;
        return this;
      };
      Span.prototype.end = function (endTime) {
        if (this._isSpanEnded()) {
          diag.error(this.name + " " + this._spanContext.traceId + "-" + this._spanContext.spanId + " - You can only call end() on a span once.");
          return;
        }
        this._ended = true;
        this.endTime = this._getTime(endTime);
        this._duration = hrTimeDuration(this.startTime, this.endTime);
        if (this._duration[0] < 0) {
          diag.warn('Inconsistent start and end time, startTime > endTime. Setting span duration to 0ms.', this.startTime, this.endTime);
          this.endTime = this.startTime.slice();
          this._duration = [0, 0];
        }
        if (this._droppedEventsCount > 0) {
          diag.warn("Dropped " + this._droppedEventsCount + " events because eventCountLimit reached");
        }
        this._spanProcessor.onEnd(this);
      };
      Span.prototype._getTime = function (inp) {
        if (typeof inp === 'number' && inp <= otperformance.now()) {
          // must be a performance timestamp
          // apply correction and convert to hrtime
          return hrTime(inp + this._performanceOffset);
        }
        if (typeof inp === 'number') {
          return millisToHrTime(inp);
        }
        if (inp instanceof Date) {
          return millisToHrTime(inp.getTime());
        }
        if (isTimeInputHrTime(inp)) {
          return inp;
        }
        if (this._startTimeProvided) {
          // if user provided a time for the start manually
          // we can't use duration to calculate event/end times
          return millisToHrTime(Date.now());
        }
        var msDuration = otperformance.now() - this._performanceStartTime;
        return addHrTimes(this.startTime, millisToHrTime(msDuration));
      };
      Span.prototype.isRecording = function () {
        return this._ended === false;
      };
      Span.prototype.recordException = function (exception, time) {
        var attributes = {};
        if (typeof exception === 'string') {
          attributes[SEMATTRS_EXCEPTION_MESSAGE] = exception;
        } else if (exception) {
          if (exception.code) {
            attributes[SEMATTRS_EXCEPTION_TYPE] = exception.code.toString();
          } else if (exception.name) {
            attributes[SEMATTRS_EXCEPTION_TYPE] = exception.name;
          }
          if (exception.message) {
            attributes[SEMATTRS_EXCEPTION_MESSAGE] = exception.message;
          }
          if (exception.stack) {
            attributes[SEMATTRS_EXCEPTION_STACKTRACE] = exception.stack;
          }
        }
        // these are minimum requirements from spec
        if (attributes[SEMATTRS_EXCEPTION_TYPE] || attributes[SEMATTRS_EXCEPTION_MESSAGE]) {
          this.addEvent(ExceptionEventName, attributes, time);
        } else {
          diag.warn("Failed to record an exception " + exception);
        }
      };
      Object.defineProperty(Span.prototype, "duration", {
        get: function () {
          return this._duration;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Span.prototype, "ended", {
        get: function () {
          return this._ended;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Span.prototype, "droppedAttributesCount", {
        get: function () {
          return this._droppedAttributesCount;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Span.prototype, "droppedEventsCount", {
        get: function () {
          return this._droppedEventsCount;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Span.prototype, "droppedLinksCount", {
        get: function () {
          return this._droppedLinksCount;
        },
        enumerable: false,
        configurable: true
      });
      Span.prototype._isSpanEnded = function () {
        if (this._ended) {
          diag.warn("Can not execute the operation on ended Span {traceId: " + this._spanContext.traceId + ", spanId: " + this._spanContext.spanId + "}");
        }
        return this._ended;
      };
      // Utility function to truncate given value within size
      // for value type of string, will truncate to given limit
      // for type of non-string, will return same value
      Span.prototype._truncateToLimitUtil = function (value, limit) {
        if (value.length <= limit) {
          return value;
        }
        return value.substring(0, limit);
      };
      /**
       * If the given attribute value is of type string and has more characters than given {@code attributeValueLengthLimit} then
       * return string with truncated to {@code attributeValueLengthLimit} characters
       *
       * If the given attribute value is array of strings then
       * return new array of strings with each element truncated to {@code attributeValueLengthLimit} characters
       *
       * Otherwise return same Attribute {@code value}
       *
       * @param value Attribute value
       * @returns truncated attribute value if required, otherwise same value
       */
      Span.prototype._truncateToSize = function (value) {
        var _this = this;
        var limit = this._attributeValueLengthLimit;
        // Check limit
        if (limit <= 0) {
          // Negative values are invalid, so do not truncate
          diag.warn("Attribute value limit must be positive, got " + limit);
          return value;
        }
        // String
        if (typeof value === 'string') {
          return this._truncateToLimitUtil(value, limit);
        }
        // Array of strings
        if (Array.isArray(value)) {
          return value.map(function (val) {
            return typeof val === 'string' ? _this._truncateToLimitUtil(val, limit) : val;
          });
        }
        // Other types, no need to apply value length limit
        return value;
      };
      return Span;
    }();

    /*
     * Copyright The OpenTelemetry Authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      https://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    /**
     * A sampling decision that determines how a {@link Span} will be recorded
     * and collected.
     */
    var SamplingDecision;
    (function (SamplingDecision) {
      /**
       * `Span.isRecording() === false`, span will not be recorded and all events
       * and attributes will be dropped.
       */
      SamplingDecision[SamplingDecision["NOT_RECORD"] = 0] = "NOT_RECORD";
      /**
       * `Span.isRecording() === true`, but `Sampled` flag in {@link TraceFlags}
       * MUST NOT be set.
       */
      SamplingDecision[SamplingDecision["RECORD"] = 1] = "RECORD";
      /**
       * `Span.isRecording() === true` AND `Sampled` flag in {@link TraceFlags}
       * MUST be set.
       */
      SamplingDecision[SamplingDecision["RECORD_AND_SAMPLED"] = 2] = "RECORD_AND_SAMPLED";
    })(SamplingDecision || (SamplingDecision = {}));

    /*
     * Copyright The OpenTelemetry Authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      https://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    /** Sampler that samples no traces. */
    var AlwaysOffSampler = /** @class */function () {
      function AlwaysOffSampler() {}
      AlwaysOffSampler.prototype.shouldSample = function () {
        return {
          decision: SamplingDecision.NOT_RECORD
        };
      };
      AlwaysOffSampler.prototype.toString = function () {
        return 'AlwaysOffSampler';
      };
      return AlwaysOffSampler;
    }();

    /*
     * Copyright The OpenTelemetry Authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      https://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    /** Sampler that samples all traces. */
    var AlwaysOnSampler = /** @class */function () {
      function AlwaysOnSampler() {}
      AlwaysOnSampler.prototype.shouldSample = function () {
        return {
          decision: SamplingDecision.RECORD_AND_SAMPLED
        };
      };
      AlwaysOnSampler.prototype.toString = function () {
        return 'AlwaysOnSampler';
      };
      return AlwaysOnSampler;
    }();

    /*
     * Copyright The OpenTelemetry Authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      https://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    /**
     * A composite sampler that either respects the parent span's sampling decision
     * or delegates to `delegateSampler` for root spans.
     */
    var ParentBasedSampler = /** @class */function () {
      function ParentBasedSampler(config) {
        var _a, _b, _c, _d;
        this._root = config.root;
        if (!this._root) {
          globalErrorHandler(new Error('ParentBasedSampler must have a root sampler configured'));
          this._root = new AlwaysOnSampler();
        }
        this._remoteParentSampled = (_a = config.remoteParentSampled) !== null && _a !== void 0 ? _a : new AlwaysOnSampler();
        this._remoteParentNotSampled = (_b = config.remoteParentNotSampled) !== null && _b !== void 0 ? _b : new AlwaysOffSampler();
        this._localParentSampled = (_c = config.localParentSampled) !== null && _c !== void 0 ? _c : new AlwaysOnSampler();
        this._localParentNotSampled = (_d = config.localParentNotSampled) !== null && _d !== void 0 ? _d : new AlwaysOffSampler();
      }
      ParentBasedSampler.prototype.shouldSample = function (context, traceId, spanName, spanKind, attributes, links) {
        var parentContext = trace.getSpanContext(context);
        if (!parentContext || !isSpanContextValid(parentContext)) {
          return this._root.shouldSample(context, traceId, spanName, spanKind, attributes, links);
        }
        if (parentContext.isRemote) {
          if (parentContext.traceFlags & TraceFlags.SAMPLED) {
            return this._remoteParentSampled.shouldSample(context, traceId, spanName, spanKind, attributes, links);
          }
          return this._remoteParentNotSampled.shouldSample(context, traceId, spanName, spanKind, attributes, links);
        }
        if (parentContext.traceFlags & TraceFlags.SAMPLED) {
          return this._localParentSampled.shouldSample(context, traceId, spanName, spanKind, attributes, links);
        }
        return this._localParentNotSampled.shouldSample(context, traceId, spanName, spanKind, attributes, links);
      };
      ParentBasedSampler.prototype.toString = function () {
        return "ParentBased{root=" + this._root.toString() + ", remoteParentSampled=" + this._remoteParentSampled.toString() + ", remoteParentNotSampled=" + this._remoteParentNotSampled.toString() + ", localParentSampled=" + this._localParentSampled.toString() + ", localParentNotSampled=" + this._localParentNotSampled.toString() + "}";
      };
      return ParentBasedSampler;
    }();

    /*
     * Copyright The OpenTelemetry Authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      https://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    /** Sampler that samples a given fraction of traces based of trace id deterministically. */
    var TraceIdRatioBasedSampler = /** @class */function () {
      function TraceIdRatioBasedSampler(_ratio) {
        if (_ratio === void 0) {
          _ratio = 0;
        }
        this._ratio = _ratio;
        this._ratio = this._normalize(_ratio);
        this._upperBound = Math.floor(this._ratio * 0xffffffff);
      }
      TraceIdRatioBasedSampler.prototype.shouldSample = function (context, traceId) {
        return {
          decision: isValidTraceId(traceId) && this._accumulate(traceId) < this._upperBound ? SamplingDecision.RECORD_AND_SAMPLED : SamplingDecision.NOT_RECORD
        };
      };
      TraceIdRatioBasedSampler.prototype.toString = function () {
        return "TraceIdRatioBased{" + this._ratio + "}";
      };
      TraceIdRatioBasedSampler.prototype._normalize = function (ratio) {
        if (typeof ratio !== 'number' || isNaN(ratio)) return 0;
        return ratio >= 1 ? 1 : ratio <= 0 ? 0 : ratio;
      };
      TraceIdRatioBasedSampler.prototype._accumulate = function (traceId) {
        var accumulation = 0;
        for (var i = 0; i < traceId.length / 8; i++) {
          var pos = i * 8;
          var part = parseInt(traceId.slice(pos, pos + 8), 16);
          accumulation = (accumulation ^ part) >>> 0;
        }
        return accumulation;
      };
      return TraceIdRatioBasedSampler;
    }();

    /*
     * Copyright The OpenTelemetry Authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      https://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    var FALLBACK_OTEL_TRACES_SAMPLER = TracesSamplerValues.AlwaysOn;
    var DEFAULT_RATIO = 1;
    /**
     * Load default configuration. For fields with primitive values, any user-provided
     * value will override the corresponding default value. For fields with
     * non-primitive values (like `spanLimits`), the user-provided value will be
     * used to extend the default value.
     */
    // object needs to be wrapped in this function and called when needed otherwise
    // envs are parsed before tests are ran - causes tests using these envs to fail
    function loadDefaultConfig() {
      var env = getEnv();
      return {
        sampler: buildSamplerFromEnv(env),
        forceFlushTimeoutMillis: 30000,
        generalLimits: {
          attributeValueLengthLimit: env.OTEL_ATTRIBUTE_VALUE_LENGTH_LIMIT,
          attributeCountLimit: env.OTEL_ATTRIBUTE_COUNT_LIMIT
        },
        spanLimits: {
          attributeValueLengthLimit: env.OTEL_SPAN_ATTRIBUTE_VALUE_LENGTH_LIMIT,
          attributeCountLimit: env.OTEL_SPAN_ATTRIBUTE_COUNT_LIMIT,
          linkCountLimit: env.OTEL_SPAN_LINK_COUNT_LIMIT,
          eventCountLimit: env.OTEL_SPAN_EVENT_COUNT_LIMIT,
          attributePerEventCountLimit: env.OTEL_SPAN_ATTRIBUTE_PER_EVENT_COUNT_LIMIT,
          attributePerLinkCountLimit: env.OTEL_SPAN_ATTRIBUTE_PER_LINK_COUNT_LIMIT
        },
        mergeResourceWithDefaults: true
      };
    }
    /**
     * Based on environment, builds a sampler, complies with specification.
     * @param environment optional, by default uses getEnv(), but allows passing a value to reuse parsed environment
     */
    function buildSamplerFromEnv(environment) {
      if (environment === void 0) {
        environment = getEnv();
      }
      switch (environment.OTEL_TRACES_SAMPLER) {
        case TracesSamplerValues.AlwaysOn:
          return new AlwaysOnSampler();
        case TracesSamplerValues.AlwaysOff:
          return new AlwaysOffSampler();
        case TracesSamplerValues.ParentBasedAlwaysOn:
          return new ParentBasedSampler({
            root: new AlwaysOnSampler()
          });
        case TracesSamplerValues.ParentBasedAlwaysOff:
          return new ParentBasedSampler({
            root: new AlwaysOffSampler()
          });
        case TracesSamplerValues.TraceIdRatio:
          return new TraceIdRatioBasedSampler(getSamplerProbabilityFromEnv(environment));
        case TracesSamplerValues.ParentBasedTraceIdRatio:
          return new ParentBasedSampler({
            root: new TraceIdRatioBasedSampler(getSamplerProbabilityFromEnv(environment))
          });
        default:
          diag.error("OTEL_TRACES_SAMPLER value \"" + environment.OTEL_TRACES_SAMPLER + " invalid, defaulting to " + FALLBACK_OTEL_TRACES_SAMPLER + "\".");
          return new AlwaysOnSampler();
      }
    }
    function getSamplerProbabilityFromEnv(environment) {
      if (environment.OTEL_TRACES_SAMPLER_ARG === undefined || environment.OTEL_TRACES_SAMPLER_ARG === '') {
        diag.error("OTEL_TRACES_SAMPLER_ARG is blank, defaulting to " + DEFAULT_RATIO + ".");
        return DEFAULT_RATIO;
      }
      var probability = Number(environment.OTEL_TRACES_SAMPLER_ARG);
      if (isNaN(probability)) {
        diag.error("OTEL_TRACES_SAMPLER_ARG=" + environment.OTEL_TRACES_SAMPLER_ARG + " was given, but it is invalid, defaulting to " + DEFAULT_RATIO + ".");
        return DEFAULT_RATIO;
      }
      if (probability < 0 || probability > 1) {
        diag.error("OTEL_TRACES_SAMPLER_ARG=" + environment.OTEL_TRACES_SAMPLER_ARG + " was given, but it is out of range ([0..1]), defaulting to " + DEFAULT_RATIO + ".");
        return DEFAULT_RATIO;
      }
      return probability;
    }

    /*
     * Copyright The OpenTelemetry Authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      https://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    /**
     * Function to merge Default configuration (as specified in './config') with
     * user provided configurations.
     */
    function mergeConfig(userConfig) {
      var perInstanceDefaults = {
        sampler: buildSamplerFromEnv()
      };
      var DEFAULT_CONFIG = loadDefaultConfig();
      var target = Object.assign({}, DEFAULT_CONFIG, perInstanceDefaults, userConfig);
      target.generalLimits = Object.assign({}, DEFAULT_CONFIG.generalLimits, userConfig.generalLimits || {});
      target.spanLimits = Object.assign({}, DEFAULT_CONFIG.spanLimits, userConfig.spanLimits || {});
      return target;
    }
    /**
     * When general limits are provided and model specific limits are not,
     * configures the model specific limits by using the values from the general ones.
     * @param userConfig User provided tracer configuration
     */
    function reconfigureLimits(userConfig) {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m;
      var spanLimits = Object.assign({}, userConfig.spanLimits);
      var parsedEnvConfig = getEnvWithoutDefaults();
      /**
       * Reassign span attribute count limit to use first non null value defined by user or use default value
       */
      spanLimits.attributeCountLimit = (_f = (_e = (_d = (_b = (_a = userConfig.spanLimits) === null || _a === void 0 ? void 0 : _a.attributeCountLimit) !== null && _b !== void 0 ? _b : (_c = userConfig.generalLimits) === null || _c === void 0 ? void 0 : _c.attributeCountLimit) !== null && _d !== void 0 ? _d : parsedEnvConfig.OTEL_SPAN_ATTRIBUTE_COUNT_LIMIT) !== null && _e !== void 0 ? _e : parsedEnvConfig.OTEL_ATTRIBUTE_COUNT_LIMIT) !== null && _f !== void 0 ? _f : DEFAULT_ATTRIBUTE_COUNT_LIMIT;
      /**
       * Reassign span attribute value length limit to use first non null value defined by user or use default value
       */
      spanLimits.attributeValueLengthLimit = (_m = (_l = (_k = (_h = (_g = userConfig.spanLimits) === null || _g === void 0 ? void 0 : _g.attributeValueLengthLimit) !== null && _h !== void 0 ? _h : (_j = userConfig.generalLimits) === null || _j === void 0 ? void 0 : _j.attributeValueLengthLimit) !== null && _k !== void 0 ? _k : parsedEnvConfig.OTEL_SPAN_ATTRIBUTE_VALUE_LENGTH_LIMIT) !== null && _l !== void 0 ? _l : parsedEnvConfig.OTEL_ATTRIBUTE_VALUE_LENGTH_LIMIT) !== null && _m !== void 0 ? _m : DEFAULT_ATTRIBUTE_VALUE_LENGTH_LIMIT;
      return Object.assign({}, userConfig, {
        spanLimits: spanLimits
      });
    }

    /*
     * Copyright The OpenTelemetry Authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      https://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    /**
     * Implementation of the {@link SpanProcessor} that batches spans exported by
     * the SDK then pushes them to the exporter pipeline.
     */
    var BatchSpanProcessorBase = /** @class */function () {
      function BatchSpanProcessorBase(_exporter, config) {
        this._exporter = _exporter;
        this._isExporting = false;
        this._finishedSpans = [];
        this._droppedSpansCount = 0;
        var env = getEnv();
        this._maxExportBatchSize = typeof (config === null || config === void 0 ? void 0 : config.maxExportBatchSize) === 'number' ? config.maxExportBatchSize : env.OTEL_BSP_MAX_EXPORT_BATCH_SIZE;
        this._maxQueueSize = typeof (config === null || config === void 0 ? void 0 : config.maxQueueSize) === 'number' ? config.maxQueueSize : env.OTEL_BSP_MAX_QUEUE_SIZE;
        this._scheduledDelayMillis = typeof (config === null || config === void 0 ? void 0 : config.scheduledDelayMillis) === 'number' ? config.scheduledDelayMillis : env.OTEL_BSP_SCHEDULE_DELAY;
        this._exportTimeoutMillis = typeof (config === null || config === void 0 ? void 0 : config.exportTimeoutMillis) === 'number' ? config.exportTimeoutMillis : env.OTEL_BSP_EXPORT_TIMEOUT;
        this._shutdownOnce = new BindOnceFuture(this._shutdown, this);
        if (this._maxExportBatchSize > this._maxQueueSize) {
          diag.warn('BatchSpanProcessor: maxExportBatchSize must be smaller or equal to maxQueueSize, setting maxExportBatchSize to match maxQueueSize');
          this._maxExportBatchSize = this._maxQueueSize;
        }
      }
      BatchSpanProcessorBase.prototype.forceFlush = function () {
        if (this._shutdownOnce.isCalled) {
          return this._shutdownOnce.promise;
        }
        return this._flushAll();
      };
      // does nothing.
      BatchSpanProcessorBase.prototype.onStart = function (_span, _parentContext) {};
      BatchSpanProcessorBase.prototype.onEnd = function (span) {
        if (this._shutdownOnce.isCalled) {
          return;
        }
        if ((span.spanContext().traceFlags & TraceFlags.SAMPLED) === 0) {
          return;
        }
        this._addToBuffer(span);
      };
      BatchSpanProcessorBase.prototype.shutdown = function () {
        return this._shutdownOnce.call();
      };
      BatchSpanProcessorBase.prototype._shutdown = function () {
        var _this = this;
        return Promise.resolve().then(function () {
          return _this.onShutdown();
        }).then(function () {
          return _this._flushAll();
        }).then(function () {
          return _this._exporter.shutdown();
        });
      };
      /** Add a span in the buffer. */
      BatchSpanProcessorBase.prototype._addToBuffer = function (span) {
        if (this._finishedSpans.length >= this._maxQueueSize) {
          // limit reached, drop span
          if (this._droppedSpansCount === 0) {
            diag.debug('maxQueueSize reached, dropping spans');
          }
          this._droppedSpansCount++;
          return;
        }
        if (this._droppedSpansCount > 0) {
          // some spans were dropped, log once with count of spans dropped
          diag.warn("Dropped " + this._droppedSpansCount + " spans because maxQueueSize reached");
          this._droppedSpansCount = 0;
        }
        this._finishedSpans.push(span);
        this._maybeStartTimer();
      };
      /**
       * Send all spans to the exporter respecting the batch size limit
       * This function is used only on forceFlush or shutdown,
       * for all other cases _flush should be used
       * */
      BatchSpanProcessorBase.prototype._flushAll = function () {
        var _this = this;
        return new Promise(function (resolve, reject) {
          var promises = [];
          // calculate number of batches
          var count = Math.ceil(_this._finishedSpans.length / _this._maxExportBatchSize);
          for (var i = 0, j = count; i < j; i++) {
            promises.push(_this._flushOneBatch());
          }
          Promise.all(promises).then(function () {
            resolve();
          }).catch(reject);
        });
      };
      BatchSpanProcessorBase.prototype._flushOneBatch = function () {
        var _this = this;
        this._clearTimer();
        if (this._finishedSpans.length === 0) {
          return Promise.resolve();
        }
        return new Promise(function (resolve, reject) {
          var timer = setTimeout(function () {
            // don't wait anymore for export, this way the next batch can start
            reject(new Error('Timeout'));
          }, _this._exportTimeoutMillis);
          // prevent downstream exporter calls from generating spans
          context.with(suppressTracing(context.active()), function () {
            // Reset the finished spans buffer here because the next invocations of the _flush method
            // could pass the same finished spans to the exporter if the buffer is cleared
            // outside the execution of this callback.
            var spans;
            if (_this._finishedSpans.length <= _this._maxExportBatchSize) {
              spans = _this._finishedSpans;
              _this._finishedSpans = [];
            } else {
              spans = _this._finishedSpans.splice(0, _this._maxExportBatchSize);
            }
            var doExport = function () {
              return _this._exporter.export(spans, function (result) {
                var _a;
                clearTimeout(timer);
                if (result.code === ExportResultCode.SUCCESS) {
                  resolve();
                } else {
                  reject((_a = result.error) !== null && _a !== void 0 ? _a : new Error('BatchSpanProcessor: span export failed'));
                }
              });
            };
            var pendingResources = null;
            for (var i = 0, len = spans.length; i < len; i++) {
              var span = spans[i];
              if (span.resource.asyncAttributesPending && span.resource.waitForAsyncAttributes) {
                pendingResources !== null && pendingResources !== void 0 ? pendingResources : pendingResources = [];
                pendingResources.push(span.resource.waitForAsyncAttributes());
              }
            }
            // Avoid scheduling a promise to make the behavior more predictable and easier to test
            if (pendingResources === null) {
              doExport();
            } else {
              Promise.all(pendingResources).then(doExport, function (err) {
                globalErrorHandler(err);
                reject(err);
              });
            }
          });
        });
      };
      BatchSpanProcessorBase.prototype._maybeStartTimer = function () {
        var _this = this;
        if (this._isExporting) return;
        var flush = function () {
          _this._isExporting = true;
          _this._flushOneBatch().finally(function () {
            _this._isExporting = false;
            if (_this._finishedSpans.length > 0) {
              _this._clearTimer();
              _this._maybeStartTimer();
            }
          }).catch(function (e) {
            _this._isExporting = false;
            globalErrorHandler(e);
          });
        };
        // we only wait if the queue doesn't have enough elements yet
        if (this._finishedSpans.length >= this._maxExportBatchSize) {
          return flush();
        }
        if (this._timer !== undefined) return;
        this._timer = setTimeout(function () {
          return flush();
        }, this._scheduledDelayMillis);
        unrefTimer(this._timer);
      };
      BatchSpanProcessorBase.prototype._clearTimer = function () {
        if (this._timer !== undefined) {
          clearTimeout(this._timer);
          this._timer = undefined;
        }
      };
      return BatchSpanProcessorBase;
    }();

    /*
     * Copyright The OpenTelemetry Authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      https://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    var __extends$7 = undefined && undefined.__extends || function () {
      var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf || {
          __proto__: []
        } instanceof Array && function (d, b) {
          d.__proto__ = b;
        } || function (d, b) {
          for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
        };
        return extendStatics(d, b);
      };
      return function (d, b) {
        if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var BatchSpanProcessor = /** @class */function (_super) {
      __extends$7(BatchSpanProcessor, _super);
      function BatchSpanProcessor(_exporter, config) {
        var _this = _super.call(this, _exporter, config) || this;
        _this.onInit(config);
        return _this;
      }
      BatchSpanProcessor.prototype.onInit = function (config) {
        var _this = this;
        if ((config === null || config === void 0 ? void 0 : config.disableAutoFlushOnDocumentHide) !== true && typeof document !== 'undefined') {
          this._visibilityChangeListener = function () {
            if (document.visibilityState === 'hidden') {
              _this.forceFlush().catch(function (error) {
                globalErrorHandler(error);
              });
            }
          };
          this._pageHideListener = function () {
            _this.forceFlush().catch(function (error) {
              globalErrorHandler(error);
            });
          };
          document.addEventListener('visibilitychange', this._visibilityChangeListener);
          // use 'pagehide' event as a fallback for Safari; see https://bugs.webkit.org/show_bug.cgi?id=116769
          document.addEventListener('pagehide', this._pageHideListener);
        }
      };
      BatchSpanProcessor.prototype.onShutdown = function () {
        if (typeof document !== 'undefined') {
          if (this._visibilityChangeListener) {
            document.removeEventListener('visibilitychange', this._visibilityChangeListener);
          }
          if (this._pageHideListener) {
            document.removeEventListener('pagehide', this._pageHideListener);
          }
        }
      };
      return BatchSpanProcessor;
    }(BatchSpanProcessorBase);

    /*
     * Copyright The OpenTelemetry Authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      https://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    var SPAN_ID_BYTES = 8;
    var TRACE_ID_BYTES = 16;
    var RandomIdGenerator = /** @class */function () {
      function RandomIdGenerator() {
        /**
         * Returns a random 16-byte trace ID formatted/encoded as a 32 lowercase hex
         * characters corresponding to 128 bits.
         */
        this.generateTraceId = getIdGenerator$1(TRACE_ID_BYTES);
        /**
         * Returns a random 8-byte span ID formatted/encoded as a 16 lowercase hex
         * characters corresponding to 64 bits.
         */
        this.generateSpanId = getIdGenerator$1(SPAN_ID_BYTES);
      }
      return RandomIdGenerator;
    }();
    var SHARED_CHAR_CODES_ARRAY$1 = Array(32);
    function getIdGenerator$1(bytes) {
      return function generateId() {
        for (var i = 0; i < bytes * 2; i++) {
          SHARED_CHAR_CODES_ARRAY$1[i] = Math.floor(Math.random() * 16) + 48;
          // valid hex characters in the range 48-57 and 97-102
          if (SHARED_CHAR_CODES_ARRAY$1[i] >= 58) {
            SHARED_CHAR_CODES_ARRAY$1[i] += 39;
          }
        }
        return String.fromCharCode.apply(null, SHARED_CHAR_CODES_ARRAY$1.slice(0, bytes * 2));
      };
    }

    /*
     * Copyright The OpenTelemetry Authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      https://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    /**
     * This class represents a basic tracer.
     */
    var Tracer = /** @class */function () {
      /**
       * Constructs a new Tracer instance.
       */
      function Tracer(instrumentationLibrary, config, _tracerProvider) {
        this._tracerProvider = _tracerProvider;
        var localConfig = mergeConfig(config);
        this._sampler = localConfig.sampler;
        this._generalLimits = localConfig.generalLimits;
        this._spanLimits = localConfig.spanLimits;
        this._idGenerator = config.idGenerator || new RandomIdGenerator();
        this.resource = _tracerProvider.resource;
        this.instrumentationLibrary = instrumentationLibrary;
      }
      /**
       * Starts a new Span or returns the default NoopSpan based on the sampling
       * decision.
       */
      Tracer.prototype.startSpan = function (name, options, context$1) {
        var _a, _b, _c;
        if (options === void 0) {
          options = {};
        }
        if (context$1 === void 0) {
          context$1 = context.active();
        }
        // remove span from context in case a root span is requested via options
        if (options.root) {
          context$1 = trace.deleteSpan(context$1);
        }
        var parentSpan = trace.getSpan(context$1);
        if (isTracingSuppressed(context$1)) {
          diag.debug('Instrumentation suppressed, returning Noop Span');
          var nonRecordingSpan = trace.wrapSpanContext(INVALID_SPAN_CONTEXT);
          return nonRecordingSpan;
        }
        var parentSpanContext = parentSpan === null || parentSpan === void 0 ? void 0 : parentSpan.spanContext();
        var spanId = this._idGenerator.generateSpanId();
        var traceId;
        var traceState;
        var parentSpanId;
        if (!parentSpanContext || !trace.isSpanContextValid(parentSpanContext)) {
          // New root span.
          traceId = this._idGenerator.generateTraceId();
        } else {
          // New child span.
          traceId = parentSpanContext.traceId;
          traceState = parentSpanContext.traceState;
          parentSpanId = parentSpanContext.spanId;
        }
        var spanKind = (_a = options.kind) !== null && _a !== void 0 ? _a : SpanKind.INTERNAL;
        var links = ((_b = options.links) !== null && _b !== void 0 ? _b : []).map(function (link) {
          return {
            context: link.context,
            attributes: sanitizeAttributes(link.attributes)
          };
        });
        var attributes = sanitizeAttributes(options.attributes);
        // make sampling decision
        var samplingResult = this._sampler.shouldSample(context$1, traceId, name, spanKind, attributes, links);
        traceState = (_c = samplingResult.traceState) !== null && _c !== void 0 ? _c : traceState;
        var traceFlags = samplingResult.decision === SamplingDecision$1.RECORD_AND_SAMPLED ? TraceFlags.SAMPLED : TraceFlags.NONE;
        var spanContext = {
          traceId: traceId,
          spanId: spanId,
          traceFlags: traceFlags,
          traceState: traceState
        };
        if (samplingResult.decision === SamplingDecision$1.NOT_RECORD) {
          diag.debug('Recording is off, propagating context in a non-recording span');
          var nonRecordingSpan = trace.wrapSpanContext(spanContext);
          return nonRecordingSpan;
        }
        // Set initial span attributes. The attributes object may have been mutated
        // by the sampler, so we sanitize the merged attributes before setting them.
        var initAttributes = sanitizeAttributes(Object.assign(attributes, samplingResult.attributes));
        var span = new Span(this, context$1, name, spanContext, spanKind, parentSpanId, links, options.startTime, undefined, initAttributes);
        return span;
      };
      Tracer.prototype.startActiveSpan = function (name, arg2, arg3, arg4) {
        var opts;
        var ctx;
        var fn;
        if (arguments.length < 2) {
          return;
        } else if (arguments.length === 2) {
          fn = arg2;
        } else if (arguments.length === 3) {
          opts = arg2;
          fn = arg3;
        } else {
          opts = arg2;
          ctx = arg3;
          fn = arg4;
        }
        var parentContext = ctx !== null && ctx !== void 0 ? ctx : context.active();
        var span = this.startSpan(name, opts, parentContext);
        var contextWithSpanSet = trace.setSpan(parentContext, span);
        return context.with(contextWithSpanSet, fn, undefined, span);
      };
      /** Returns the active {@link GeneralLimits}. */
      Tracer.prototype.getGeneralLimits = function () {
        return this._generalLimits;
      };
      /** Returns the active {@link SpanLimits}. */
      Tracer.prototype.getSpanLimits = function () {
        return this._spanLimits;
      };
      Tracer.prototype.getActiveSpanProcessor = function () {
        return this._tracerProvider.getActiveSpanProcessor();
      };
      return Tracer;
    }();

    /*
     * Copyright The OpenTelemetry Authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      https://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    var __values$3 = undefined && undefined.__values || function (o) {
      var s = typeof Symbol === "function" && Symbol.iterator,
        m = s && o[s],
        i = 0;
      if (m) return m.call(o);
      if (o && typeof o.length === "number") return {
        next: function () {
          if (o && i >= o.length) o = void 0;
          return {
            value: o && o[i++],
            done: !o
          };
        }
      };
      throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    };
    /**
     * Implementation of the {@link SpanProcessor} that simply forwards all
     * received events to a list of {@link SpanProcessor}s.
     */
    var MultiSpanProcessor = /** @class */function () {
      function MultiSpanProcessor(_spanProcessors) {
        this._spanProcessors = _spanProcessors;
      }
      MultiSpanProcessor.prototype.forceFlush = function () {
        var e_1, _a;
        var promises = [];
        try {
          for (var _b = __values$3(this._spanProcessors), _c = _b.next(); !_c.done; _c = _b.next()) {
            var spanProcessor = _c.value;
            promises.push(spanProcessor.forceFlush());
          }
        } catch (e_1_1) {
          e_1 = {
            error: e_1_1
          };
        } finally {
          try {
            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
          } finally {
            if (e_1) throw e_1.error;
          }
        }
        return new Promise(function (resolve) {
          Promise.all(promises).then(function () {
            resolve();
          }).catch(function (error) {
            globalErrorHandler(error || new Error('MultiSpanProcessor: forceFlush failed'));
            resolve();
          });
        });
      };
      MultiSpanProcessor.prototype.onStart = function (span, context) {
        var e_2, _a;
        try {
          for (var _b = __values$3(this._spanProcessors), _c = _b.next(); !_c.done; _c = _b.next()) {
            var spanProcessor = _c.value;
            spanProcessor.onStart(span, context);
          }
        } catch (e_2_1) {
          e_2 = {
            error: e_2_1
          };
        } finally {
          try {
            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
          } finally {
            if (e_2) throw e_2.error;
          }
        }
      };
      MultiSpanProcessor.prototype.onEnd = function (span) {
        var e_3, _a;
        try {
          for (var _b = __values$3(this._spanProcessors), _c = _b.next(); !_c.done; _c = _b.next()) {
            var spanProcessor = _c.value;
            spanProcessor.onEnd(span);
          }
        } catch (e_3_1) {
          e_3 = {
            error: e_3_1
          };
        } finally {
          try {
            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
          } finally {
            if (e_3) throw e_3.error;
          }
        }
      };
      MultiSpanProcessor.prototype.shutdown = function () {
        var e_4, _a;
        var promises = [];
        try {
          for (var _b = __values$3(this._spanProcessors), _c = _b.next(); !_c.done; _c = _b.next()) {
            var spanProcessor = _c.value;
            promises.push(spanProcessor.shutdown());
          }
        } catch (e_4_1) {
          e_4 = {
            error: e_4_1
          };
        } finally {
          try {
            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
          } finally {
            if (e_4) throw e_4.error;
          }
        }
        return new Promise(function (resolve, reject) {
          Promise.all(promises).then(function () {
            resolve();
          }, reject);
        });
      };
      return MultiSpanProcessor;
    }();

    /*
     * Copyright The OpenTelemetry Authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      https://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    /** No-op implementation of SpanProcessor */
    var NoopSpanProcessor = /** @class */function () {
      function NoopSpanProcessor() {}
      NoopSpanProcessor.prototype.onStart = function (_span, _context) {};
      NoopSpanProcessor.prototype.onEnd = function (_span) {};
      NoopSpanProcessor.prototype.shutdown = function () {
        return Promise.resolve();
      };
      NoopSpanProcessor.prototype.forceFlush = function () {
        return Promise.resolve();
      };
      return NoopSpanProcessor;
    }();

    /*
     * Copyright The OpenTelemetry Authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      https://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    var __read$8 = undefined && undefined.__read || function (o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m) return o;
      var i = m.call(o),
        r,
        ar = [],
        e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
      } catch (error) {
        e = {
          error: error
        };
      } finally {
        try {
          if (r && !r.done && (m = i["return"])) m.call(i);
        } finally {
          if (e) throw e.error;
        }
      }
      return ar;
    };
    var __spreadArray$2 = undefined && undefined.__spreadArray || function (to, from, pack) {
      if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
          if (!ar) ar = Array.prototype.slice.call(from, 0, i);
          ar[i] = from[i];
        }
      }
      return to.concat(ar || Array.prototype.slice.call(from));
    };
    var ForceFlushState;
    (function (ForceFlushState) {
      ForceFlushState[ForceFlushState["resolved"] = 0] = "resolved";
      ForceFlushState[ForceFlushState["timeout"] = 1] = "timeout";
      ForceFlushState[ForceFlushState["error"] = 2] = "error";
      ForceFlushState[ForceFlushState["unresolved"] = 3] = "unresolved";
    })(ForceFlushState || (ForceFlushState = {}));
    /**
     * This class represents a basic tracer provider which platform libraries can extend
     */
    var BasicTracerProvider = /** @class */function () {
      function BasicTracerProvider(config) {
        if (config === void 0) {
          config = {};
        }
        var _a, _b;
        this._registeredSpanProcessors = [];
        this._tracers = new Map();
        var mergedConfig = merge({}, loadDefaultConfig(), reconfigureLimits(config));
        this.resource = (_a = mergedConfig.resource) !== null && _a !== void 0 ? _a : Resource.empty();
        if (mergedConfig.mergeResourceWithDefaults) {
          this.resource = Resource.default().merge(this.resource);
        }
        this._config = Object.assign({}, mergedConfig, {
          resource: this.resource
        });
        if ((_b = config.spanProcessors) === null || _b === void 0 ? void 0 : _b.length) {
          this._registeredSpanProcessors = __spreadArray$2([], __read$8(config.spanProcessors), false);
          this.activeSpanProcessor = new MultiSpanProcessor(this._registeredSpanProcessors);
        } else {
          var defaultExporter = this._buildExporterFromEnv();
          if (defaultExporter !== undefined) {
            var batchProcessor = new BatchSpanProcessor(defaultExporter);
            this.activeSpanProcessor = batchProcessor;
          } else {
            this.activeSpanProcessor = new NoopSpanProcessor();
          }
        }
      }
      BasicTracerProvider.prototype.getTracer = function (name, version, options) {
        var key = name + "@" + (version || '') + ":" + ((options === null || options === void 0 ? void 0 : options.schemaUrl) || '');
        if (!this._tracers.has(key)) {
          this._tracers.set(key, new Tracer({
            name: name,
            version: version,
            schemaUrl: options === null || options === void 0 ? void 0 : options.schemaUrl
          }, this._config, this));
        }
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        return this._tracers.get(key);
      };
      /**
       * @deprecated please use {@link TracerConfig} spanProcessors property
       * Adds a new {@link SpanProcessor} to this tracer.
       * @param spanProcessor the new SpanProcessor to be added.
       */
      BasicTracerProvider.prototype.addSpanProcessor = function (spanProcessor) {
        if (this._registeredSpanProcessors.length === 0) {
          // since we might have enabled by default a batchProcessor, we disable it
          // before adding the new one
          this.activeSpanProcessor.shutdown().catch(function (err) {
            return diag.error('Error while trying to shutdown current span processor', err);
          });
        }
        this._registeredSpanProcessors.push(spanProcessor);
        this.activeSpanProcessor = new MultiSpanProcessor(this._registeredSpanProcessors);
      };
      BasicTracerProvider.prototype.getActiveSpanProcessor = function () {
        return this.activeSpanProcessor;
      };
      /**
       * Register this TracerProvider for use with the OpenTelemetry API.
       * Undefined values may be replaced with defaults, and
       * null values will be skipped.
       *
       * @param config Configuration object for SDK registration
       */
      BasicTracerProvider.prototype.register = function (config) {
        if (config === void 0) {
          config = {};
        }
        trace.setGlobalTracerProvider(this);
        if (config.propagator === undefined) {
          config.propagator = this._buildPropagatorFromEnv();
        }
        if (config.contextManager) {
          context.setGlobalContextManager(config.contextManager);
        }
        if (config.propagator) {
          propagation.setGlobalPropagator(config.propagator);
        }
      };
      BasicTracerProvider.prototype.forceFlush = function () {
        var timeout = this._config.forceFlushTimeoutMillis;
        var promises = this._registeredSpanProcessors.map(function (spanProcessor) {
          return new Promise(function (resolve) {
            var state;
            var timeoutInterval = setTimeout(function () {
              resolve(new Error("Span processor did not completed within timeout period of " + timeout + " ms"));
              state = ForceFlushState.timeout;
            }, timeout);
            spanProcessor.forceFlush().then(function () {
              clearTimeout(timeoutInterval);
              if (state !== ForceFlushState.timeout) {
                state = ForceFlushState.resolved;
                resolve(state);
              }
            }).catch(function (error) {
              clearTimeout(timeoutInterval);
              state = ForceFlushState.error;
              resolve(error);
            });
          });
        });
        return new Promise(function (resolve, reject) {
          Promise.all(promises).then(function (results) {
            var errors = results.filter(function (result) {
              return result !== ForceFlushState.resolved;
            });
            if (errors.length > 0) {
              reject(errors);
            } else {
              resolve();
            }
          }).catch(function (error) {
            return reject([error]);
          });
        });
      };
      BasicTracerProvider.prototype.shutdown = function () {
        return this.activeSpanProcessor.shutdown();
      };
      /**
       * TS cannot yet infer the type of this.constructor:
       * https://github.com/Microsoft/TypeScript/issues/3841#issuecomment-337560146
       * There is no need to override either of the getters in your child class.
       * The type of the registered component maps should be the same across all
       * classes in the inheritance tree.
       */
      BasicTracerProvider.prototype._getPropagator = function (name) {
        var _a;
        return (_a = this.constructor._registeredPropagators.get(name)) === null || _a === void 0 ? void 0 : _a();
      };
      BasicTracerProvider.prototype._getSpanExporter = function (name) {
        var _a;
        return (_a = this.constructor._registeredExporters.get(name)) === null || _a === void 0 ? void 0 : _a();
      };
      BasicTracerProvider.prototype._buildPropagatorFromEnv = function () {
        var _this = this;
        // per spec, propagators from env must be deduplicated
        var uniquePropagatorNames = Array.from(new Set(getEnv().OTEL_PROPAGATORS));
        var propagators = uniquePropagatorNames.map(function (name) {
          var propagator = _this._getPropagator(name);
          if (!propagator) {
            diag.warn("Propagator \"" + name + "\" requested through environment variable is unavailable.");
          }
          return propagator;
        });
        var validPropagators = propagators.reduce(function (list, item) {
          if (item) {
            list.push(item);
          }
          return list;
        }, []);
        if (validPropagators.length === 0) {
          return;
        } else if (uniquePropagatorNames.length === 1) {
          return validPropagators[0];
        } else {
          return new CompositePropagator({
            propagators: validPropagators
          });
        }
      };
      BasicTracerProvider.prototype._buildExporterFromEnv = function () {
        var exporterName = getEnv().OTEL_TRACES_EXPORTER;
        if (exporterName === 'none' || exporterName === '') return;
        var exporter = this._getSpanExporter(exporterName);
        if (!exporter) {
          diag.error("Exporter \"" + exporterName + "\" requested through environment variable is unavailable.");
        }
        return exporter;
      };
      BasicTracerProvider._registeredPropagators = new Map([['tracecontext', function () {
        return new W3CTraceContextPropagator();
      }], ['baggage', function () {
        return new W3CBaggagePropagator();
      }]]);
      BasicTracerProvider._registeredExporters = new Map();
      return BasicTracerProvider;
    }();

    /*
     * Copyright The OpenTelemetry Authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      https://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    var __read$7 = undefined && undefined.__read || function (o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m) return o;
      var i = m.call(o),
        r,
        ar = [],
        e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
      } catch (error) {
        e = {
          error: error
        };
      } finally {
        try {
          if (r && !r.done && (m = i["return"])) m.call(i);
        } finally {
          if (e) throw e.error;
        }
      }
      return ar;
    };
    var __spreadArray$1 = undefined && undefined.__spreadArray || function (to, from, pack) {
      if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
          if (!ar) ar = Array.prototype.slice.call(from, 0, i);
          ar[i] = from[i];
        }
      }
      return to.concat(ar || Array.prototype.slice.call(from));
    };
    /**
     * Stack Context Manager for managing the state in web
     * it doesn't fully support the async calls though
     */
    var StackContextManager = /** @class */function () {
      function StackContextManager() {
        /**
         * whether the context manager is enabled or not
         */
        this._enabled = false;
        /**
         * Keeps the reference to current context
         */
        this._currentContext = ROOT_CONTEXT;
      }
      /**
       *
       * @param context
       * @param target Function to be executed within the context
       */
      // eslint-disable-next-line @typescript-eslint/ban-types
      StackContextManager.prototype._bindFunction = function (context, target) {
        if (context === void 0) {
          context = ROOT_CONTEXT;
        }
        var manager = this;
        var contextWrapper = function () {
          var _this = this;
          var args = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
          }
          return manager.with(context, function () {
            return target.apply(_this, args);
          });
        };
        Object.defineProperty(contextWrapper, 'length', {
          enumerable: false,
          configurable: true,
          writable: false,
          value: target.length
        });
        return contextWrapper;
      };
      /**
       * Returns the active context
       */
      StackContextManager.prototype.active = function () {
        return this._currentContext;
      };
      /**
       * Binds a the certain context or the active one to the target function and then returns the target
       * @param context A context (span) to be bind to target
       * @param target a function or event emitter. When target or one of its callbacks is called,
       *  the provided context will be used as the active context for the duration of the call.
       */
      StackContextManager.prototype.bind = function (context, target) {
        // if no specific context to propagate is given, we use the current one
        if (context === undefined) {
          context = this.active();
        }
        if (typeof target === 'function') {
          return this._bindFunction(context, target);
        }
        return target;
      };
      /**
       * Disable the context manager (clears the current context)
       */
      StackContextManager.prototype.disable = function () {
        this._currentContext = ROOT_CONTEXT;
        this._enabled = false;
        return this;
      };
      /**
       * Enables the context manager and creates a default(root) context
       */
      StackContextManager.prototype.enable = function () {
        if (this._enabled) {
          return this;
        }
        this._enabled = true;
        this._currentContext = ROOT_CONTEXT;
        return this;
      };
      /**
       * Calls the callback function [fn] with the provided [context]. If [context] is undefined then it will use the window.
       * The context will be set as active
       * @param context
       * @param fn Callback function
       * @param thisArg optional receiver to be used for calling fn
       * @param args optional arguments forwarded to fn
       */
      StackContextManager.prototype.with = function (context, fn, thisArg) {
        var args = [];
        for (var _i = 3; _i < arguments.length; _i++) {
          args[_i - 3] = arguments[_i];
        }
        var previousContext = this._currentContext;
        this._currentContext = context || ROOT_CONTEXT;
        try {
          return fn.call.apply(fn, __spreadArray$1([thisArg], __read$7(args), false));
        } finally {
          this._currentContext = previousContext;
        }
      };
      return StackContextManager;
    }();

    /*
     * Copyright The OpenTelemetry Authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      https://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    var __extends$6 = undefined && undefined.__extends || function () {
      var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf || {
          __proto__: []
        } instanceof Array && function (d, b) {
          d.__proto__ = b;
        } || function (d, b) {
          for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
        };
        return extendStatics(d, b);
      };
      return function (d, b) {
        if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    /**
     * This class represents a web tracer with {@link StackContextManager}
     */
    var WebTracerProvider = /** @class */function (_super) {
      __extends$6(WebTracerProvider, _super);
      /**
       * Constructs a new Tracer instance.
       * @param config Web Tracer config
       */
      function WebTracerProvider(config) {
        if (config === void 0) {
          config = {};
        }
        var _this = _super.call(this, config) || this;
        if (config.contextManager) {
          throw 'contextManager should be defined in register method not in' + ' constructor';
        }
        if (config.propagator) {
          throw 'propagator should be defined in register method not in constructor';
        }
        return _this;
      }
      /**
       * Register this TracerProvider for use with the OpenTelemetry API.
       * Undefined values may be replaced with defaults, and
       * null values will be skipped.
       *
       * @param config Configuration object for SDK registration
       */
      WebTracerProvider.prototype.register = function (config) {
        if (config === void 0) {
          config = {};
        }
        if (config.contextManager === undefined) {
          config.contextManager = new StackContextManager();
        }
        if (config.contextManager) {
          config.contextManager.enable();
        }
        _super.prototype.register.call(this, config);
      };
      return WebTracerProvider;
    }(BasicTracerProvider);

    /*
     * Copyright The OpenTelemetry Authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      https://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    var PerformanceTimingNames;
    (function (PerformanceTimingNames) {
      PerformanceTimingNames["CONNECT_END"] = "connectEnd";
      PerformanceTimingNames["CONNECT_START"] = "connectStart";
      PerformanceTimingNames["DECODED_BODY_SIZE"] = "decodedBodySize";
      PerformanceTimingNames["DOM_COMPLETE"] = "domComplete";
      PerformanceTimingNames["DOM_CONTENT_LOADED_EVENT_END"] = "domContentLoadedEventEnd";
      PerformanceTimingNames["DOM_CONTENT_LOADED_EVENT_START"] = "domContentLoadedEventStart";
      PerformanceTimingNames["DOM_INTERACTIVE"] = "domInteractive";
      PerformanceTimingNames["DOMAIN_LOOKUP_END"] = "domainLookupEnd";
      PerformanceTimingNames["DOMAIN_LOOKUP_START"] = "domainLookupStart";
      PerformanceTimingNames["ENCODED_BODY_SIZE"] = "encodedBodySize";
      PerformanceTimingNames["FETCH_START"] = "fetchStart";
      PerformanceTimingNames["LOAD_EVENT_END"] = "loadEventEnd";
      PerformanceTimingNames["LOAD_EVENT_START"] = "loadEventStart";
      PerformanceTimingNames["NAVIGATION_START"] = "navigationStart";
      PerformanceTimingNames["REDIRECT_END"] = "redirectEnd";
      PerformanceTimingNames["REDIRECT_START"] = "redirectStart";
      PerformanceTimingNames["REQUEST_START"] = "requestStart";
      PerformanceTimingNames["RESPONSE_END"] = "responseEnd";
      PerformanceTimingNames["RESPONSE_START"] = "responseStart";
      PerformanceTimingNames["SECURE_CONNECTION_START"] = "secureConnectionStart";
      PerformanceTimingNames["UNLOAD_EVENT_END"] = "unloadEventEnd";
      PerformanceTimingNames["UNLOAD_EVENT_START"] = "unloadEventStart";
    })(PerformanceTimingNames || (PerformanceTimingNames = {}));

    /*
     * Copyright The OpenTelemetry Authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      https://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    var TMP_HTTP_RESPONSE_CONTENT_LENGTH = 'http.response_content_length';
    var TMP_HTTP_RESPONSE_CONTENT_LENGTH_UNCOMPRESSED = 'http.response_content_length_uncompressed';
    /**
     * The size of the response payload body in bytes. This is the number of bytes transferred excluding headers and is often, but not always, present as the [Content-Length](https://tools.ietf.org/html/rfc7230#section-3.3.2) header. For requests using transport encoding, this should be the compressed size.
     *
     * @deprecated Use ATTR_HTTP_RESPONSE_CONTENT_LENGTH in [incubating entry-point]({@link https://github.com/open-telemetry/opentelemetry-js/blob/main/semantic-conventions/README.md#unstable-semconv}).
     */
    var SEMATTRS_HTTP_RESPONSE_CONTENT_LENGTH = TMP_HTTP_RESPONSE_CONTENT_LENGTH;
    /**
     * The size of the uncompressed response payload body after transport decoding. Not set if transport encoding not used.
     *
     * @deprecated Use ATTR_HTTP_RESPONSE_CONTENT_LENGTH_UNCOMPRESSED in [incubating entry-point]({@link https://github.com/open-telemetry/opentelemetry-js/blob/main/semantic-conventions/README.md#unstable-semconv}).
     */
    var SEMATTRS_HTTP_RESPONSE_CONTENT_LENGTH_UNCOMPRESSED = TMP_HTTP_RESPONSE_CONTENT_LENGTH_UNCOMPRESSED;

    /*
     * Copyright The OpenTelemetry Authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      https://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    // Used to normalize relative URLs
    var urlNormalizingAnchor;
    function getUrlNormalizingAnchor() {
      if (!urlNormalizingAnchor) {
        urlNormalizingAnchor = document.createElement('a');
      }
      return urlNormalizingAnchor;
    }
    /**
     * Helper function to be able to use enum as typed key in type and in interface when using forEach
     * @param obj
     * @param key
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    function hasKey(obj, key) {
      return key in obj;
    }
    /**
     * Helper function for starting an event on span based on {@link PerformanceEntries}
     * @param span
     * @param performanceName name of performance entry for time start
     * @param entries
     * @param refPerfName name of performance entry to use for reference
     */
    function addSpanNetworkEvent(span, performanceName, entries, refPerfName) {
      var perfTime = undefined;
      var refTime = undefined;
      if (hasKey(entries, performanceName) && typeof entries[performanceName] === 'number') {
        perfTime = entries[performanceName];
      }
      var refName = PerformanceTimingNames.FETCH_START;
      // Use a reference time which is the earliest possible value so that the performance timings that are earlier should not be added
      // using FETCH START time in case no reference is provided
      if (hasKey(entries, refName) && typeof entries[refName] === 'number') {
        refTime = entries[refName];
      }
      if (perfTime !== undefined && refTime !== undefined && perfTime >= refTime) {
        span.addEvent(performanceName, perfTime);
        return span;
      }
      return undefined;
    }
    /**
     * Helper function for adding network events and content length attributes
     * @param span
     * @param resource
     * @param ignoreNetworkEvents
     */
    function addSpanNetworkEvents(span, resource, ignoreNetworkEvents) {
      if (ignoreNetworkEvents === void 0) {
        ignoreNetworkEvents = false;
      }
      if (!ignoreNetworkEvents) {
        addSpanNetworkEvent(span, PerformanceTimingNames.FETCH_START, resource);
        addSpanNetworkEvent(span, PerformanceTimingNames.DOMAIN_LOOKUP_START, resource);
        addSpanNetworkEvent(span, PerformanceTimingNames.DOMAIN_LOOKUP_END, resource);
        addSpanNetworkEvent(span, PerformanceTimingNames.CONNECT_START, resource);
        if (hasKey(resource, 'name') && resource['name'].startsWith('https:')) {
          addSpanNetworkEvent(span, PerformanceTimingNames.SECURE_CONNECTION_START, resource);
        }
        addSpanNetworkEvent(span, PerformanceTimingNames.CONNECT_END, resource);
        addSpanNetworkEvent(span, PerformanceTimingNames.REQUEST_START, resource);
        addSpanNetworkEvent(span, PerformanceTimingNames.RESPONSE_START, resource);
        addSpanNetworkEvent(span, PerformanceTimingNames.RESPONSE_END, resource);
      }
      var encodedLength = resource[PerformanceTimingNames.ENCODED_BODY_SIZE];
      if (encodedLength !== undefined) {
        span.setAttribute(SEMATTRS_HTTP_RESPONSE_CONTENT_LENGTH, encodedLength);
      }
      var decodedLength = resource[PerformanceTimingNames.DECODED_BODY_SIZE];
      // Spec: Not set if transport encoding not used (in which case encoded and decoded sizes match)
      if (decodedLength !== undefined && encodedLength !== decodedLength) {
        span.setAttribute(SEMATTRS_HTTP_RESPONSE_CONTENT_LENGTH_UNCOMPRESSED, decodedLength);
      }
    }
    /**
     * sort resources by startTime
     * @param filteredResources
     */
    function sortResources(filteredResources) {
      return filteredResources.slice().sort(function (a, b) {
        var valueA = a[PerformanceTimingNames.FETCH_START];
        var valueB = b[PerformanceTimingNames.FETCH_START];
        if (valueA > valueB) {
          return 1;
        } else if (valueA < valueB) {
          return -1;
        }
        return 0;
      });
    }
    /** Returns the origin if present (if in browser context). */
    function getOrigin() {
      return typeof location !== 'undefined' ? location.origin : undefined;
    }
    /**
     * Get closest performance resource ignoring the resources that have been
     * already used.
     * @param spanUrl
     * @param startTimeHR
     * @param endTimeHR
     * @param resources
     * @param ignoredResources
     * @param initiatorType
     */
    function getResource(spanUrl, startTimeHR, endTimeHR, resources, ignoredResources, initiatorType) {
      if (ignoredResources === void 0) {
        ignoredResources = new WeakSet();
      }
      // de-relativize the URL before usage (does no harm to absolute URLs)
      var parsedSpanUrl = parseUrl(spanUrl);
      spanUrl = parsedSpanUrl.toString();
      var filteredResources = filterResourcesForSpan(spanUrl, startTimeHR, endTimeHR, resources, ignoredResources, initiatorType);
      if (filteredResources.length === 0) {
        return {
          mainRequest: undefined
        };
      }
      if (filteredResources.length === 1) {
        return {
          mainRequest: filteredResources[0]
        };
      }
      var sorted = sortResources(filteredResources);
      if (parsedSpanUrl.origin !== getOrigin() && sorted.length > 1) {
        var corsPreFlightRequest = sorted[0];
        var mainRequest = findMainRequest(sorted, corsPreFlightRequest[PerformanceTimingNames.RESPONSE_END], endTimeHR);
        var responseEnd = corsPreFlightRequest[PerformanceTimingNames.RESPONSE_END];
        var fetchStart = mainRequest[PerformanceTimingNames.FETCH_START];
        // no corsPreFlightRequest
        if (fetchStart < responseEnd) {
          mainRequest = corsPreFlightRequest;
          corsPreFlightRequest = undefined;
        }
        return {
          corsPreFlightRequest: corsPreFlightRequest,
          mainRequest: mainRequest
        };
      } else {
        return {
          mainRequest: filteredResources[0]
        };
      }
    }
    /**
     * Will find the main request skipping the cors pre flight requests
     * @param resources
     * @param corsPreFlightRequestEndTime
     * @param spanEndTimeHR
     */
    function findMainRequest(resources, corsPreFlightRequestEndTime, spanEndTimeHR) {
      var spanEndTime = hrTimeToNanoseconds(spanEndTimeHR);
      var minTime = hrTimeToNanoseconds(timeInputToHrTime(corsPreFlightRequestEndTime));
      var mainRequest = resources[1];
      var bestGap;
      var length = resources.length;
      for (var i = 1; i < length; i++) {
        var resource = resources[i];
        var resourceStartTime = hrTimeToNanoseconds(timeInputToHrTime(resource[PerformanceTimingNames.FETCH_START]));
        var resourceEndTime = hrTimeToNanoseconds(timeInputToHrTime(resource[PerformanceTimingNames.RESPONSE_END]));
        var currentGap = spanEndTime - resourceEndTime;
        if (resourceStartTime >= minTime && (!bestGap || currentGap < bestGap)) {
          bestGap = currentGap;
          mainRequest = resource;
        }
      }
      return mainRequest;
    }
    /**
     * Filter all resources that has started and finished according to span start time and end time.
     *     It will return the closest resource to a start time
     * @param spanUrl
     * @param startTimeHR
     * @param endTimeHR
     * @param resources
     * @param ignoredResources
     */
    function filterResourcesForSpan(spanUrl, startTimeHR, endTimeHR, resources, ignoredResources, initiatorType) {
      var startTime = hrTimeToNanoseconds(startTimeHR);
      var endTime = hrTimeToNanoseconds(endTimeHR);
      var filteredResources = resources.filter(function (resource) {
        var resourceStartTime = hrTimeToNanoseconds(timeInputToHrTime(resource[PerformanceTimingNames.FETCH_START]));
        var resourceEndTime = hrTimeToNanoseconds(timeInputToHrTime(resource[PerformanceTimingNames.RESPONSE_END]));
        return resource.initiatorType.toLowerCase() === (initiatorType || 'xmlhttprequest') && resource.name === spanUrl && resourceStartTime >= startTime && resourceEndTime <= endTime;
      });
      if (filteredResources.length > 0) {
        filteredResources = filteredResources.filter(function (resource) {
          return !ignoredResources.has(resource);
        });
      }
      return filteredResources;
    }
    /**
     * Parses url using URL constructor or fallback to anchor element.
     * @param url
     */
    function parseUrl(url) {
      if (typeof URL === 'function') {
        return new URL(url, typeof document !== 'undefined' ? document.baseURI : typeof location !== 'undefined' // Some JS runtimes (e.g. Deno) don't define this
        ? location.href : undefined);
      }
      var element = getUrlNormalizingAnchor();
      element.href = url;
      return element;
    }
    /**
     * Get element XPath
     * @param target - target element
     * @param optimised - when id attribute of element is present the xpath can be
     * simplified to contain id
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/explicit-module-boundary-types
    function getElementXPath(target, optimised) {
      if (target.nodeType === Node.DOCUMENT_NODE) {
        return '/';
      }
      var targetValue = getNodeValue(target, optimised);
      if (optimised && targetValue.indexOf('@id') > 0) {
        return targetValue;
      }
      var xpath = '';
      if (target.parentNode) {
        xpath += getElementXPath(target.parentNode, false);
      }
      xpath += targetValue;
      return xpath;
    }
    /**
     * get node index within the siblings
     * @param target
     */
    function getNodeIndex(target) {
      if (!target.parentNode) {
        return 0;
      }
      var allowedTypes = [target.nodeType];
      if (target.nodeType === Node.CDATA_SECTION_NODE) {
        allowedTypes.push(Node.TEXT_NODE);
      }
      var elements = Array.from(target.parentNode.childNodes);
      elements = elements.filter(function (element) {
        var localName = element.localName;
        return allowedTypes.indexOf(element.nodeType) >= 0 && localName === target.localName;
      });
      if (elements.length >= 1) {
        return elements.indexOf(target) + 1; // xpath starts from 1
      }
      // if there are no other similar child xpath doesn't need index
      return 0;
    }
    /**
     * get node value for xpath
     * @param target
     * @param optimised
     */
    function getNodeValue(target, optimised) {
      var nodeType = target.nodeType;
      var index = getNodeIndex(target);
      var nodeValue = '';
      if (nodeType === Node.ELEMENT_NODE) {
        var id = target.getAttribute('id');
        if (optimised && id) {
          return "//*[@id=\"" + id + "\"]";
        }
        nodeValue = target.localName;
      } else if (nodeType === Node.TEXT_NODE || nodeType === Node.CDATA_SECTION_NODE) {
        nodeValue = 'text()';
      } else if (nodeType === Node.COMMENT_NODE) {
        nodeValue = 'comment()';
      } else {
        return '';
      }
      // if index is 1 it can be omitted in xpath
      if (nodeValue && index > 1) {
        return "/" + nodeValue + "[" + index + "]";
      }
      return "/" + nodeValue;
    }
    /**
     * Checks if trace headers should be propagated
     * @param spanUrl
     * @private
     */
    function shouldPropagateTraceHeaders(spanUrl, propagateTraceHeaderCorsUrls) {
      var propagateTraceHeaderUrls = propagateTraceHeaderCorsUrls || [];
      if (typeof propagateTraceHeaderUrls === 'string' || propagateTraceHeaderUrls instanceof RegExp) {
        propagateTraceHeaderUrls = [propagateTraceHeaderUrls];
      }
      var parsedSpanUrl = parseUrl(spanUrl);
      if (parsedSpanUrl.origin === getOrigin()) {
        return true;
      } else {
        return propagateTraceHeaderUrls.some(function (propagateTraceHeaderUrl) {
          return urlMatches(spanUrl, propagateTraceHeaderUrl);
        });
      }
    }

    /*
     * Copyright The OpenTelemetry Authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      https://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    var TMP_HTTP_URL$2 = 'http.url';
    var TMP_HTTP_USER_AGENT$2 = 'http.user_agent';
    /**
     * Full HTTP request URL in the form `scheme://host[:port]/path?query[#fragment]`. Usually the fragment is not transmitted over HTTP, but if it is known, it should be included nevertheless.
     *
     * Note: `http.url` MUST NOT contain credentials passed via URL in form of `https://username:password@www.example.com/`. In such case the attribute&#39;s value should be `https://www.example.com/`.
     *
     * @deprecated Use ATTR_HTTP_URL in [incubating entry-point]({@link https://github.com/open-telemetry/opentelemetry-js/blob/main/semantic-conventions/README.md#unstable-semconv}).
     */
    var SEMATTRS_HTTP_URL$2 = TMP_HTTP_URL$2;
    /**
     * Value of the [HTTP User-Agent](https://tools.ietf.org/html/rfc7231#section-5.5.3) header sent by the client.
     *
     * @deprecated Use ATTR_HTTP_USER_AGENT in [incubating entry-point]({@link https://github.com/open-telemetry/opentelemetry-js/blob/main/semantic-conventions/README.md#unstable-semconv}).
     */
    var SEMATTRS_HTTP_USER_AGENT$2 = TMP_HTTP_USER_AGENT$2;

    /*
     * Copyright The OpenTelemetry Authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      https://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    var TMP_SERVICE_NAME = 'service.name';
    /**
     * Logical name of the service.
     *
     * Note: MUST be the same for all instances of horizontally scaled services. If the value was not specified, SDKs MUST fallback to `unknown_service:` concatenated with [`process.executable.name`](process.md#process), e.g. `unknown_service:bash`. If `process.executable.name` is not available, the value MUST be set to `unknown_service`.
     *
     * @deprecated Use ATTR_SERVICE_NAME.
     */
    var SEMRESATTRS_SERVICE_NAME = TMP_SERVICE_NAME;

    /*
     * Copyright The OpenTelemetry Authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      https://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    //----------------------------------------------------------------------------------------------------------
    // DO NOT EDIT, this is an Auto-generated file from scripts/semconv/templates/registry/stable/attributes.ts.j2
    //----------------------------------------------------------------------------------------------------------
    /**
     * ASP.NET Core exception middleware handling result
     *
     * @example handled
     * @example unhandled
     */
    /**
     * The exception message.
     *
     * @example Division by zero
     * @example Can't convert 'int' object to str implicitly
     */
    var ATTR_EXCEPTION_MESSAGE = 'exception.message';
    /**
     * A stacktrace as a string in the natural representation for the language runtime. The representation is to be determined and documented by each language SIG.
     *
     * @example "Exception in thread "main" java.lang.RuntimeException: Test exception\\n at com.example.GenerateTrace.methodB(GenerateTrace.java:13)\\n at com.example.GenerateTrace.methodA(GenerateTrace.java:9)\\n at com.example.GenerateTrace.main(GenerateTrace.java:5)\\n"
     */
    var ATTR_EXCEPTION_STACKTRACE = 'exception.stacktrace';
    /**
     * The type of the exception (its fully-qualified class name, if applicable). The dynamic type of the exception should be preferred over the static type in languages that support it.
     *
     * @example java.net.ConnectException
     * @example OSError
     */
    var ATTR_EXCEPTION_TYPE = 'exception.type';

    var BROWSER_ATTRIBUTES = {
      PLATFORM: 'browser.platform',
      BRANDS: 'browser.brands',
      MOBILE: 'browser.mobile',
      LANGUAGE: 'browser.language',
      USER_AGENT: 'browser.user_agent'
    };

    /*
     * Copyright The OpenTelemetry Authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      https://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    var __awaiter$4 = undefined && undefined.__awaiter || function (thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function (resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator$4 = undefined && undefined.__generator || function (thisArg, body) {
      var _ = {
          label: 0,
          sent: function () {
            if (t[0] & 1) throw t[1];
            return t[1];
          },
          trys: [],
          ops: []
        },
        f,
        y,
        t,
        g;
      return g = {
        next: verb(0),
        "throw": verb(1),
        "return": verb(2)
      }, typeof Symbol === "function" && (g[Symbol.iterator] = function () {
        return this;
      }), g;
      function verb(n) {
        return function (v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
          if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
          if (y = 0, t) op = [op[0] & 2, t.value];
          switch (op[0]) {
            case 0:
            case 1:
              t = op;
              break;
            case 4:
              _.label++;
              return {
                value: op[1],
                done: false
              };
            case 5:
              _.label++;
              y = op[1];
              op = [0];
              continue;
            case 7:
              op = _.ops.pop();
              _.trys.pop();
              continue;
            default:
              if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                _ = 0;
                continue;
              }
              if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                _.label = op[1];
                break;
              }
              if (op[0] === 6 && _.label < t[1]) {
                _.label = t[1];
                t = op;
                break;
              }
              if (t && _.label < t[2]) {
                _.label = t[2];
                _.ops.push(op);
                break;
              }
              if (t[2]) _.ops.pop();
              _.trys.pop();
              continue;
          }
          op = body.call(thisArg, _);
        } catch (e) {
          op = [6, e];
          y = 0;
        } finally {
          f = t = 0;
        }
        if (op[0] & 5) throw op[1];
        return {
          value: op[0] ? op[1] : void 0,
          done: true
        };
      }
    };
    /**
     * BrowserDetector will be used to detect the resources related to browser.
     */
    var BrowserDetector = /** @class */function () {
      function BrowserDetector() {}
      BrowserDetector.prototype.detect = function (config) {
        return __awaiter$4(this, void 0, void 0, function () {
          var isBrowser, browserResource;
          return __generator$4(this, function (_a) {
            isBrowser = typeof navigator !== 'undefined';
            if (!isBrowser) {
              return [2 /*return*/, Resource.empty()];
            }
            browserResource = getBrowserAttributes();
            return [2 /*return*/, this._getResourceAttributes(browserResource, config)];
          });
        });
      };
      /**
       * Validates browser resource attribute map from browser variables
       *
       * @param browserResource The un-sanitized resource attributes from browser as key/value pairs.
       * @param config: Config
       * @returns The sanitized resource attributes.
       */
      BrowserDetector.prototype._getResourceAttributes = function (browserResource, _config) {
        if (!browserResource[BROWSER_ATTRIBUTES.USER_AGENT] && !browserResource[BROWSER_ATTRIBUTES.PLATFORM]) {
          diag.debug('BrowserDetector failed: Unable to find required browser resources. ');
          return Resource.empty();
        } else {
          return new Resource(browserResource);
        }
      };
      return BrowserDetector;
    }();
    // Add Browser related attributes to resources
    function getBrowserAttributes() {
      var browserAttribs = {};
      var userAgentData = navigator.userAgentData;
      if (userAgentData) {
        browserAttribs[BROWSER_ATTRIBUTES.PLATFORM] = userAgentData.platform;
        browserAttribs[BROWSER_ATTRIBUTES.BRANDS] = userAgentData.brands.map(function (b) {
          return b.brand + " " + b.version;
        });
        browserAttribs[BROWSER_ATTRIBUTES.MOBILE] = userAgentData.mobile;
      } else {
        browserAttribs[BROWSER_ATTRIBUTES.USER_AGENT] = navigator.userAgent;
      }
      browserAttribs[BROWSER_ATTRIBUTES.LANGUAGE] = navigator.language;
      return browserAttribs;
    }
    var browserDetector = new BrowserDetector();

    const VERSION$2 = '0.13.0';
    const INSTRUMENTATION_NAME = '@honeycombio/user-instrumentation';
    const DEFAULT_EVENT_NAMES$1 = ['click'];
    let UserInteractionInstrumentation$1 = class UserInteractionInstrumentation extends InstrumentationBase {
      constructor(config = {}) {
        var _a, _b;
        super(INSTRUMENTATION_NAME, VERSION$2, config);
        this._config = config;
        this._isEnabled = (_a = this._config.enabled) !== null && _a !== void 0 ? _a : false;
        // enable() gets called by our superclass constructor
        // @ts-expect-error this may get set in enable()
        this._listeners = (_b = this._listeners) !== null && _b !== void 0 ? _b : [];
      }
      init() {}
      static handleEndSpan(ev) {
        var _a;
        (_a = UserInteractionInstrumentation._eventMap.get(ev)) === null || _a === void 0 ? void 0 : _a.end();
      }
      static createGlobalEventListener(eventName, rootNodeId, isInstrumentationEnabled) {
        return event => {
          const element = event.target;
          if (isInstrumentationEnabled() === false) return;
          if (UserInteractionInstrumentation._eventMap.has(event)) return;
          if (!shouldCreateSpan(event, element, eventName, rootNodeId)) return;
          const xpath = getElementXPath(element);
          const tracer = trace.getTracer(INSTRUMENTATION_NAME);
          context.with(context.active(), () => {
            tracer.startActiveSpan(eventName, {
              attributes: {
                event_type: eventName,
                target_element: element.tagName,
                target_xpath: xpath,
                'http.url': window.location.href
              }
            }, span => {
              // if user space code calls stopPropagation, we'll never see it again
              // so let's monkey patch those funcs to end the span if they do kill it
              wrapEventPropagationCb(event, 'stopPropagation', span);
              wrapEventPropagationCb(event, 'stopImmediatePropagation', span);
              UserInteractionInstrumentation._eventMap.set(event, span);
            });
          });
        };
      }
      enable() {
        var _a;
        if (this._isEnabled) {
          return;
        }
        const rootNode = this.getRootNode();
        // enable() gets called by our superclass constructor
        // meaning our private fields aren't initialized yet!!
        this._listeners = [];
        //
        const eventNames = (_a = this._config.eventNames) !== null && _a !== void 0 ? _a : DEFAULT_EVENT_NAMES$1;
        eventNames.forEach(eventName => {
          // we need a stable reference to this handler so that we can remove it later
          const handler = UserInteractionInstrumentation.createGlobalEventListener(eventName, this._config.rootNodeId, () => this._isEnabled);
          this._listeners.push({
            eventName,
            handler
          });
          // capture phase listener to kick in before any other listeners
          rootNode.addEventListener(eventName, handler, {
            capture: true
          });
          // bubble phase listener gets called at the end, if user space doesn't call e.stopPropagation()
          rootNode.addEventListener(eventName, UserInteractionInstrumentation.handleEndSpan);
        });
        this._isEnabled = true;
      }
      getRootNode() {
        if (this._config.rootNodeId) {
          const rootNode = document.getElementById(this._config.rootNodeId);
          if (rootNode === null) {
            this._diag.warn(`Root Node id: ${this._config.rootNodeId} not found!`);
            return document;
          }
          return rootNode;
        }
        return document;
      }
      disable() {
        this._isEnabled = false;
        this._listeners.forEach(({
          eventName,
          handler
        }) => {
          document.removeEventListener(eventName, handler, {
            capture: true
          });
          document.removeEventListener(eventName, UserInteractionInstrumentation.handleEndSpan);
        });
        this._listeners = [];
      }
    };
    UserInteractionInstrumentation$1._eventMap = new WeakMap();
    const shouldCreateSpan = (event, element, eventName, rootNodeId) => {
      if (!(element instanceof HTMLElement)) {
        return false;
      }
      const handlerName = `on${eventName}`;
      if (!elementHasEventHandler(element, handlerName, rootNodeId)) {
        return false;
      }
      if (!element.getAttribute) {
        return false;
      }
      if (element.hasAttribute('disabled')) {
        return false;
      }
      return true;
    };
    /**
     * Detects if this event on this element is useful
     *    by checking if this element or any of its parents have handlers
     *    for this event.
     *
     * Accounts for the fact that frameworks like React will put dummy/noop
     *    handlers at their root, and ignores those.
     */
    const elementHasEventHandler = (element, eventName, rootNodeId) => {
      if (!element || !!rootNodeId && element.id === rootNodeId) {
        return false;
      }
      if (element[eventName]) {
        return true;
      }
      return elementHasEventHandler(element.parentElement, eventName, rootNodeId);
    };
    const wrapEventPropagationCb = (event, key, span) => {
      const oldCb = event[key].bind(event);
      event[key] = () => {
        span.end();
        oldCb();
      };
    };

    var uaParser$1 = {exports: {}};

    var uaParser = uaParser$1.exports;
    var hasRequiredUaParser;
    function requireUaParser() {
      if (hasRequiredUaParser) return uaParser$1.exports;
      hasRequiredUaParser = 1;
      (function (module, exports) {
        /////////////////////////////////////////////////////////////////////////////////
        /* UAParser.js v1.0.40
           Copyright  2012-2024 Faisal Salman <f@faisalman.com>
           MIT License */ /*
                          Detect Browser, Engine, OS, CPU, and Device type/model from User-Agent data.
                          Supports browser & node.js environment. 
                          Demo   : https://faisalman.github.io/ua-parser-js
                          Source : https://github.com/faisalman/ua-parser-js */
        /////////////////////////////////////////////////////////////////////////////////

        (function (window, undefined$1) {

          //////////////
          // Constants
          /////////////
          var LIBVERSION = '1.0.40',
            EMPTY = '',
            UNKNOWN = '?',
            FUNC_TYPE = 'function',
            UNDEF_TYPE = 'undefined',
            OBJ_TYPE = 'object',
            STR_TYPE = 'string',
            MAJOR = 'major',
            MODEL = 'model',
            NAME = 'name',
            TYPE = 'type',
            VENDOR = 'vendor',
            VERSION = 'version',
            ARCHITECTURE = 'architecture',
            CONSOLE = 'console',
            MOBILE = 'mobile',
            TABLET = 'tablet',
            SMARTTV = 'smarttv',
            WEARABLE = 'wearable',
            EMBEDDED = 'embedded',
            UA_MAX_LENGTH = 500;
          var AMAZON = 'Amazon',
            APPLE = 'Apple',
            ASUS = 'ASUS',
            BLACKBERRY = 'BlackBerry',
            BROWSER = 'Browser',
            CHROME = 'Chrome',
            EDGE = 'Edge',
            FIREFOX = 'Firefox',
            GOOGLE = 'Google',
            HUAWEI = 'Huawei',
            LG = 'LG',
            MICROSOFT = 'Microsoft',
            MOTOROLA = 'Motorola',
            OPERA = 'Opera',
            SAMSUNG = 'Samsung',
            SHARP = 'Sharp',
            SONY = 'Sony',
            XIAOMI = 'Xiaomi',
            ZEBRA = 'Zebra',
            FACEBOOK = 'Facebook',
            CHROMIUM_OS = 'Chromium OS',
            MAC_OS = 'Mac OS',
            SUFFIX_BROWSER = ' Browser';

          ///////////
          // Helper
          //////////

          var extend = function (regexes, extensions) {
              var mergedRegexes = {};
              for (var i in regexes) {
                if (extensions[i] && extensions[i].length % 2 === 0) {
                  mergedRegexes[i] = extensions[i].concat(regexes[i]);
                } else {
                  mergedRegexes[i] = regexes[i];
                }
              }
              return mergedRegexes;
            },
            enumerize = function (arr) {
              var enums = {};
              for (var i = 0; i < arr.length; i++) {
                enums[arr[i].toUpperCase()] = arr[i];
              }
              return enums;
            },
            has = function (str1, str2) {
              return typeof str1 === STR_TYPE ? lowerize(str2).indexOf(lowerize(str1)) !== -1 : false;
            },
            lowerize = function (str) {
              return str.toLowerCase();
            },
            majorize = function (version) {
              return typeof version === STR_TYPE ? version.replace(/[^\d\.]/g, EMPTY).split('.')[0] : undefined$1;
            },
            trim = function (str, len) {
              if (typeof str === STR_TYPE) {
                str = str.replace(/^\s\s*/, EMPTY);
                return typeof len === UNDEF_TYPE ? str : str.substring(0, UA_MAX_LENGTH);
              }
            };

          ///////////////
          // Map helper
          //////////////

          var rgxMapper = function (ua, arrays) {
              var i = 0,
                j,
                k,
                p,
                q,
                matches,
                match;

              // loop through all regexes maps
              while (i < arrays.length && !matches) {
                var regex = arrays[i],
                  // even sequence (0,2,4,..)
                  props = arrays[i + 1]; // odd sequence (1,3,5,..)
                j = k = 0;

                // try matching uastring with regexes
                while (j < regex.length && !matches) {
                  if (!regex[j]) {
                    break;
                  }
                  matches = regex[j++].exec(ua);
                  if (!!matches) {
                    for (p = 0; p < props.length; p++) {
                      match = matches[++k];
                      q = props[p];
                      // check if given property is actually array
                      if (typeof q === OBJ_TYPE && q.length > 0) {
                        if (q.length === 2) {
                          if (typeof q[1] == FUNC_TYPE) {
                            // assign modified match
                            this[q[0]] = q[1].call(this, match);
                          } else {
                            // assign given value, ignore regex match
                            this[q[0]] = q[1];
                          }
                        } else if (q.length === 3) {
                          // check whether function or regex
                          if (typeof q[1] === FUNC_TYPE && !(q[1].exec && q[1].test)) {
                            // call function (usually string mapper)
                            this[q[0]] = match ? q[1].call(this, match, q[2]) : undefined$1;
                          } else {
                            // sanitize match using given regex
                            this[q[0]] = match ? match.replace(q[1], q[2]) : undefined$1;
                          }
                        } else if (q.length === 4) {
                          this[q[0]] = match ? q[3].call(this, match.replace(q[1], q[2])) : undefined$1;
                        }
                      } else {
                        this[q] = match ? match : undefined$1;
                      }
                    }
                  }
                }
                i += 2;
              }
            },
            strMapper = function (str, map) {
              for (var i in map) {
                // check if current value is array
                if (typeof map[i] === OBJ_TYPE && map[i].length > 0) {
                  for (var j = 0; j < map[i].length; j++) {
                    if (has(map[i][j], str)) {
                      return i === UNKNOWN ? undefined$1 : i;
                    }
                  }
                } else if (has(map[i], str)) {
                  return i === UNKNOWN ? undefined$1 : i;
                }
              }
              return map.hasOwnProperty('*') ? map['*'] : str;
            };

          ///////////////
          // String map
          //////////////

          // Safari < 3.0
          var oldSafariMap = {
              '1.0': '/8',
              '1.2': '/1',
              '1.3': '/3',
              '2.0': '/412',
              '2.0.2': '/416',
              '2.0.3': '/417',
              '2.0.4': '/419',
              '?': '/'
            },
            windowsVersionMap = {
              'ME': '4.90',
              'NT 3.11': 'NT3.51',
              'NT 4.0': 'NT4.0',
              '2000': 'NT 5.0',
              'XP': ['NT 5.1', 'NT 5.2'],
              'Vista': 'NT 6.0',
              '7': 'NT 6.1',
              '8': 'NT 6.2',
              '8.1': 'NT 6.3',
              '10': ['NT 6.4', 'NT 10.0'],
              'RT': 'ARM'
            };

          //////////////
          // Regex map
          /////////////

          var regexes = {
            browser: [[/\b(?:crmo|crios)\/([\w\.]+)/i // Chrome for Android/iOS
            ], [VERSION, [NAME, 'Chrome']], [/edg(?:e|ios|a)?\/([\w\.]+)/i // Microsoft Edge
            ], [VERSION, [NAME, 'Edge']], [
            // Presto based
            /(opera mini)\/([-\w\.]+)/i,
            // Opera Mini
            /(opera [mobiletab]{3,6})\b.+version\/([-\w\.]+)/i,
            // Opera Mobi/Tablet
            /(opera)(?:.+version\/|[\/ ]+)([\w\.]+)/i // Opera
            ], [NAME, VERSION], [/opios[\/ ]+([\w\.]+)/i // Opera mini on iphone >= 8.0
            ], [VERSION, [NAME, OPERA + ' Mini']], [/\bop(?:rg)?x\/([\w\.]+)/i // Opera GX
            ], [VERSION, [NAME, OPERA + ' GX']], [/\bopr\/([\w\.]+)/i // Opera Webkit
            ], [VERSION, [NAME, OPERA]], [
            // Mixed
            /\bb[ai]*d(?:uhd|[ub]*[aekoprswx]{5,6})[\/ ]?([\w\.]+)/i // Baidu
            ], [VERSION, [NAME, 'Baidu']], [/\b(?:mxbrowser|mxios|myie2)\/?([-\w\.]*)\b/i // Maxthon
            ], [VERSION, [NAME, 'Maxthon']], [/(kindle)\/([\w\.]+)/i,
            // Kindle
            /(lunascape|maxthon|netfront|jasmine|blazer|sleipnir)[\/ ]?([\w\.]*)/i,
            // Lunascape/Maxthon/Netfront/Jasmine/Blazer/Sleipnir
            // Trident based
            /(avant|iemobile|slim(?:browser|boat|jet))[\/ ]?([\d\.]*)/i,
            // Avant/IEMobile/SlimBrowser/SlimBoat/Slimjet
            /(?:ms|\()(ie) ([\w\.]+)/i,
            // Internet Explorer

            // Blink/Webkit/KHTML based                                         // Flock/RockMelt/Midori/Epiphany/Silk/Skyfire/Bolt/Iron/Iridium/PhantomJS/Bowser/QupZilla/Falkon
            /(flock|rockmelt|midori|epiphany|silk|skyfire|ovibrowser|bolt|iron|vivaldi|iridium|phantomjs|bowser|qupzilla|falkon|rekonq|puffin|brave|whale(?!.+naver)|qqbrowserlite|duckduckgo|klar|helio|(?=comodo_)?dragon)\/([-\w\.]+)/i,
            // Rekonq/Puffin/Brave/Whale/QQBrowserLite/QQ//Vivaldi/DuckDuckGo/Klar/Helio/Dragon
            /(heytap|ovi|115)browser\/([\d\.]+)/i,
            // HeyTap/Ovi/115
            /(weibo)__([\d\.]+)/i // Weibo
            ], [NAME, VERSION], [/quark(?:pc)?\/([-\w\.]+)/i // Quark
            ], [VERSION, [NAME, 'Quark']], [/\bddg\/([\w\.]+)/i // DuckDuckGo
            ], [VERSION, [NAME, 'DuckDuckGo']], [/(?:\buc? ?browser|(?:juc.+)ucweb)[\/ ]?([\w\.]+)/i // UCBrowser
            ], [VERSION, [NAME, 'UC' + BROWSER]], [/microm.+\bqbcore\/([\w\.]+)/i,
            // WeChat Desktop for Windows Built-in Browser
            /\bqbcore\/([\w\.]+).+microm/i, /micromessenger\/([\w\.]+)/i // WeChat
            ], [VERSION, [NAME, 'WeChat']], [/konqueror\/([\w\.]+)/i // Konqueror
            ], [VERSION, [NAME, 'Konqueror']], [/trident.+rv[: ]([\w\.]{1,9})\b.+like gecko/i // IE11
            ], [VERSION, [NAME, 'IE']], [/ya(?:search)?browser\/([\w\.]+)/i // Yandex
            ], [VERSION, [NAME, 'Yandex']], [/slbrowser\/([\w\.]+)/i // Smart Lenovo Browser
            ], [VERSION, [NAME, 'Smart Lenovo ' + BROWSER]], [/(avast|avg)\/([\w\.]+)/i // Avast/AVG Secure Browser
            ], [[NAME, /(.+)/, '$1 Secure ' + BROWSER], VERSION], [/\bfocus\/([\w\.]+)/i // Firefox Focus
            ], [VERSION, [NAME, FIREFOX + ' Focus']], [/\bopt\/([\w\.]+)/i // Opera Touch
            ], [VERSION, [NAME, OPERA + ' Touch']], [/coc_coc\w+\/([\w\.]+)/i // Coc Coc Browser
            ], [VERSION, [NAME, 'Coc Coc']], [/dolfin\/([\w\.]+)/i // Dolphin
            ], [VERSION, [NAME, 'Dolphin']], [/coast\/([\w\.]+)/i // Opera Coast
            ], [VERSION, [NAME, OPERA + ' Coast']], [/miuibrowser\/([\w\.]+)/i // MIUI Browser
            ], [VERSION, [NAME, 'MIUI' + SUFFIX_BROWSER]], [/fxios\/([\w\.-]+)/i // Firefox for iOS
            ], [VERSION, [NAME, FIREFOX]], [/\bqihoobrowser\/?([\w\.]*)/i // 360
            ], [VERSION, [NAME, '360']], [/\b(qq)\/([\w\.]+)/i // QQ
            ], [[NAME, /(.+)/, '$1Browser'], VERSION], [/(oculus|sailfish|huawei|vivo|pico)browser\/([\w\.]+)/i], [[NAME, /(.+)/, '$1' + SUFFIX_BROWSER], VERSION], [
            // Oculus/Sailfish/HuaweiBrowser/VivoBrowser/PicoBrowser
            /samsungbrowser\/([\w\.]+)/i // Samsung Internet
            ], [VERSION, [NAME, SAMSUNG + ' Internet']], [/metasr[\/ ]?([\d\.]+)/i // Sogou Explorer
            ], [VERSION, [NAME, 'Sogou Explorer']], [/(sogou)mo\w+\/([\d\.]+)/i // Sogou Mobile
            ], [[NAME, 'Sogou Mobile'], VERSION], [/(electron)\/([\w\.]+) safari/i,
            // Electron-based App
            /(tesla)(?: qtcarbrowser|\/(20\d\d\.[-\w\.]+))/i,
            // Tesla
            /m?(qqbrowser|2345(?=browser|chrome|explorer))\w*[\/ ]?v?([\w\.]+)/i // QQ/2345
            ], [NAME, VERSION], [/(lbbrowser|rekonq)/i,
            // LieBao Browser/Rekonq
            /\[(linkedin)app\]/i // LinkedIn App for iOS & Android
            ], [NAME], [/ome\/([\w\.]+) \w* ?(iron) saf/i,
            // Iron
            /ome\/([\w\.]+).+qihu (360)[es]e/i // 360
            ], [VERSION, NAME], [
            // WebView
            /((?:fban\/fbios|fb_iab\/fb4a)(?!.+fbav)|;fbav\/([\w\.]+);)/i // Facebook App for iOS & Android
            ], [[NAME, FACEBOOK], VERSION], [/(Klarna)\/([\w\.]+)/i,
            // Klarna Shopping Browser for iOS & Android
            /(kakao(?:talk|story))[\/ ]([\w\.]+)/i,
            // Kakao App
            /(naver)\(.*?(\d+\.[\w\.]+).*\)/i,
            // Naver InApp
            /safari (line)\/([\w\.]+)/i,
            // Line App for iOS
            /\b(line)\/([\w\.]+)\/iab/i,
            // Line App for Android
            /(alipay)client\/([\w\.]+)/i,
            // Alipay
            /(twitter)(?:and| f.+e\/([\w\.]+))/i,
            // Twitter
            /(chromium|instagram|snapchat)[\/ ]([-\w\.]+)/i // Chromium/Instagram/Snapchat
            ], [NAME, VERSION], [/\bgsa\/([\w\.]+) .*safari\//i // Google Search Appliance on iOS
            ], [VERSION, [NAME, 'GSA']], [/musical_ly(?:.+app_?version\/|_)([\w\.]+)/i // TikTok
            ], [VERSION, [NAME, 'TikTok']], [/headlesschrome(?:\/([\w\.]+)| )/i // Chrome Headless
            ], [VERSION, [NAME, CHROME + ' Headless']], [/ wv\).+(chrome)\/([\w\.]+)/i // Chrome WebView
            ], [[NAME, CHROME + ' WebView'], VERSION], [/droid.+ version\/([\w\.]+)\b.+(?:mobile safari|safari)/i // Android Browser
            ], [VERSION, [NAME, 'Android ' + BROWSER]], [/(chrome|omniweb|arora|[tizenoka]{5} ?browser)\/v?([\w\.]+)/i // Chrome/OmniWeb/Arora/Tizen/Nokia
            ], [NAME, VERSION], [/version\/([\w\.\,]+) .*mobile\/\w+ (safari)/i // Mobile Safari
            ], [VERSION, [NAME, 'Mobile Safari']], [/version\/([\w(\.|\,)]+) .*(mobile ?safari|safari)/i // Safari & Safari Mobile
            ], [VERSION, NAME], [/webkit.+?(mobile ?safari|safari)(\/[\w\.]+)/i // Safari < 3.0
            ], [NAME, [VERSION, strMapper, oldSafariMap]], [/(webkit|khtml)\/([\w\.]+)/i], [NAME, VERSION], [
            // Gecko based
            /(navigator|netscape\d?)\/([-\w\.]+)/i // Netscape
            ], [[NAME, 'Netscape'], VERSION], [/(wolvic|librewolf)\/([\w\.]+)/i // Wolvic/LibreWolf
            ], [NAME, VERSION], [/mobile vr; rv:([\w\.]+)\).+firefox/i // Firefox Reality
            ], [VERSION, [NAME, FIREFOX + ' Reality']], [/ekiohf.+(flow)\/([\w\.]+)/i,
            // Flow
            /(swiftfox)/i,
            // Swiftfox
            /(icedragon|iceweasel|camino|chimera|fennec|maemo browser|minimo|conkeror)[\/ ]?([\w\.\+]+)/i,
            // IceDragon/Iceweasel/Camino/Chimera/Fennec/Maemo/Minimo/Conkeror
            /(seamonkey|k-meleon|icecat|iceape|firebird|phoenix|palemoon|basilisk|waterfox)\/([-\w\.]+)$/i,
            // Firefox/SeaMonkey/K-Meleon/IceCat/IceApe/Firebird/Phoenix
            /(firefox)\/([\w\.]+)/i,
            // Other Firefox-based
            /(mozilla)\/([\w\.]+) .+rv\:.+gecko\/\d+/i,
            // Mozilla

            // Other
            /(polaris|lynx|dillo|icab|doris|amaya|w3m|netsurf|obigo|mosaic|(?:go|ice|up)[\. ]?browser)[-\/ ]?v?([\w\.]+)/i,
            // Polaris/Lynx/Dillo/iCab/Doris/Amaya/w3m/NetSurf/Obigo/Mosaic/Go/ICE/UP.Browser
            /(links) \(([\w\.]+)/i // Links
            ], [NAME, [VERSION, /_/g, '.']], [/(cobalt)\/([\w\.]+)/i // Cobalt
            ], [NAME, [VERSION, /master.|lts./, ""]]],
            cpu: [[/(?:(amd|x(?:(?:86|64)[-_])?|wow|win)64)[;\)]/i // AMD64 (x64)
            ], [[ARCHITECTURE, 'amd64']], [/(ia32(?=;))/i // IA32 (quicktime)
            ], [[ARCHITECTURE, lowerize]], [/((?:i[346]|x)86)[;\)]/i // IA32 (x86)
            ], [[ARCHITECTURE, 'ia32']], [/\b(aarch64|arm(v?8e?l?|_?64))\b/i // ARM64
            ], [[ARCHITECTURE, 'arm64']], [/\b(arm(?:v[67])?ht?n?[fl]p?)\b/i // ARMHF
            ], [[ARCHITECTURE, 'armhf']], [
            // PocketPC mistakenly identified as PowerPC
            /windows (ce|mobile); ppc;/i], [[ARCHITECTURE, 'arm']], [/((?:ppc|powerpc)(?:64)?)(?: mac|;|\))/i // PowerPC
            ], [[ARCHITECTURE, /ower/, EMPTY, lowerize]], [/(sun4\w)[;\)]/i // SPARC
            ], [[ARCHITECTURE, 'sparc']], [/((?:avr32|ia64(?=;))|68k(?=\))|\barm(?=v(?:[1-7]|[5-7]1)l?|;|eabi)|(?=atmel )avr|(?:irix|mips|sparc)(?:64)?\b|pa-risc)/i
            // IA64, 68K, ARM/64, AVR/32, IRIX/64, MIPS/64, SPARC/64, PA-RISC
            ], [[ARCHITECTURE, lowerize]]],
            device: [[
            //////////////////////////
            // MOBILES & TABLETS
            /////////////////////////

            // Samsung
            /\b(sch-i[89]0\d|shw-m380s|sm-[ptx]\w{2,4}|gt-[pn]\d{2,4}|sgh-t8[56]9|nexus 10)/i], [MODEL, [VENDOR, SAMSUNG], [TYPE, TABLET]], [/\b((?:s[cgp]h|gt|sm)-(?![lr])\w+|sc[g-]?[\d]+a?|galaxy nexus)/i, /samsung[- ]((?!sm-[lr])[-\w]+)/i, /sec-(sgh\w+)/i], [MODEL, [VENDOR, SAMSUNG], [TYPE, MOBILE]], [
            // Apple
            /(?:\/|\()(ip(?:hone|od)[\w, ]*)(?:\/|;)/i // iPod/iPhone
            ], [MODEL, [VENDOR, APPLE], [TYPE, MOBILE]], [/\((ipad);[-\w\),; ]+apple/i,
            // iPad
            /applecoremedia\/[\w\.]+ \((ipad)/i, /\b(ipad)\d\d?,\d\d?[;\]].+ios/i], [MODEL, [VENDOR, APPLE], [TYPE, TABLET]], [/(macintosh);/i], [MODEL, [VENDOR, APPLE]], [
            // Sharp
            /\b(sh-?[altvz]?\d\d[a-ekm]?)/i], [MODEL, [VENDOR, SHARP], [TYPE, MOBILE]], [
            // Honor
            /(?:honor)([-\w ]+)[;\)]/i], [MODEL, [VENDOR, 'Honor'], [TYPE, MOBILE]], [
            // Huawei
            /\b((?:ag[rs][23]?|bah2?|sht?|btv)-a?[lw]\d{2})\b(?!.+d\/s)/i], [MODEL, [VENDOR, HUAWEI], [TYPE, TABLET]], [/(?:huawei)([-\w ]+)[;\)]/i, /\b(nexus 6p|\w{2,4}e?-[atu]?[ln][\dx][012359c][adn]?)\b(?!.+d\/s)/i], [MODEL, [VENDOR, HUAWEI], [TYPE, MOBILE]], [
            // Xiaomi
            /\b(poco[\w ]+|m2\d{3}j\d\d[a-z]{2})(?: bui|\))/i,
            // Xiaomi POCO
            /\b; (\w+) build\/hm\1/i,
            // Xiaomi Hongmi 'numeric' models
            /\b(hm[-_ ]?note?[_ ]?(?:\d\w)?) bui/i,
            // Xiaomi Hongmi
            /\b(redmi[\-_ ]?(?:note|k)?[\w_ ]+)(?: bui|\))/i,
            // Xiaomi Redmi
            /oid[^\)]+; (m?[12][0-389][01]\w{3,6}[c-y])( bui|; wv|\))/i,
            // Xiaomi Redmi 'numeric' models
            /\b(mi[-_ ]?(?:a\d|one|one[_ ]plus|note lte|max|cc)?[_ ]?(?:\d?\w?)[_ ]?(?:plus|se|lite|pro)?)(?: bui|\))/i // Xiaomi Mi
            ], [[MODEL, /_/g, ' '], [VENDOR, XIAOMI], [TYPE, MOBILE]], [/oid[^\)]+; (2\d{4}(283|rpbf)[cgl])( bui|\))/i,
            // Redmi Pad
            /\b(mi[-_ ]?(?:pad)(?:[\w_ ]+))(?: bui|\))/i // Mi Pad tablets
            ], [[MODEL, /_/g, ' '], [VENDOR, XIAOMI], [TYPE, TABLET]], [
            // OPPO
            /; (\w+) bui.+ oppo/i, /\b(cph[12]\d{3}|p(?:af|c[al]|d\w|e[ar])[mt]\d0|x9007|a101op)\b/i], [MODEL, [VENDOR, 'OPPO'], [TYPE, MOBILE]], [/\b(opd2\d{3}a?) bui/i], [MODEL, [VENDOR, 'OPPO'], [TYPE, TABLET]], [
            // Vivo
            /vivo (\w+)(?: bui|\))/i, /\b(v[12]\d{3}\w?[at])(?: bui|;)/i], [MODEL, [VENDOR, 'Vivo'], [TYPE, MOBILE]], [
            // Realme
            /\b(rmx[1-3]\d{3})(?: bui|;|\))/i], [MODEL, [VENDOR, 'Realme'], [TYPE, MOBILE]], [
            // Motorola
            /\b(milestone|droid(?:[2-4x]| (?:bionic|x2|pro|razr))?:?( 4g)?)\b[\w ]+build\//i, /\bmot(?:orola)?[- ](\w*)/i, /((?:moto[\w\(\) ]+|xt\d{3,4}|nexus 6)(?= bui|\)))/i], [MODEL, [VENDOR, MOTOROLA], [TYPE, MOBILE]], [/\b(mz60\d|xoom[2 ]{0,2}) build\//i], [MODEL, [VENDOR, MOTOROLA], [TYPE, TABLET]], [
            // LG
            /((?=lg)?[vl]k\-?\d{3}) bui| 3\.[-\w; ]{10}lg?-([06cv9]{3,4})/i], [MODEL, [VENDOR, LG], [TYPE, TABLET]], [/(lm(?:-?f100[nv]?|-[\w\.]+)(?= bui|\))|nexus [45])/i, /\blg[-e;\/ ]+((?!browser|netcast|android tv)\w+)/i, /\blg-?([\d\w]+) bui/i], [MODEL, [VENDOR, LG], [TYPE, MOBILE]], [
            // Lenovo
            /(ideatab[-\w ]+)/i, /lenovo ?(s[56]000[-\w]+|tab(?:[\w ]+)|yt[-\d\w]{6}|tb[-\d\w]{6})/i], [MODEL, [VENDOR, 'Lenovo'], [TYPE, TABLET]], [
            // Nokia
            /(?:maemo|nokia).*(n900|lumia \d+)/i, /nokia[-_ ]?([-\w\.]*)/i], [[MODEL, /_/g, ' '], [VENDOR, 'Nokia'], [TYPE, MOBILE]], [
            // Google
            /(pixel c)\b/i // Google Pixel C
            ], [MODEL, [VENDOR, GOOGLE], [TYPE, TABLET]], [/droid.+; (pixel[\daxl ]{0,6})(?: bui|\))/i // Google Pixel
            ], [MODEL, [VENDOR, GOOGLE], [TYPE, MOBILE]], [
            // Sony
            /droid.+; (a?\d[0-2]{2}so|[c-g]\d{4}|so[-gl]\w+|xq-a\w[4-7][12])(?= bui|\).+chrome\/(?![1-6]{0,1}\d\.))/i], [MODEL, [VENDOR, SONY], [TYPE, MOBILE]], [/sony tablet [ps]/i, /\b(?:sony)?sgp\w+(?: bui|\))/i], [[MODEL, 'Xperia Tablet'], [VENDOR, SONY], [TYPE, TABLET]], [
            // OnePlus
            / (kb2005|in20[12]5|be20[12][59])\b/i, /(?:one)?(?:plus)? (a\d0\d\d)(?: b|\))/i], [MODEL, [VENDOR, 'OnePlus'], [TYPE, MOBILE]], [
            // Amazon
            /(alexa)webm/i, /(kf[a-z]{2}wi|aeo(?!bc)\w\w)( bui|\))/i,
            // Kindle Fire without Silk / Echo Show
            /(kf[a-z]+)( bui|\)).+silk\//i // Kindle Fire HD
            ], [MODEL, [VENDOR, AMAZON], [TYPE, TABLET]], [/((?:sd|kf)[0349hijorstuw]+)( bui|\)).+silk\//i // Fire Phone
            ], [[MODEL, /(.+)/g, 'Fire Phone $1'], [VENDOR, AMAZON], [TYPE, MOBILE]], [
            // BlackBerry
            /(playbook);[-\w\),; ]+(rim)/i // BlackBerry PlayBook
            ], [MODEL, VENDOR, [TYPE, TABLET]], [/\b((?:bb[a-f]|st[hv])100-\d)/i, /\(bb10; (\w+)/i // BlackBerry 10
            ], [MODEL, [VENDOR, BLACKBERRY], [TYPE, MOBILE]], [
            // Asus
            /(?:\b|asus_)(transfo[prime ]{4,10} \w+|eeepc|slider \w+|nexus 7|padfone|p00[cj])/i], [MODEL, [VENDOR, ASUS], [TYPE, TABLET]], [/ (z[bes]6[027][012][km][ls]|zenfone \d\w?)\b/i], [MODEL, [VENDOR, ASUS], [TYPE, MOBILE]], [
            // HTC
            /(nexus 9)/i // HTC Nexus 9
            ], [MODEL, [VENDOR, 'HTC'], [TYPE, TABLET]], [/(htc)[-;_ ]{1,2}([\w ]+(?=\)| bui)|\w+)/i,
            // HTC

            // ZTE
            /(zte)[- ]([\w ]+?)(?: bui|\/|\))/i, /(alcatel|geeksphone|nexian|panasonic(?!(?:;|\.))|sony(?!-bra))[-_ ]?([-\w]*)/i // Alcatel/GeeksPhone/Nexian/Panasonic/Sony
            ], [VENDOR, [MODEL, /_/g, ' '], [TYPE, MOBILE]], [
            // TCL
            /droid [\w\.]+; ((?:8[14]9[16]|9(?:0(?:48|60|8[01])|1(?:3[27]|66)|2(?:6[69]|9[56])|466))[gqswx])\w*(\)| bui)/i], [MODEL, [VENDOR, 'TCL'], [TYPE, TABLET]], [
            // itel
            /(itel) ((\w+))/i], [[VENDOR, lowerize], MODEL, [TYPE, strMapper, {
              'tablet': ['p10001l', 'w7001'],
              '*': 'mobile'
            }]], [
            // Acer
            /droid.+; ([ab][1-7]-?[0178a]\d\d?)/i], [MODEL, [VENDOR, 'Acer'], [TYPE, TABLET]], [
            // Meizu
            /droid.+; (m[1-5] note) bui/i, /\bmz-([-\w]{2,})/i], [MODEL, [VENDOR, 'Meizu'], [TYPE, MOBILE]], [
            // Ulefone
            /; ((?:power )?armor(?:[\w ]{0,8}))(?: bui|\))/i], [MODEL, [VENDOR, 'Ulefone'], [TYPE, MOBILE]], [
            // Energizer
            /; (energy ?\w+)(?: bui|\))/i, /; energizer ([\w ]+)(?: bui|\))/i], [MODEL, [VENDOR, 'Energizer'], [TYPE, MOBILE]], [
            // Cat
            /; cat (b35);/i, /; (b15q?|s22 flip|s48c|s62 pro)(?: bui|\))/i], [MODEL, [VENDOR, 'Cat'], [TYPE, MOBILE]], [
            // Smartfren
            /((?:new )?andromax[\w- ]+)(?: bui|\))/i], [MODEL, [VENDOR, 'Smartfren'], [TYPE, MOBILE]], [
            // Nothing
            /droid.+; (a(?:015|06[35]|142p?))/i], [MODEL, [VENDOR, 'Nothing'], [TYPE, MOBILE]], [
            // MIXED
            /(blackberry|benq|palm(?=\-)|sonyericsson|acer|asus|dell|meizu|motorola|polytron|infinix|tecno|micromax|advan)[-_ ]?([-\w]*)/i,
            // BlackBerry/BenQ/Palm/Sony-Ericsson/Acer/Asus/Dell/Meizu/Motorola/Polytron/Infinix/Tecno/Micromax/Advan
            /; (imo) ((?!tab)[\w ]+?)(?: bui|\))/i,
            // IMO
            /(hp) ([\w ]+\w)/i,
            // HP iPAQ
            /(asus)-?(\w+)/i,
            // Asus
            /(microsoft); (lumia[\w ]+)/i,
            // Microsoft Lumia
            /(lenovo)[-_ ]?([-\w]+)/i,
            // Lenovo
            /(jolla)/i,
            // Jolla
            /(oppo) ?([\w ]+) bui/i // OPPO
            ], [VENDOR, MODEL, [TYPE, MOBILE]], [/(imo) (tab \w+)/i,
            // IMO
            /(kobo)\s(ereader|touch)/i,
            // Kobo
            /(archos) (gamepad2?)/i,
            // Archos
            /(hp).+(touchpad(?!.+tablet)|tablet)/i,
            // HP TouchPad
            /(kindle)\/([\w\.]+)/i,
            // Kindle
            /(nook)[\w ]+build\/(\w+)/i,
            // Nook
            /(dell) (strea[kpr\d ]*[\dko])/i,
            // Dell Streak
            /(le[- ]+pan)[- ]+(\w{1,9}) bui/i,
            // Le Pan Tablets
            /(trinity)[- ]*(t\d{3}) bui/i,
            // Trinity Tablets
            /(gigaset)[- ]+(q\w{1,9}) bui/i,
            // Gigaset Tablets
            /(vodafone) ([\w ]+)(?:\)| bui)/i // Vodafone
            ], [VENDOR, MODEL, [TYPE, TABLET]], [/(surface duo)/i // Surface Duo
            ], [MODEL, [VENDOR, MICROSOFT], [TYPE, TABLET]], [/droid [\d\.]+; (fp\du?)(?: b|\))/i // Fairphone
            ], [MODEL, [VENDOR, 'Fairphone'], [TYPE, MOBILE]], [/(u304aa)/i // AT&T
            ], [MODEL, [VENDOR, 'AT&T'], [TYPE, MOBILE]], [/\bsie-(\w*)/i // Siemens
            ], [MODEL, [VENDOR, 'Siemens'], [TYPE, MOBILE]], [/\b(rct\w+) b/i // RCA Tablets
            ], [MODEL, [VENDOR, 'RCA'], [TYPE, TABLET]], [/\b(venue[\d ]{2,7}) b/i // Dell Venue Tablets
            ], [MODEL, [VENDOR, 'Dell'], [TYPE, TABLET]], [/\b(q(?:mv|ta)\w+) b/i // Verizon Tablet
            ], [MODEL, [VENDOR, 'Verizon'], [TYPE, TABLET]], [/\b(?:barnes[& ]+noble |bn[rt])([\w\+ ]*) b/i // Barnes & Noble Tablet
            ], [MODEL, [VENDOR, 'Barnes & Noble'], [TYPE, TABLET]], [/\b(tm\d{3}\w+) b/i], [MODEL, [VENDOR, 'NuVision'], [TYPE, TABLET]], [/\b(k88) b/i // ZTE K Series Tablet
            ], [MODEL, [VENDOR, 'ZTE'], [TYPE, TABLET]], [/\b(nx\d{3}j) b/i // ZTE Nubia
            ], [MODEL, [VENDOR, 'ZTE'], [TYPE, MOBILE]], [/\b(gen\d{3}) b.+49h/i // Swiss GEN Mobile
            ], [MODEL, [VENDOR, 'Swiss'], [TYPE, MOBILE]], [/\b(zur\d{3}) b/i // Swiss ZUR Tablet
            ], [MODEL, [VENDOR, 'Swiss'], [TYPE, TABLET]], [/\b((zeki)?tb.*\b) b/i // Zeki Tablets
            ], [MODEL, [VENDOR, 'Zeki'], [TYPE, TABLET]], [/\b([yr]\d{2}) b/i, /\b(dragon[- ]+touch |dt)(\w{5}) b/i // Dragon Touch Tablet
            ], [[VENDOR, 'Dragon Touch'], MODEL, [TYPE, TABLET]], [/\b(ns-?\w{0,9}) b/i // Insignia Tablets
            ], [MODEL, [VENDOR, 'Insignia'], [TYPE, TABLET]], [/\b((nxa|next)-?\w{0,9}) b/i // NextBook Tablets
            ], [MODEL, [VENDOR, 'NextBook'], [TYPE, TABLET]], [/\b(xtreme\_)?(v(1[045]|2[015]|[3469]0|7[05])) b/i // Voice Xtreme Phones
            ], [[VENDOR, 'Voice'], MODEL, [TYPE, MOBILE]], [/\b(lvtel\-)?(v1[12]) b/i // LvTel Phones
            ], [[VENDOR, 'LvTel'], MODEL, [TYPE, MOBILE]], [/\b(ph-1) /i // Essential PH-1
            ], [MODEL, [VENDOR, 'Essential'], [TYPE, MOBILE]], [/\b(v(100md|700na|7011|917g).*\b) b/i // Envizen Tablets
            ], [MODEL, [VENDOR, 'Envizen'], [TYPE, TABLET]], [/\b(trio[-\w\. ]+) b/i // MachSpeed Tablets
            ], [MODEL, [VENDOR, 'MachSpeed'], [TYPE, TABLET]], [/\btu_(1491) b/i // Rotor Tablets
            ], [MODEL, [VENDOR, 'Rotor'], [TYPE, TABLET]], [/(shield[\w ]+) b/i // Nvidia Shield Tablets
            ], [MODEL, [VENDOR, 'Nvidia'], [TYPE, TABLET]], [/(sprint) (\w+)/i // Sprint Phones
            ], [VENDOR, MODEL, [TYPE, MOBILE]], [/(kin\.[onetw]{3})/i // Microsoft Kin
            ], [[MODEL, /\./g, ' '], [VENDOR, MICROSOFT], [TYPE, MOBILE]], [/droid.+; (cc6666?|et5[16]|mc[239][23]x?|vc8[03]x?)\)/i // Zebra
            ], [MODEL, [VENDOR, ZEBRA], [TYPE, TABLET]], [/droid.+; (ec30|ps20|tc[2-8]\d[kx])\)/i], [MODEL, [VENDOR, ZEBRA], [TYPE, MOBILE]], [
            ///////////////////
            // SMARTTVS
            ///////////////////

            /smart-tv.+(samsung)/i // Samsung
            ], [VENDOR, [TYPE, SMARTTV]], [/hbbtv.+maple;(\d+)/i], [[MODEL, /^/, 'SmartTV'], [VENDOR, SAMSUNG], [TYPE, SMARTTV]], [/(nux; netcast.+smarttv|lg (netcast\.tv-201\d|android tv))/i // LG SmartTV
            ], [[VENDOR, LG], [TYPE, SMARTTV]], [/(apple) ?tv/i // Apple TV
            ], [VENDOR, [MODEL, APPLE + ' TV'], [TYPE, SMARTTV]], [/crkey/i // Google Chromecast
            ], [[MODEL, CHROME + 'cast'], [VENDOR, GOOGLE], [TYPE, SMARTTV]], [/droid.+aft(\w+)( bui|\))/i // Fire TV
            ], [MODEL, [VENDOR, AMAZON], [TYPE, SMARTTV]], [/\(dtv[\);].+(aquos)/i, /(aquos-tv[\w ]+)\)/i // Sharp
            ], [MODEL, [VENDOR, SHARP], [TYPE, SMARTTV]], [/(bravia[\w ]+)( bui|\))/i // Sony
            ], [MODEL, [VENDOR, SONY], [TYPE, SMARTTV]], [/(mitv-\w{5}) bui/i // Xiaomi
            ], [MODEL, [VENDOR, XIAOMI], [TYPE, SMARTTV]], [/Hbbtv.*(technisat) (.*);/i // TechniSAT
            ], [VENDOR, MODEL, [TYPE, SMARTTV]], [/\b(roku)[\dx]*[\)\/]((?:dvp-)?[\d\.]*)/i,
            // Roku
            /hbbtv\/\d+\.\d+\.\d+ +\([\w\+ ]*; *([\w\d][^;]*);([^;]*)/i // HbbTV devices
            ], [[VENDOR, trim], [MODEL, trim], [TYPE, SMARTTV]], [/\b(android tv|smart[- ]?tv|opera tv|tv; rv:)\b/i // SmartTV from Unidentified Vendors
            ], [[TYPE, SMARTTV]], [
            ///////////////////
            // CONSOLES
            ///////////////////

            /(ouya)/i,
            // Ouya
            /(nintendo) ([wids3utch]+)/i // Nintendo
            ], [VENDOR, MODEL, [TYPE, CONSOLE]], [/droid.+; (shield) bui/i // Nvidia
            ], [MODEL, [VENDOR, 'Nvidia'], [TYPE, CONSOLE]], [/(playstation [345portablevi]+)/i // Playstation
            ], [MODEL, [VENDOR, SONY], [TYPE, CONSOLE]], [/\b(xbox(?: one)?(?!; xbox))[\); ]/i // Microsoft Xbox
            ], [MODEL, [VENDOR, MICROSOFT], [TYPE, CONSOLE]], [
            ///////////////////
            // WEARABLES
            ///////////////////

            /\b(sm-[lr]\d\d[05][fnuw]?s?)\b/i // Samsung Galaxy Watch
            ], [MODEL, [VENDOR, SAMSUNG], [TYPE, WEARABLE]], [/((pebble))app/i // Pebble
            ], [VENDOR, MODEL, [TYPE, WEARABLE]], [/(watch)(?: ?os[,\/]|\d,\d\/)[\d\.]+/i // Apple Watch
            ], [MODEL, [VENDOR, APPLE], [TYPE, WEARABLE]], [/droid.+; (glass) \d/i // Google Glass
            ], [MODEL, [VENDOR, GOOGLE], [TYPE, WEARABLE]], [/droid.+; (wt63?0{2,3})\)/i], [MODEL, [VENDOR, ZEBRA], [TYPE, WEARABLE]], [
            ///////////////////
            // XR
            ///////////////////

            /droid.+; (glass) \d/i // Google Glass
            ], [MODEL, [VENDOR, GOOGLE], [TYPE, WEARABLE]], [/(pico) (4|neo3(?: link|pro)?)/i // Pico
            ], [VENDOR, MODEL, [TYPE, WEARABLE]], [/; (quest( \d| pro)?)/i // Oculus Quest
            ], [MODEL, [VENDOR, FACEBOOK], [TYPE, WEARABLE]], [
            ///////////////////
            // EMBEDDED
            ///////////////////

            /(tesla)(?: qtcarbrowser|\/[-\w\.]+)/i // Tesla
            ], [VENDOR, [TYPE, EMBEDDED]], [/(aeobc)\b/i // Echo Dot
            ], [MODEL, [VENDOR, AMAZON], [TYPE, EMBEDDED]], [
            ////////////////////
            // MIXED (GENERIC)
            ///////////////////

            /droid .+?; ([^;]+?)(?: bui|; wv\)|\) applew).+? mobile safari/i // Android Phones from Unidentified Vendors
            ], [MODEL, [TYPE, MOBILE]], [/droid .+?; ([^;]+?)(?: bui|\) applew).+?(?! mobile) safari/i // Android Tablets from Unidentified Vendors
            ], [MODEL, [TYPE, TABLET]], [/\b((tablet|tab)[;\/]|focus\/\d(?!.+mobile))/i // Unidentifiable Tablet
            ], [[TYPE, TABLET]], [/(phone|mobile(?:[;\/]| [ \w\/\.]*safari)|pda(?=.+windows ce))/i // Unidentifiable Mobile
            ], [[TYPE, MOBILE]], [/(android[-\w\. ]{0,9});.+buil/i // Generic Android Device
            ], [MODEL, [VENDOR, 'Generic']]],
            engine: [[/windows.+ edge\/([\w\.]+)/i // EdgeHTML
            ], [VERSION, [NAME, EDGE + 'HTML']], [/(arkweb)\/([\w\.]+)/i // ArkWeb
            ], [NAME, VERSION], [/webkit\/537\.36.+chrome\/(?!27)([\w\.]+)/i // Blink
            ], [VERSION, [NAME, 'Blink']], [/(presto)\/([\w\.]+)/i,
            // Presto
            /(webkit|trident|netfront|netsurf|amaya|lynx|w3m|goanna|servo)\/([\w\.]+)/i,
            // WebKit/Trident/NetFront/NetSurf/Amaya/Lynx/w3m/Goanna/Servo
            /ekioh(flow)\/([\w\.]+)/i,
            // Flow
            /(khtml|tasman|links)[\/ ]\(?([\w\.]+)/i,
            // KHTML/Tasman/Links
            /(icab)[\/ ]([23]\.[\d\.]+)/i,
            // iCab
            /\b(libweb)/i], [NAME, VERSION], [/rv\:([\w\.]{1,9})\b.+(gecko)/i // Gecko
            ], [VERSION, NAME]],
            os: [[
            // Windows
            /microsoft (windows) (vista|xp)/i // Windows (iTunes)
            ], [NAME, VERSION], [/(windows (?:phone(?: os)?|mobile))[\/ ]?([\d\.\w ]*)/i // Windows Phone
            ], [NAME, [VERSION, strMapper, windowsVersionMap]], [/windows nt 6\.2; (arm)/i,
            // Windows RT
            /windows[\/ ]?([ntce\d\. ]+\w)(?!.+xbox)/i, /(?:win(?=3|9|n)|win 9x )([nt\d\.]+)/i], [[VERSION, strMapper, windowsVersionMap], [NAME, 'Windows']], [
            // iOS/macOS
            /ip[honead]{2,4}\b(?:.*os ([\w]+) like mac|; opera)/i,
            // iOS
            /(?:ios;fbsv\/|iphone.+ios[\/ ])([\d\.]+)/i, /cfnetwork\/.+darwin/i], [[VERSION, /_/g, '.'], [NAME, 'iOS']], [/(mac os x) ?([\w\. ]*)/i, /(macintosh|mac_powerpc\b)(?!.+haiku)/i // Mac OS
            ], [[NAME, MAC_OS], [VERSION, /_/g, '.']], [
            // Mobile OSes
            /droid ([\w\.]+)\b.+(android[- ]x86|harmonyos)/i // Android-x86/HarmonyOS
            ], [VERSION, NAME], [
            // Android/WebOS/QNX/Bada/RIM/Maemo/MeeGo/Sailfish OS/OpenHarmony
            /(android|webos|qnx|bada|rim tablet os|maemo|meego|sailfish|openharmony)[-\/ ]?([\w\.]*)/i, /(blackberry)\w*\/([\w\.]*)/i,
            // Blackberry
            /(tizen|kaios)[\/ ]([\w\.]+)/i,
            // Tizen/KaiOS
            /\((series40);/i // Series 40
            ], [NAME, VERSION], [/\(bb(10);/i // BlackBerry 10
            ], [VERSION, [NAME, BLACKBERRY]], [/(?:symbian ?os|symbos|s60(?=;)|series60)[-\/ ]?([\w\.]*)/i // Symbian
            ], [VERSION, [NAME, 'Symbian']], [/mozilla\/[\d\.]+ \((?:mobile|tablet|tv|mobile; [\w ]+); rv:.+ gecko\/([\w\.]+)/i // Firefox OS
            ], [VERSION, [NAME, FIREFOX + ' OS']], [/web0s;.+rt(tv)/i, /\b(?:hp)?wos(?:browser)?\/([\w\.]+)/i // WebOS
            ], [VERSION, [NAME, 'webOS']], [/watch(?: ?os[,\/]|\d,\d\/)([\d\.]+)/i // watchOS
            ], [VERSION, [NAME, 'watchOS']], [
            // Google Chromecast
            /crkey\/([\d\.]+)/i // Google Chromecast
            ], [VERSION, [NAME, CHROME + 'cast']], [/(cros) [\w]+(?:\)| ([\w\.]+)\b)/i // Chromium OS
            ], [[NAME, CHROMIUM_OS], VERSION], [
            // Smart TVs
            /panasonic;(viera)/i,
            // Panasonic Viera
            /(netrange)mmh/i,
            // Netrange
            /(nettv)\/(\d+\.[\w\.]+)/i,
            // NetTV

            // Console
            /(nintendo|playstation) ([wids345portablevuch]+)/i,
            // Nintendo/Playstation
            /(xbox); +xbox ([^\);]+)/i,
            // Microsoft Xbox (360, One, X, S, Series X, Series S)

            // Other
            /\b(joli|palm)\b ?(?:os)?\/?([\w\.]*)/i,
            // Joli/Palm
            /(mint)[\/\(\) ]?(\w*)/i,
            // Mint
            /(mageia|vectorlinux)[; ]/i,
            // Mageia/VectorLinux
            /([kxln]?ubuntu|debian|suse|opensuse|gentoo|arch(?= linux)|slackware|fedora|mandriva|centos|pclinuxos|red ?hat|zenwalk|linpus|raspbian|plan 9|minix|risc os|contiki|deepin|manjaro|elementary os|sabayon|linspire)(?: gnu\/linux)?(?: enterprise)?(?:[- ]linux)?(?:-gnu)?[-\/ ]?(?!chrom|package)([-\w\.]*)/i,
            // Ubuntu/Debian/SUSE/Gentoo/Arch/Slackware/Fedora/Mandriva/CentOS/PCLinuxOS/RedHat/Zenwalk/Linpus/Raspbian/Plan9/Minix/RISCOS/Contiki/Deepin/Manjaro/elementary/Sabayon/Linspire
            /(hurd|linux) ?([\w\.]*)/i,
            // Hurd/Linux
            /(gnu) ?([\w\.]*)/i,
            // GNU
            /\b([-frentopcghs]{0,5}bsd|dragonfly)[\/ ]?(?!amd|[ix346]{1,2}86)([\w\.]*)/i,
            // FreeBSD/NetBSD/OpenBSD/PC-BSD/GhostBSD/DragonFly
            /(haiku) (\w+)/i // Haiku
            ], [NAME, VERSION], [/(sunos) ?([\w\.\d]*)/i // Solaris
            ], [[NAME, 'Solaris'], VERSION], [/((?:open)?solaris)[-\/ ]?([\w\.]*)/i,
            // Solaris
            /(aix) ((\d)(?=\.|\)| )[\w\.])*/i,
            // AIX
            /\b(beos|os\/2|amigaos|morphos|openvms|fuchsia|hp-ux|serenityos)/i,
            // BeOS/OS2/AmigaOS/MorphOS/OpenVMS/Fuchsia/HP-UX/SerenityOS
            /(unix) ?([\w\.]*)/i // UNIX
            ], [NAME, VERSION]]
          };

          /////////////////
          // Constructor
          ////////////////

          var UAParser = function (ua, extensions) {
            if (typeof ua === OBJ_TYPE) {
              extensions = ua;
              ua = undefined$1;
            }
            if (!(this instanceof UAParser)) {
              return new UAParser(ua, extensions).getResult();
            }
            var _navigator = typeof window !== UNDEF_TYPE && window.navigator ? window.navigator : undefined$1;
            var _ua = ua || (_navigator && _navigator.userAgent ? _navigator.userAgent : EMPTY);
            var _uach = _navigator && _navigator.userAgentData ? _navigator.userAgentData : undefined$1;
            var _rgxmap = extensions ? extend(regexes, extensions) : regexes;
            var _isSelfNav = _navigator && _navigator.userAgent == _ua;
            this.getBrowser = function () {
              var _browser = {};
              _browser[NAME] = undefined$1;
              _browser[VERSION] = undefined$1;
              rgxMapper.call(_browser, _ua, _rgxmap.browser);
              _browser[MAJOR] = majorize(_browser[VERSION]);
              // Brave-specific detection
              if (_isSelfNav && _navigator && _navigator.brave && typeof _navigator.brave.isBrave == FUNC_TYPE) {
                _browser[NAME] = 'Brave';
              }
              return _browser;
            };
            this.getCPU = function () {
              var _cpu = {};
              _cpu[ARCHITECTURE] = undefined$1;
              rgxMapper.call(_cpu, _ua, _rgxmap.cpu);
              return _cpu;
            };
            this.getDevice = function () {
              var _device = {};
              _device[VENDOR] = undefined$1;
              _device[MODEL] = undefined$1;
              _device[TYPE] = undefined$1;
              rgxMapper.call(_device, _ua, _rgxmap.device);
              if (_isSelfNav && !_device[TYPE] && _uach && _uach.mobile) {
                _device[TYPE] = MOBILE;
              }
              // iPadOS-specific detection: identified as Mac, but has some iOS-only properties
              if (_isSelfNav && _device[MODEL] == 'Macintosh' && _navigator && typeof _navigator.standalone !== UNDEF_TYPE && _navigator.maxTouchPoints && _navigator.maxTouchPoints > 2) {
                _device[MODEL] = 'iPad';
                _device[TYPE] = TABLET;
              }
              return _device;
            };
            this.getEngine = function () {
              var _engine = {};
              _engine[NAME] = undefined$1;
              _engine[VERSION] = undefined$1;
              rgxMapper.call(_engine, _ua, _rgxmap.engine);
              return _engine;
            };
            this.getOS = function () {
              var _os = {};
              _os[NAME] = undefined$1;
              _os[VERSION] = undefined$1;
              rgxMapper.call(_os, _ua, _rgxmap.os);
              if (_isSelfNav && !_os[NAME] && _uach && _uach.platform && _uach.platform != 'Unknown') {
                _os[NAME] = _uach.platform.replace(/chrome os/i, CHROMIUM_OS).replace(/macos/i, MAC_OS); // backward compatibility
              }
              return _os;
            };
            this.getResult = function () {
              return {
                ua: this.getUA(),
                browser: this.getBrowser(),
                engine: this.getEngine(),
                os: this.getOS(),
                device: this.getDevice(),
                cpu: this.getCPU()
              };
            };
            this.getUA = function () {
              return _ua;
            };
            this.setUA = function (ua) {
              _ua = typeof ua === STR_TYPE && ua.length > UA_MAX_LENGTH ? trim(ua, UA_MAX_LENGTH) : ua;
              return this;
            };
            this.setUA(_ua);
            return this;
          };
          UAParser.VERSION = LIBVERSION;
          UAParser.BROWSER = enumerize([NAME, VERSION, MAJOR]);
          UAParser.CPU = enumerize([ARCHITECTURE]);
          UAParser.DEVICE = enumerize([MODEL, VENDOR, TYPE, CONSOLE, MOBILE, SMARTTV, TABLET, WEARABLE, EMBEDDED]);
          UAParser.ENGINE = UAParser.OS = enumerize([NAME, VERSION]);

          ///////////
          // Export
          //////////

          // check js environment
          {
            // nodejs env
            if (module.exports) {
              exports = module.exports = UAParser;
            }
            exports.UAParser = UAParser;
          }

          // jQuery/Zepto specific (optional)
          // Note:
          //   In AMD env the global scope should be kept clean, but jQuery is an exception.
          //   jQuery always exports to global scope, unless jQuery.noConflict(true) is used,
          //   and we should catch that.
          var $ = typeof window !== UNDEF_TYPE && (window.jQuery || window.Zepto);
          if ($ && !$.ua) {
            var parser = new UAParser();
            $.ua = parser.getResult();
            $.ua.get = function () {
              return parser.getUA();
            };
            $.ua.set = function (ua) {
              parser.setUA(ua);
              var result = parser.getResult();
              for (var prop in result) {
                $.ua[prop] = result[prop];
              }
            };
          }
        })(typeof window === 'object' ? window : uaParser);
      })(uaParser$1, uaParser$1.exports);
      return uaParser$1.exports;
    }

    var uaParserExports = requireUaParser();
    var UAParser = /*@__PURE__*/getDefaultExportFromCjs(uaParserExports);

    /*
     * Copyright The OpenTelemetry Authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      https://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    var OTLPExporterBase = /** @class */function () {
      function OTLPExporterBase(_delegate) {
        this._delegate = _delegate;
      }
      /**
       * Export items.
       * @param items
       * @param resultCallback
       */
      OTLPExporterBase.prototype.export = function (items, resultCallback) {
        this._delegate.export(items, resultCallback);
      };
      OTLPExporterBase.prototype.forceFlush = function () {
        return this._delegate.forceFlush();
      };
      OTLPExporterBase.prototype.shutdown = function () {
        return this._delegate.shutdown();
      };
      return OTLPExporterBase;
    }();

    /*
     * Copyright The OpenTelemetry Authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      https://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    var __extends$5 = undefined && undefined.__extends || function () {
      var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf || {
          __proto__: []
        } instanceof Array && function (d, b) {
          d.__proto__ = b;
        } || function (d, b) {
          for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
        };
        return extendStatics(d, b);
      };
      return function (d, b) {
        if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    /**
     * Interface for handling error
     */
    var OTLPExporterError = /** @class */function (_super) {
      __extends$5(OTLPExporterError, _super);
      function OTLPExporterError(message, code, data) {
        var _this = _super.call(this, message) || this;
        _this.name = 'OTLPExporterError';
        _this.data = data;
        _this.code = code;
        return _this;
      }
      return OTLPExporterError;
    }(Error);

    /*
     * Copyright The OpenTelemetry Authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      https://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    function validateTimeoutMillis(timeoutMillis) {
      if (!Number.isNaN(timeoutMillis) && Number.isFinite(timeoutMillis) && timeoutMillis > 0) {
        return timeoutMillis;
      }
      throw new Error("Configuration: timeoutMillis is invalid, expected number greater than 0 (actual: '" + timeoutMillis + "')");
    }
    function wrapStaticHeadersInFunction(headers) {
      if (headers == null) {
        return undefined;
      }
      return function () {
        return headers;
      };
    }
    /**
     * @param userProvidedConfiguration  Configuration options provided by the user in code.
     * @param fallbackConfiguration Fallback to use when the {@link userProvidedConfiguration} does not specify an option.
     * @param defaultConfiguration The defaults as defined by the exporter specification
     */
    function mergeOtlpSharedConfigurationWithDefaults(userProvidedConfiguration, fallbackConfiguration, defaultConfiguration) {
      var _a, _b, _c, _d, _e, _f;
      return {
        timeoutMillis: validateTimeoutMillis((_b = (_a = userProvidedConfiguration.timeoutMillis) !== null && _a !== void 0 ? _a : fallbackConfiguration.timeoutMillis) !== null && _b !== void 0 ? _b : defaultConfiguration.timeoutMillis),
        concurrencyLimit: (_d = (_c = userProvidedConfiguration.concurrencyLimit) !== null && _c !== void 0 ? _c : fallbackConfiguration.concurrencyLimit) !== null && _d !== void 0 ? _d : defaultConfiguration.concurrencyLimit,
        compression: (_f = (_e = userProvidedConfiguration.compression) !== null && _e !== void 0 ? _e : fallbackConfiguration.compression) !== null && _f !== void 0 ? _f : defaultConfiguration.compression
      };
    }
    function getSharedConfigurationDefaults() {
      return {
        timeoutMillis: 10000,
        concurrencyLimit: 30,
        compression: 'none'
      };
    }

    /*
     * Copyright The OpenTelemetry Authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      https://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    var __awaiter$3 = undefined && undefined.__awaiter || function (thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function (resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator$3 = undefined && undefined.__generator || function (thisArg, body) {
      var _ = {
          label: 0,
          sent: function () {
            if (t[0] & 1) throw t[1];
            return t[1];
          },
          trys: [],
          ops: []
        },
        f,
        y,
        t,
        g;
      return g = {
        next: verb(0),
        "throw": verb(1),
        "return": verb(2)
      }, typeof Symbol === "function" && (g[Symbol.iterator] = function () {
        return this;
      }), g;
      function verb(n) {
        return function (v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
          if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
          if (y = 0, t) op = [op[0] & 2, t.value];
          switch (op[0]) {
            case 0:
            case 1:
              t = op;
              break;
            case 4:
              _.label++;
              return {
                value: op[1],
                done: false
              };
            case 5:
              _.label++;
              y = op[1];
              op = [0];
              continue;
            case 7:
              op = _.ops.pop();
              _.trys.pop();
              continue;
            default:
              if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                _ = 0;
                continue;
              }
              if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                _.label = op[1];
                break;
              }
              if (op[0] === 6 && _.label < t[1]) {
                _.label = t[1];
                t = op;
                break;
              }
              if (t && _.label < t[2]) {
                _.label = t[2];
                _.ops.push(op);
                break;
              }
              if (t[2]) _.ops.pop();
              _.trys.pop();
              continue;
          }
          op = body.call(thisArg, _);
        } catch (e) {
          op = [6, e];
          y = 0;
        } finally {
          f = t = 0;
        }
        if (op[0] & 5) throw op[1];
        return {
          value: op[0] ? op[1] : void 0,
          done: true
        };
      }
    };
    var BoundedQueueExportPromiseHandler = /** @class */function () {
      /**
       * @param concurrencyLimit maximum promises allowed in a queue at the same time.
       */
      function BoundedQueueExportPromiseHandler(concurrencyLimit) {
        this._sendingPromises = [];
        this._concurrencyLimit = concurrencyLimit;
      }
      BoundedQueueExportPromiseHandler.prototype.pushPromise = function (promise) {
        var _this = this;
        if (this.hasReachedLimit()) {
          throw new Error('Concurrency Limit reached');
        }
        this._sendingPromises.push(promise);
        var popPromise = function () {
          var index = _this._sendingPromises.indexOf(promise);
          _this._sendingPromises.splice(index, 1);
        };
        promise.then(popPromise, popPromise);
      };
      BoundedQueueExportPromiseHandler.prototype.hasReachedLimit = function () {
        return this._sendingPromises.length >= this._concurrencyLimit;
      };
      BoundedQueueExportPromiseHandler.prototype.awaitAll = function () {
        return __awaiter$3(this, void 0, void 0, function () {
          return __generator$3(this, function (_a) {
            switch (_a.label) {
              case 0:
                return [4 /*yield*/, Promise.all(this._sendingPromises)];
              case 1:
                _a.sent();
                return [2 /*return*/];
            }
          });
        });
      };
      return BoundedQueueExportPromiseHandler;
    }();
    /**
     * Promise queue for keeping track of export promises. Finished promises will be auto-dequeued.
     * Allows for awaiting all promises in the queue.
     */
    function createBoundedQueueExportPromiseHandler(options) {
      return new BoundedQueueExportPromiseHandler(options.concurrencyLimit);
    }

    /*
     * Copyright The OpenTelemetry Authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      https://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    function isPartialSuccessResponse(response) {
      return Object.prototype.hasOwnProperty.call(response, 'partialSuccess');
    }
    /**
     * Default response handler that logs a partial success to the console.
     */
    function createLoggingPartialSuccessResponseHandler() {
      return {
        handleResponse: function (response) {
          // Partial success MUST never be an empty object according the specification
          // see https://opentelemetry.io/docs/specs/otlp/#partial-success
          if (response == null || !isPartialSuccessResponse(response) || response.partialSuccess == null || Object.keys(response.partialSuccess).length === 0) {
            return;
          }
          diag.warn('Received Partial Success response:', JSON.stringify(response.partialSuccess));
        }
      };
    }

    /*
     * Copyright The OpenTelemetry Authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      https://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    var __awaiter$2 = undefined && undefined.__awaiter || function (thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function (resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator$2 = undefined && undefined.__generator || function (thisArg, body) {
      var _ = {
          label: 0,
          sent: function () {
            if (t[0] & 1) throw t[1];
            return t[1];
          },
          trys: [],
          ops: []
        },
        f,
        y,
        t,
        g;
      return g = {
        next: verb(0),
        "throw": verb(1),
        "return": verb(2)
      }, typeof Symbol === "function" && (g[Symbol.iterator] = function () {
        return this;
      }), g;
      function verb(n) {
        return function (v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
          if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
          if (y = 0, t) op = [op[0] & 2, t.value];
          switch (op[0]) {
            case 0:
            case 1:
              t = op;
              break;
            case 4:
              _.label++;
              return {
                value: op[1],
                done: false
              };
            case 5:
              _.label++;
              y = op[1];
              op = [0];
              continue;
            case 7:
              op = _.ops.pop();
              _.trys.pop();
              continue;
            default:
              if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                _ = 0;
                continue;
              }
              if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                _.label = op[1];
                break;
              }
              if (op[0] === 6 && _.label < t[1]) {
                _.label = t[1];
                t = op;
                break;
              }
              if (t && _.label < t[2]) {
                _.label = t[2];
                _.ops.push(op);
                break;
              }
              if (t[2]) _.ops.pop();
              _.trys.pop();
              continue;
          }
          op = body.call(thisArg, _);
        } catch (e) {
          op = [6, e];
          y = 0;
        } finally {
          f = t = 0;
        }
        if (op[0] & 5) throw op[1];
        return {
          value: op[0] ? op[1] : void 0,
          done: true
        };
      }
    };
    var OTLPExportDelegate = /** @class */function () {
      function OTLPExportDelegate(_transport, _serializer, _responseHandler, _promiseQueue, _timeout) {
        this._transport = _transport;
        this._serializer = _serializer;
        this._responseHandler = _responseHandler;
        this._promiseQueue = _promiseQueue;
        this._timeout = _timeout;
        this._diagLogger = diag.createComponentLogger({
          namespace: 'OTLPExportDelegate'
        });
      }
      OTLPExportDelegate.prototype.export = function (internalRepresentation, resultCallback) {
        var _this = this;
        this._diagLogger.debug('items to be sent', internalRepresentation);
        // don't do any work if too many exports are in progress.
        if (this._promiseQueue.hasReachedLimit()) {
          resultCallback({
            code: ExportResultCode.FAILED,
            error: new Error('Concurrent export limit reached')
          });
          return;
        }
        var serializedRequest = this._serializer.serializeRequest(internalRepresentation);
        if (serializedRequest == null) {
          resultCallback({
            code: ExportResultCode.FAILED,
            error: new Error('Nothing to send')
          });
          return;
        }
        this._promiseQueue.pushPromise(this._transport.send(serializedRequest, this._timeout).then(function (response) {
          if (response.status === 'success') {
            if (response.data != null) {
              try {
                _this._responseHandler.handleResponse(_this._serializer.deserializeResponse(response.data));
              } catch (e) {
                _this._diagLogger.warn('Export succeeded but could not deserialize response - is the response specification compliant?', e, response.data);
              }
            }
            // No matter the response, we can consider the export still successful.
            resultCallback({
              code: ExportResultCode.SUCCESS
            });
            return;
          } else if (response.status === 'failure' && response.error) {
            resultCallback({
              code: ExportResultCode.FAILED,
              error: response.error
            });
            return;
          } else if (response.status === 'retryable') {
            resultCallback({
              code: ExportResultCode.FAILED,
              error: new OTLPExporterError('Export failed with retryable status')
            });
          } else {
            resultCallback({
              code: ExportResultCode.FAILED,
              error: new OTLPExporterError('Export failed with unknown error')
            });
          }
        }, function (reason) {
          return resultCallback({
            code: ExportResultCode.FAILED,
            error: reason
          });
        }));
      };
      OTLPExportDelegate.prototype.forceFlush = function () {
        return this._promiseQueue.awaitAll();
      };
      OTLPExportDelegate.prototype.shutdown = function () {
        return __awaiter$2(this, void 0, void 0, function () {
          return __generator$2(this, function (_a) {
            switch (_a.label) {
              case 0:
                this._diagLogger.debug('shutdown started');
                return [4 /*yield*/, this.forceFlush()];
              case 1:
                _a.sent();
                this._transport.shutdown();
                return [2 /*return*/];
            }
          });
        });
      };
      return OTLPExportDelegate;
    }();
    /**
     * Creates a generic delegate for OTLP exports which only contains parts of the OTLP export that are shared across all
     * signals.
     */
    function createOtlpExportDelegate(components, settings) {
      return new OTLPExportDelegate(components.transport, components.serializer, createLoggingPartialSuccessResponseHandler(), components.promiseHandler, settings.timeout);
    }

    /*
     * Copyright The OpenTelemetry Authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      https://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    function createOtlpNetworkExportDelegate(options, serializer, transport) {
      return createOtlpExportDelegate({
        transport: transport,
        serializer: serializer,
        promiseHandler: createBoundedQueueExportPromiseHandler(options)
      }, {
        timeout: options.timeoutMillis
      });
    }

    /*
     * Copyright The OpenTelemetry Authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      https://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    function hrTimeToNanos(hrTime) {
      var NANOSECONDS = BigInt(1000000000);
      return BigInt(hrTime[0]) * NANOSECONDS + BigInt(hrTime[1]);
    }
    function toLongBits(value) {
      var low = Number(BigInt.asUintN(32, value));
      var high = Number(BigInt.asUintN(32, value >> BigInt(32)));
      return {
        low: low,
        high: high
      };
    }
    function encodeAsLongBits(hrTime) {
      var nanos = hrTimeToNanos(hrTime);
      return toLongBits(nanos);
    }
    function encodeAsString(hrTime) {
      var nanos = hrTimeToNanos(hrTime);
      return nanos.toString();
    }
    var encodeTimestamp = typeof BigInt !== 'undefined' ? encodeAsString : hrTimeToNanoseconds;
    function identity(value) {
      return value;
    }
    function optionalHexToBinary(str) {
      if (str === undefined) return undefined;
      return hexToBinary(str);
    }
    var DEFAULT_ENCODER = {
      encodeHrTime: encodeAsLongBits,
      encodeSpanContext: hexToBinary,
      encodeOptionalSpanContext: optionalHexToBinary
    };
    function getOtlpEncoder(options) {
      var _a, _b;
      if (options === undefined) {
        return DEFAULT_ENCODER;
      }
      var useLongBits = (_a = options.useLongBits) !== null && _a !== void 0 ? _a : true;
      var useHex = (_b = options.useHex) !== null && _b !== void 0 ? _b : false;
      return {
        encodeHrTime: useLongBits ? encodeAsLongBits : encodeTimestamp,
        encodeSpanContext: useHex ? identity : hexToBinary,
        encodeOptionalSpanContext: useHex ? identity : optionalHexToBinary
      };
    }

    var __read$6 = undefined && undefined.__read || function (o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m) return o;
      var i = m.call(o),
        r,
        ar = [],
        e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
      } catch (error) {
        e = {
          error: error
        };
      } finally {
        try {
          if (r && !r.done && (m = i["return"])) m.call(i);
        } finally {
          if (e) throw e.error;
        }
      }
      return ar;
    };
    function createResource(resource) {
      return {
        attributes: toAttributes(resource.attributes),
        droppedAttributesCount: 0
      };
    }
    function createInstrumentationScope(scope) {
      return {
        name: scope.name,
        version: scope.version
      };
    }
    function toAttributes(attributes) {
      return Object.keys(attributes).map(function (key) {
        return toKeyValue(key, attributes[key]);
      });
    }
    function toKeyValue(key, value) {
      return {
        key: key,
        value: toAnyValue(value)
      };
    }
    function toAnyValue(value) {
      var t = typeof value;
      if (t === 'string') return {
        stringValue: value
      };
      if (t === 'number') {
        if (!Number.isInteger(value)) return {
          doubleValue: value
        };
        return {
          intValue: value
        };
      }
      if (t === 'boolean') return {
        boolValue: value
      };
      if (value instanceof Uint8Array) return {
        bytesValue: value
      };
      if (Array.isArray(value)) return {
        arrayValue: {
          values: value.map(toAnyValue)
        }
      };
      if (t === 'object' && value != null) return {
        kvlistValue: {
          values: Object.entries(value).map(function (_a) {
            var _b = __read$6(_a, 2),
              k = _b[0],
              v = _b[1];
            return toKeyValue(k, v);
          })
        }
      };
      return {};
    }

    var __values$2 = undefined && undefined.__values || function (o) {
      var s = typeof Symbol === "function" && Symbol.iterator,
        m = s && o[s],
        i = 0;
      if (m) return m.call(o);
      if (o && typeof o.length === "number") return {
        next: function () {
          if (o && i >= o.length) o = void 0;
          return {
            value: o && o[i++],
            done: !o
          };
        }
      };
      throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    };
    var __read$5 = undefined && undefined.__read || function (o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m) return o;
      var i = m.call(o),
        r,
        ar = [],
        e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
      } catch (error) {
        e = {
          error: error
        };
      } finally {
        try {
          if (r && !r.done && (m = i["return"])) m.call(i);
        } finally {
          if (e) throw e.error;
        }
      }
      return ar;
    };
    function sdkSpanToOtlpSpan(span, encoder) {
      var _a;
      var ctx = span.spanContext();
      var status = span.status;
      return {
        traceId: encoder.encodeSpanContext(ctx.traceId),
        spanId: encoder.encodeSpanContext(ctx.spanId),
        parentSpanId: encoder.encodeOptionalSpanContext(span.parentSpanId),
        traceState: (_a = ctx.traceState) === null || _a === void 0 ? void 0 : _a.serialize(),
        name: span.name,
        // Span kind is offset by 1 because the API does not define a value for unset
        kind: span.kind == null ? 0 : span.kind + 1,
        startTimeUnixNano: encoder.encodeHrTime(span.startTime),
        endTimeUnixNano: encoder.encodeHrTime(span.endTime),
        attributes: toAttributes(span.attributes),
        droppedAttributesCount: span.droppedAttributesCount,
        events: span.events.map(function (event) {
          return toOtlpSpanEvent(event, encoder);
        }),
        droppedEventsCount: span.droppedEventsCount,
        status: {
          // API and proto enums share the same values
          code: status.code,
          message: status.message
        },
        links: span.links.map(function (link) {
          return toOtlpLink(link, encoder);
        }),
        droppedLinksCount: span.droppedLinksCount
      };
    }
    function toOtlpLink(link, encoder) {
      var _a;
      return {
        attributes: link.attributes ? toAttributes(link.attributes) : [],
        spanId: encoder.encodeSpanContext(link.context.spanId),
        traceId: encoder.encodeSpanContext(link.context.traceId),
        traceState: (_a = link.context.traceState) === null || _a === void 0 ? void 0 : _a.serialize(),
        droppedAttributesCount: link.droppedAttributesCount || 0
      };
    }
    function toOtlpSpanEvent(timedEvent, encoder) {
      return {
        attributes: timedEvent.attributes ? toAttributes(timedEvent.attributes) : [],
        name: timedEvent.name,
        timeUnixNano: encoder.encodeHrTime(timedEvent.time),
        droppedAttributesCount: timedEvent.droppedAttributesCount || 0
      };
    }
    /*
     * Copyright The OpenTelemetry Authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      https://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    function createExportTraceServiceRequest(spans, options) {
      var encoder = getOtlpEncoder(options);
      return {
        resourceSpans: spanRecordsToResourceSpans(spans, encoder)
      };
    }
    function createResourceMap(readableSpans) {
      var e_1, _a;
      var resourceMap = new Map();
      try {
        for (var readableSpans_1 = __values$2(readableSpans), readableSpans_1_1 = readableSpans_1.next(); !readableSpans_1_1.done; readableSpans_1_1 = readableSpans_1.next()) {
          var record = readableSpans_1_1.value;
          var ilmMap = resourceMap.get(record.resource);
          if (!ilmMap) {
            ilmMap = new Map();
            resourceMap.set(record.resource, ilmMap);
          }
          // TODO this is duplicated in basic tracer. Consolidate on a common helper in core
          var instrumentationLibraryKey = record.instrumentationLibrary.name + "@" + (record.instrumentationLibrary.version || '') + ":" + (record.instrumentationLibrary.schemaUrl || '');
          var records = ilmMap.get(instrumentationLibraryKey);
          if (!records) {
            records = [];
            ilmMap.set(instrumentationLibraryKey, records);
          }
          records.push(record);
        }
      } catch (e_1_1) {
        e_1 = {
          error: e_1_1
        };
      } finally {
        try {
          if (readableSpans_1_1 && !readableSpans_1_1.done && (_a = readableSpans_1.return)) _a.call(readableSpans_1);
        } finally {
          if (e_1) throw e_1.error;
        }
      }
      return resourceMap;
    }
    function spanRecordsToResourceSpans(readableSpans, encoder) {
      var resourceMap = createResourceMap(readableSpans);
      var out = [];
      var entryIterator = resourceMap.entries();
      var entry = entryIterator.next();
      while (!entry.done) {
        var _a = __read$5(entry.value, 2),
          resource = _a[0],
          ilmMap = _a[1];
        var scopeResourceSpans = [];
        var ilmIterator = ilmMap.values();
        var ilmEntry = ilmIterator.next();
        while (!ilmEntry.done) {
          var scopeSpans = ilmEntry.value;
          if (scopeSpans.length > 0) {
            var spans = scopeSpans.map(function (readableSpan) {
              return sdkSpanToOtlpSpan(readableSpan, encoder);
            });
            scopeResourceSpans.push({
              scope: createInstrumentationScope(scopeSpans[0].instrumentationLibrary),
              spans: spans,
              schemaUrl: scopeSpans[0].instrumentationLibrary.schemaUrl
            });
          }
          ilmEntry = ilmIterator.next();
        }
        // TODO SDK types don't provide resource schema URL at this time
        var transformedSpans = {
          resource: createResource(resource),
          scopeSpans: scopeResourceSpans,
          schemaUrl: undefined
        };
        out.push(transformedSpans);
        entry = entryIterator.next();
      }
      return out;
    }

    var JsonTraceSerializer = {
      serializeRequest: function (arg) {
        var request = createExportTraceServiceRequest(arg, {
          useHex: true,
          useLongBits: false
        });
        var encoder = new TextEncoder();
        return encoder.encode(JSON.stringify(request));
      },
      deserializeResponse: function (arg) {
        var decoder = new TextDecoder();
        return JSON.parse(decoder.decode(arg));
      }
    };

    /*
     * Copyright The OpenTelemetry Authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      https://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    var __awaiter$1 = undefined && undefined.__awaiter || function (thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function (resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator$1 = undefined && undefined.__generator || function (thisArg, body) {
      var _ = {
          label: 0,
          sent: function () {
            if (t[0] & 1) throw t[1];
            return t[1];
          },
          trys: [],
          ops: []
        },
        f,
        y,
        t,
        g;
      return g = {
        next: verb(0),
        "throw": verb(1),
        "return": verb(2)
      }, typeof Symbol === "function" && (g[Symbol.iterator] = function () {
        return this;
      }), g;
      function verb(n) {
        return function (v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
          if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
          if (y = 0, t) op = [op[0] & 2, t.value];
          switch (op[0]) {
            case 0:
            case 1:
              t = op;
              break;
            case 4:
              _.label++;
              return {
                value: op[1],
                done: false
              };
            case 5:
              _.label++;
              y = op[1];
              op = [0];
              continue;
            case 7:
              op = _.ops.pop();
              _.trys.pop();
              continue;
            default:
              if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                _ = 0;
                continue;
              }
              if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                _.label = op[1];
                break;
              }
              if (op[0] === 6 && _.label < t[1]) {
                _.label = t[1];
                t = op;
                break;
              }
              if (t && _.label < t[2]) {
                _.label = t[2];
                _.ops.push(op);
                break;
              }
              if (t[2]) _.ops.pop();
              _.trys.pop();
              continue;
          }
          op = body.call(thisArg, _);
        } catch (e) {
          op = [6, e];
          y = 0;
        } finally {
          f = t = 0;
        }
        if (op[0] & 5) throw op[1];
        return {
          value: op[0] ? op[1] : void 0,
          done: true
        };
      }
    };
    var MAX_ATTEMPTS = 5;
    var INITIAL_BACKOFF = 1000;
    var MAX_BACKOFF = 5000;
    var BACKOFF_MULTIPLIER = 1.5;
    var JITTER = 0.2;
    /**
     * Get a pseudo-random jitter that falls in the range of [-JITTER, +JITTER]
     */
    function getJitter() {
      return Math.random() * (2 * JITTER) - JITTER;
    }
    var RetryingTransport = /** @class */function () {
      function RetryingTransport(_transport) {
        this._transport = _transport;
      }
      RetryingTransport.prototype.retry = function (data, timeoutMillis, inMillis) {
        var _this = this;
        return new Promise(function (resolve, reject) {
          setTimeout(function () {
            _this._transport.send(data, timeoutMillis).then(resolve, reject);
          }, inMillis);
        });
      };
      RetryingTransport.prototype.send = function (data, timeoutMillis) {
        var _a;
        return __awaiter$1(this, void 0, void 0, function () {
          var deadline, result, attempts, nextBackoff, backoff, retryInMillis, remainingTimeoutMillis;
          return __generator$1(this, function (_b) {
            switch (_b.label) {
              case 0:
                deadline = Date.now() + timeoutMillis;
                return [4 /*yield*/, this._transport.send(data, timeoutMillis)];
              case 1:
                result = _b.sent();
                attempts = MAX_ATTEMPTS;
                nextBackoff = INITIAL_BACKOFF;
                _b.label = 2;
              case 2:
                if (!(result.status === 'retryable' && attempts > 0)) return [3 /*break*/, 4];
                attempts--;
                backoff = Math.max(Math.min(nextBackoff, MAX_BACKOFF) + getJitter(), 0);
                nextBackoff = nextBackoff * BACKOFF_MULTIPLIER;
                retryInMillis = (_a = result.retryInMillis) !== null && _a !== void 0 ? _a : backoff;
                remainingTimeoutMillis = deadline - Date.now();
                if (retryInMillis > remainingTimeoutMillis) {
                  return [2 /*return*/, result];
                }
                return [4 /*yield*/, this.retry(data, remainingTimeoutMillis, retryInMillis)];
              case 3:
                result = _b.sent();
                return [3 /*break*/, 2];
              case 4:
                return [2 /*return*/, result];
            }
          });
        });
      };
      RetryingTransport.prototype.shutdown = function () {
        return this._transport.shutdown();
      };
      return RetryingTransport;
    }();
    /**
     * Creates an Exporter Transport that retries on 'retryable' response.
     */
    function createRetryingTransport(options) {
      return new RetryingTransport(options.transport);
    }

    /*
     * Copyright The OpenTelemetry Authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      https://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    function isExportRetryable(statusCode) {
      var retryCodes = [429, 502, 503, 504];
      return retryCodes.includes(statusCode);
    }
    function parseRetryAfterToMills(retryAfter) {
      if (retryAfter == null) {
        return undefined;
      }
      var seconds = Number.parseInt(retryAfter, 10);
      if (Number.isInteger(seconds)) {
        return seconds > 0 ? seconds * 1000 : -1;
      }
      // https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Retry-After#directives
      var delay = new Date(retryAfter).getTime() - Date.now();
      if (delay >= 0) {
        return delay;
      }
      return 0;
    }

    /*
     * Copyright The OpenTelemetry Authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      https://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    var __read$4 = undefined && undefined.__read || function (o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m) return o;
      var i = m.call(o),
        r,
        ar = [],
        e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
      } catch (error) {
        e = {
          error: error
        };
      } finally {
        try {
          if (r && !r.done && (m = i["return"])) m.call(i);
        } finally {
          if (e) throw e.error;
        }
      }
      return ar;
    };
    var XhrTransport = /** @class */function () {
      function XhrTransport(_parameters) {
        this._parameters = _parameters;
      }
      XhrTransport.prototype.send = function (data, timeoutMillis) {
        var _this = this;
        return new Promise(function (resolve) {
          var xhr = new XMLHttpRequest();
          xhr.timeout = timeoutMillis;
          xhr.open('POST', _this._parameters.url);
          var headers = _this._parameters.headers();
          Object.entries(headers).forEach(function (_a) {
            var _b = __read$4(_a, 2),
              k = _b[0],
              v = _b[1];
            xhr.setRequestHeader(k, v);
          });
          xhr.ontimeout = function (_) {
            resolve({
              status: 'failure',
              error: new Error('XHR request timed out')
            });
          };
          xhr.onreadystatechange = function () {
            if (xhr.status >= 200 && xhr.status <= 299) {
              diag.debug('XHR success');
              resolve({
                status: 'success'
              });
            } else if (xhr.status && isExportRetryable(xhr.status)) {
              resolve({
                status: 'retryable',
                retryInMillis: parseRetryAfterToMills(xhr.getResponseHeader('Retry-After'))
              });
            } else if (xhr.status !== 0) {
              resolve({
                status: 'failure',
                error: new Error('XHR request failed with non-retryable status')
              });
            }
          };
          xhr.onabort = function () {
            resolve({
              status: 'failure',
              error: new Error('XHR request aborted')
            });
          };
          xhr.onerror = function () {
            resolve({
              status: 'failure',
              error: new Error('XHR request errored')
            });
          };
          xhr.send(data);
        });
      };
      XhrTransport.prototype.shutdown = function () {
        // Intentionally left empty, nothing to do.
      };
      return XhrTransport;
    }();
    /**
     * Creates an exporter transport that uses XHR to send the data
     * @param parameters applied to each request made by transport
     */
    function createXhrTransport(parameters) {
      return new XhrTransport(parameters);
    }

    /*
     * Copyright The OpenTelemetry Authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      https://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    var SendBeaconTransport = /** @class */function () {
      function SendBeaconTransport(_params) {
        this._params = _params;
      }
      SendBeaconTransport.prototype.send = function (data) {
        var _this = this;
        return new Promise(function (resolve) {
          if (navigator.sendBeacon(_this._params.url, new Blob([data], {
            type: _this._params.blobType
          }))) {
            // no way to signal retry, treat everything as success
            diag.debug('SendBeacon success');
            resolve({
              status: 'success'
            });
          } else {
            resolve({
              status: 'failure',
              error: new Error('SendBeacon failed')
            });
          }
        });
      };
      SendBeaconTransport.prototype.shutdown = function () {
        // Intentionally left empty, nothing to do.
      };
      return SendBeaconTransport;
    }();
    function createSendBeaconTransport(parameters) {
      return new SendBeaconTransport(parameters);
    }

    function createOtlpXhrExportDelegate(options, serializer) {
      return createOtlpNetworkExportDelegate(options, serializer, createRetryingTransport({
        transport: createXhrTransport(options)
      }));
    }
    function createOtlpSendBeaconExportDelegate(options, serializer) {
      return createOtlpNetworkExportDelegate(options, serializer, createRetryingTransport({
        transport: createSendBeaconTransport({
          url: options.url,
          blobType: options.headers()['Content-Type']
        })
      }));
    }

    /*
     * Copyright The OpenTelemetry Authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      https://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    var __read$3 = undefined && undefined.__read || function (o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m) return o;
      var i = m.call(o),
        r,
        ar = [],
        e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
      } catch (error) {
        e = {
          error: error
        };
      } finally {
        try {
          if (r && !r.done && (m = i["return"])) m.call(i);
        } finally {
          if (e) throw e.error;
        }
      }
      return ar;
    };
    /**
     * Parses headers from config leaving only those that have defined values
     * @param partialHeaders
     */
    function validateAndNormalizeHeaders(partialHeaders) {
      return function () {
        var _a;
        var headers = {};
        Object.entries((_a = partialHeaders === null || partialHeaders === void 0 ? void 0 : partialHeaders()) !== null && _a !== void 0 ? _a : {}).forEach(function (_a) {
          var _b = __read$3(_a, 2),
            key = _b[0],
            value = _b[1];
          if (typeof value !== 'undefined') {
            headers[key] = String(value);
          } else {
            diag.warn("Header \"" + key + "\" has invalid value (" + value + ") and will be ignored");
          }
        });
        return headers;
      };
    }

    /*
     * Copyright The OpenTelemetry Authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      https://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    var __assign = undefined && undefined.__assign || function () {
      __assign = Object.assign || function (t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
      };
      return __assign.apply(this, arguments);
    };
    function mergeHeaders(userProvidedHeaders, fallbackHeaders, defaultHeaders) {
      var requiredHeaders = __assign({}, defaultHeaders());
      var headers = {};
      return function () {
        // add fallback ones first
        if (fallbackHeaders != null) {
          Object.assign(headers, fallbackHeaders());
        }
        // override with user-provided ones
        if (userProvidedHeaders != null) {
          Object.assign(headers, userProvidedHeaders());
        }
        // override required ones.
        return Object.assign(headers, requiredHeaders);
      };
    }
    function validateUserProvidedUrl(url) {
      if (url == null) {
        return undefined;
      }
      try {
        new URL(url);
        return url;
      } catch (e) {
        throw new Error("Configuration: Could not parse user-provided export URL: '" + url + "'");
      }
    }
    /**
     * @param userProvidedConfiguration  Configuration options provided by the user in code.
     * @param fallbackConfiguration Fallback to use when the {@link userProvidedConfiguration} does not specify an option.
     * @param defaultConfiguration The defaults as defined by the exporter specification
     */
    function mergeOtlpHttpConfigurationWithDefaults(userProvidedConfiguration, fallbackConfiguration, defaultConfiguration) {
      var _a, _b, _c, _d;
      return __assign(__assign({}, mergeOtlpSharedConfigurationWithDefaults(userProvidedConfiguration, fallbackConfiguration, defaultConfiguration)), {
        headers: mergeHeaders(validateAndNormalizeHeaders(userProvidedConfiguration.headers), fallbackConfiguration.headers, defaultConfiguration.headers),
        url: (_b = (_a = validateUserProvidedUrl(userProvidedConfiguration.url)) !== null && _a !== void 0 ? _a : fallbackConfiguration.url) !== null && _b !== void 0 ? _b : defaultConfiguration.url,
        agentOptions: (_d = (_c = userProvidedConfiguration.agentOptions) !== null && _c !== void 0 ? _c : fallbackConfiguration.agentOptions) !== null && _d !== void 0 ? _d : defaultConfiguration.agentOptions
      });
    }
    function getHttpConfigurationDefaults(requiredHeaders, signalResourcePath) {
      return __assign(__assign({}, getSharedConfigurationDefaults()), {
        headers: function () {
          return requiredHeaders;
        },
        url: 'http://localhost:4318/' + signalResourcePath,
        agentOptions: {
          keepAlive: true
        }
      });
    }

    /*
     * Copyright The OpenTelemetry Authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      https://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    /**
     * @deprecated this will be removed in 2.0
     *
     * @param config
     * @param signalResourcePath
     * @param requiredHeaders
     */
    function convertLegacyBrowserHttpOptions(config, signalResourcePath, requiredHeaders) {
      return mergeOtlpHttpConfigurationWithDefaults({
        url: config.url,
        timeoutMillis: config.timeoutMillis,
        headers: wrapStaticHeadersInFunction(config.headers),
        concurrencyLimit: config.concurrencyLimit
      }, {},
      // no fallback for browser case
      getHttpConfigurationDefaults(requiredHeaders, signalResourcePath));
    }

    /**
     * @deprecated
     * @param config
     * @param serializer
     * @param signalResourcePath
     * @param requiredHeaders
     */
    function createLegacyOtlpBrowserExportDelegate(config, serializer, signalResourcePath, requiredHeaders) {
      var useXhr = !!config.headers || typeof navigator.sendBeacon !== 'function';
      var options = convertLegacyBrowserHttpOptions(config, signalResourcePath, requiredHeaders);
      if (useXhr) {
        return createOtlpXhrExportDelegate(options, serializer);
      } else {
        return createOtlpSendBeaconExportDelegate(options, serializer);
      }
    }

    /*
     * Copyright The OpenTelemetry Authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      https://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    var __extends$4 = undefined && undefined.__extends || function () {
      var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf || {
          __proto__: []
        } instanceof Array && function (d, b) {
          d.__proto__ = b;
        } || function (d, b) {
          for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
        };
        return extendStatics(d, b);
      };
      return function (d, b) {
        if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    /**
     * Collector Trace Exporter for Web
     */
    var OTLPTraceExporter = /** @class */function (_super) {
      __extends$4(OTLPTraceExporter, _super);
      function OTLPTraceExporter(config) {
        if (config === void 0) {
          config = {};
        }
        return _super.call(this, createLegacyOtlpBrowserExportDelegate(config, JsonTraceSerializer, 'v1/traces', {
          'Content-Type': 'application/json'
        })) || this;
      }
      return OTLPTraceExporter;
    }(OTLPExporterBase);

    var tracekit = {exports: {}};

    /**
     * https://github.com/csnover/TraceKit
     * @license MIT
     * @namespace TraceKit
     */
    var hasRequiredTracekit;
    function requireTracekit() {
      if (hasRequiredTracekit) return tracekit.exports;
      hasRequiredTracekit = 1;
      (function (module) {
        (function (window, undefined$1) {
          if (!window) {
            return;
          }
          var TraceKit = {};
          var _oldTraceKit = window.TraceKit;

          // global reference to slice
          var _slice = [].slice;
          var UNKNOWN_FUNCTION = '?';

          // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error#Error_types
          var ERROR_TYPES_RE = /^(?:[Uu]ncaught (?:exception: )?)?(?:((?:Eval|Internal|Range|Reference|Syntax|Type|URI|)Error): )?(.*)$/;

          /**
           * A better form of hasOwnProperty<br/>
           * Example: `_has(MainHostObject, property) === true/false`
           *
           * @param {Object} object to check property
           * @param {string} key to check
           * @return {Boolean} true if the object has the key and it is not inherited
           */
          function _has(object, key) {
            return Object.prototype.hasOwnProperty.call(object, key);
          }

          /**
           * Returns true if the parameter is undefined<br/>
           * Example: `_isUndefined(val) === true/false`
           *
           * @param {*} what Value to check
           * @return {Boolean} true if undefined and false otherwise
           */
          function _isUndefined(what) {
            return typeof what === 'undefined';
          }

          /**
           * Export TraceKit out to another variable<br/>
           * Example: `var TK = TraceKit.noConflict()`
           * @return {Object} The TraceKit object
           * @memberof TraceKit
           */
          TraceKit.noConflict = function noConflict() {
            window.TraceKit = _oldTraceKit;
            return TraceKit;
          };

          /**
           * Wrap any function in a TraceKit reporter<br/>
           * Example: `func = TraceKit.wrap(func);`
           *
           * @param {Function} func Function to be wrapped
           * @return {Function} The wrapped func
           * @memberof TraceKit
           */
          TraceKit.wrap = function traceKitWrapper(func) {
            function wrapped() {
              try {
                return func.apply(this, arguments);
              } catch (e) {
                TraceKit.report(e);
                throw e;
              }
            }
            return wrapped;
          };

          /**
           * Cross-browser processing of unhandled exceptions
           *
           * Syntax:
           * ```js
           *   TraceKit.report.subscribe(function(stackInfo) { ... })
           *   TraceKit.report.unsubscribe(function(stackInfo) { ... })
           *   TraceKit.report(exception)
           *   try { ...code... } catch(ex) { TraceKit.report(ex); }
           * ```
           *
           * Supports:
           *   - Firefox: full stack trace with line numbers, plus column number
           *     on top frame; column number is not guaranteed
           *   - Opera: full stack trace with line and column numbers
           *   - Chrome: full stack trace with line and column numbers
           *   - Safari: line and column number for the top frame only; some frames
           *     may be missing, and column number is not guaranteed
           *   - IE: line and column number for the top frame only; some frames
           *     may be missing, and column number is not guaranteed
           *
           * In theory, TraceKit should work on all of the following versions:
           *   - IE5.5+ (only 8.0 tested)
           *   - Firefox 0.9+ (only 3.5+ tested)
           *   - Opera 7+ (only 10.50 tested; versions 9 and earlier may require
           *     Exceptions Have Stacktrace to be enabled in opera:config)
           *   - Safari 3+ (only 4+ tested)
           *   - Chrome 1+ (only 5+ tested)
           *   - Konqueror 3.5+ (untested)
           *
           * Requires TraceKit.computeStackTrace.
           *
           * Tries to catch all unhandled exceptions and report them to the
           * subscribed handlers. Please note that TraceKit.report will rethrow the
           * exception. This is REQUIRED in order to get a useful stack trace in IE.
           * If the exception does not reach the top of the browser, you will only
           * get a stack trace from the point where TraceKit.report was called.
           *
           * Handlers receive a TraceKit.StackTrace object as described in the
           * TraceKit.computeStackTrace docs.
           *
           * @memberof TraceKit
           * @namespace
           */
          TraceKit.report = function reportModuleWrapper() {
            var handlers = [],
              lastException = null,
              lastExceptionStack = null;

            /**
             * Add a crash handler.
             * @param {Function} handler
             * @memberof TraceKit.report
             */
            function subscribe(handler) {
              installGlobalHandler();
              installGlobalUnhandledRejectionHandler();
              handlers.push(handler);
            }

            /**
             * Remove a crash handler.
             * @param {Function} handler
             * @memberof TraceKit.report
             */
            function unsubscribe(handler) {
              for (var i = handlers.length - 1; i >= 0; --i) {
                if (handlers[i] === handler) {
                  handlers.splice(i, 1);
                }
              }
              if (handlers.length === 0) {
                uninstallGlobalHandler();
                uninstallGlobalUnhandledRejectionHandler();
              }
            }

            /**
             * Dispatch stack information to all handlers.
             * @param {TraceKit.StackTrace} stack
             * @param {boolean} isWindowError Is this a top-level window error?
             * @param {Error=} error The error that's being handled (if available, null otherwise)
             * @memberof TraceKit.report
             * @throws An exception if an error occurs while calling an handler.
             */
            function notifyHandlers(stack, isWindowError, error) {
              var exception = null;
              if (isWindowError && !TraceKit.collectWindowErrors) {
                return;
              }
              for (var i in handlers) {
                if (_has(handlers, i)) {
                  try {
                    handlers[i](stack, isWindowError, error);
                  } catch (inner) {
                    exception = inner;
                  }
                }
              }
              if (exception) {
                throw exception;
              }
            }
            var _oldOnerrorHandler, _onErrorHandlerInstalled;
            var _oldOnunhandledrejectionHandler, _onUnhandledRejectionHandlerInstalled;

            /**
             * Ensures all global unhandled exceptions are recorded.
             * Supported by Gecko and IE.
             * @param {string} message Error message.
             * @param {string} url URL of script that generated the exception.
             * @param {(number|string)} lineNo The line number at which the error occurred.
             * @param {(number|string)=} columnNo The column number at which the error occurred.
             * @param {Error=} errorObj The actual Error object.
             * @memberof TraceKit.report
             */
            function traceKitWindowOnError(message, url, lineNo, columnNo, errorObj) {
              var stack = null;
              if (lastExceptionStack) {
                TraceKit.computeStackTrace.augmentStackTraceWithInitialElement(lastExceptionStack, url, lineNo, message);
                processLastException();
              } else if (errorObj) {
                stack = TraceKit.computeStackTrace(errorObj);
                notifyHandlers(stack, true, errorObj);
              } else {
                var location = {
                  'url': url,
                  'line': lineNo,
                  'column': columnNo
                };
                var name;
                var msg = message; // must be new var or will modify original `arguments`
                if ({}.toString.call(message) === '[object String]') {
                  var groups = message.match(ERROR_TYPES_RE);
                  if (groups) {
                    name = groups[1];
                    msg = groups[2];
                  }
                }
                location.func = TraceKit.computeStackTrace.guessFunctionName(location.url, location.line);
                location.context = TraceKit.computeStackTrace.gatherContext(location.url, location.line);
                stack = {
                  'name': name,
                  'message': msg,
                  'mode': 'onerror',
                  'stack': [location]
                };
                notifyHandlers(stack, true, null);
              }
              if (_oldOnerrorHandler) {
                return _oldOnerrorHandler.apply(this, arguments);
              }
              return false;
            }

            /**
             * Ensures all unhandled rejections are recorded.
             * @param {PromiseRejectionEvent} e event.
             * @memberof TraceKit.report
             * @see https://developer.mozilla.org/en-US/docs/Web/API/WindowEventHandlers/onunhandledrejection
             * @see https://developer.mozilla.org/en-US/docs/Web/API/PromiseRejectionEvent
             */
            function traceKitWindowOnUnhandledRejection(e) {
              var stack = TraceKit.computeStackTrace(e.reason);
              notifyHandlers(stack, true, e.reason);
            }

            /**
             * Install a global onerror handler
             * @memberof TraceKit.report
             */
            function installGlobalHandler() {
              if (_onErrorHandlerInstalled === true) {
                return;
              }
              _oldOnerrorHandler = window.onerror;
              window.onerror = traceKitWindowOnError;
              _onErrorHandlerInstalled = true;
            }

            /**
             * Uninstall the global onerror handler
             * @memberof TraceKit.report
             */
            function uninstallGlobalHandler() {
              if (_onErrorHandlerInstalled) {
                window.onerror = _oldOnerrorHandler;
                _onErrorHandlerInstalled = false;
              }
            }

            /**
             * Install a global onunhandledrejection handler
             * @memberof TraceKit.report
             */
            function installGlobalUnhandledRejectionHandler() {
              if (_onUnhandledRejectionHandlerInstalled === true) {
                return;
              }
              _oldOnunhandledrejectionHandler = window.onunhandledrejection;
              window.onunhandledrejection = traceKitWindowOnUnhandledRejection;
              _onUnhandledRejectionHandlerInstalled = true;
            }

            /**
             * Uninstall the global onunhandledrejection handler
             * @memberof TraceKit.report
             */
            function uninstallGlobalUnhandledRejectionHandler() {
              if (_onUnhandledRejectionHandlerInstalled) {
                window.onunhandledrejection = _oldOnunhandledrejectionHandler;
                _onUnhandledRejectionHandlerInstalled = false;
              }
            }

            /**
             * Process the most recent exception
             * @memberof TraceKit.report
             */
            function processLastException() {
              var _lastExceptionStack = lastExceptionStack,
                _lastException = lastException;
              lastExceptionStack = null;
              lastException = null;
              notifyHandlers(_lastExceptionStack, false, _lastException);
            }

            /**
             * Reports an unhandled Error to TraceKit.
             * @param {Error} ex
             * @memberof TraceKit.report
             * @throws An exception if an incomplete stack trace is detected (old IE browsers).
             */
            function report(ex) {
              if (lastExceptionStack) {
                if (lastException === ex) {
                  return; // already caught by an inner catch block, ignore
                } else {
                  processLastException();
                }
              }
              var stack = TraceKit.computeStackTrace(ex);
              lastExceptionStack = stack;
              lastException = ex;

              // If the stack trace is incomplete, wait for 2 seconds for
              // slow slow IE to see if onerror occurs or not before reporting
              // this exception; otherwise, we will end up with an incomplete
              // stack trace
              setTimeout(function () {
                if (lastException === ex) {
                  processLastException();
                }
              }, stack.incomplete ? 2000 : 0);
              throw ex; // re-throw to propagate to the top level (and cause window.onerror)
            }
            report.subscribe = subscribe;
            report.unsubscribe = unsubscribe;
            return report;
          }();

          /**
           * An object representing a single stack frame.
           * @typedef {Object} StackFrame
           * @property {string} url The JavaScript or HTML file URL.
           * @property {string} func The function name, or empty for anonymous functions (if guessing did not work).
           * @property {string[]?} args The arguments passed to the function, if known.
           * @property {number=} line The line number, if known.
           * @property {number=} column The column number, if known.
           * @property {string[]} context An array of source code lines; the middle element corresponds to the correct line#.
           * @memberof TraceKit
           */

          /**
           * An object representing a JavaScript stack trace.
           * @typedef {Object} StackTrace
           * @property {string} name The name of the thrown exception.
           * @property {string} message The exception error message.
           * @property {TraceKit.StackFrame[]} stack An array of stack frames.
           * @property {string} mode 'stack', 'stacktrace', 'multiline', 'callers', 'onerror', or 'failed' -- method used to collect the stack trace.
           * @memberof TraceKit
           */

          /**
           * TraceKit.computeStackTrace: cross-browser stack traces in JavaScript
           *
           * Syntax:
           *   ```js
           *   s = TraceKit.computeStackTrace.ofCaller([depth])
           *   s = TraceKit.computeStackTrace(exception) // consider using TraceKit.report instead (see below)
           *   ```
           *
           * Supports:
           *   - Firefox:  full stack trace with line numbers and unreliable column
           *               number on top frame
           *   - Opera 10: full stack trace with line and column numbers
           *   - Opera 9-: full stack trace with line numbers
           *   - Chrome:   full stack trace with line and column numbers
           *   - Safari:   line and column number for the topmost stacktrace element
           *               only
           *   - IE:       no line numbers whatsoever
           *
           * Tries to guess names of anonymous functions by looking for assignments
           * in the source code. In IE and Safari, we have to guess source file names
           * by searching for function bodies inside all page scripts. This will not
           * work for scripts that are loaded cross-domain.
           * Here be dragons: some function names may be guessed incorrectly, and
           * duplicate functions may be mismatched.
           *
           * TraceKit.computeStackTrace should only be used for tracing purposes.
           * Logging of unhandled exceptions should be done with TraceKit.report,
           * which builds on top of TraceKit.computeStackTrace and provides better
           * IE support by utilizing the window.onerror event to retrieve information
           * about the top of the stack.
           *
           * Note: In IE and Safari, no stack trace is recorded on the Error object,
           * so computeStackTrace instead walks its *own* chain of callers.
           * This means that:
           *  * in Safari, some methods may be missing from the stack trace;
           *  * in IE, the topmost function in the stack trace will always be the
           *    caller of computeStackTrace.
           *
           * This is okay for tracing (because you are likely to be calling
           * computeStackTrace from the function you want to be the topmost element
           * of the stack trace anyway), but not okay for logging unhandled
           * exceptions (because your catch block will likely be far away from the
           * inner function that actually caused the exception).
           *
           * Tracing example:
           *  ```js
           *     function trace(message) {
           *         var stackInfo = TraceKit.computeStackTrace.ofCaller();
           *         var data = message + "\n";
           *         for(var i in stackInfo.stack) {
           *             var item = stackInfo.stack[i];
           *             data += (item.func || '[anonymous]') + "() in " + item.url + ":" + (item.line || '0') + "\n";
           *         }
           *         if (window.console)
           *             console.info(data);
           *         else
           *             alert(data);
           *     }
           * ```
           * @memberof TraceKit
           * @namespace
           */
          TraceKit.computeStackTrace = function computeStackTraceWrapper() {
            var sourceCache = {};

            /**
             * Attempts to retrieve source code via XMLHttpRequest, which is used
             * to look up anonymous function names.
             * @param {string} url URL of source code.
             * @return {string} Source contents.
             * @memberof TraceKit.computeStackTrace
             */
            function loadSource(url) {
              if (!TraceKit.remoteFetching) {
                //Only attempt request if remoteFetching is on.
                return '';
              }
              try {
                var getXHR = function () {
                  try {
                    return new window.XMLHttpRequest();
                  } catch (e) {
                    // explicitly bubble up the exception if not found
                    return new window.ActiveXObject('Microsoft.XMLHTTP');
                  }
                };
                var request = getXHR();
                request.open('GET', url, false);
                request.send('');
                return request.responseText;
              } catch (e) {
                return '';
              }
            }

            /**
             * Retrieves source code from the source code cache.
             * @param {string} url URL of source code.
             * @return {Array.<string>} Source contents.
             * @memberof TraceKit.computeStackTrace
             */
            function getSource(url) {
              if (typeof url !== 'string') {
                return [];
              }
              if (!_has(sourceCache, url)) {
                // URL needs to be able to fetched within the acceptable domain.  Otherwise,
                // cross-domain errors will be triggered.
                /*
                    Regex matches:
                    0 - Full Url
                    1 - Protocol
                    2 - Domain
                    3 - Port (Useful for internal applications)
                    4 - Path
                */
                var source = '';
                var domain = '';
                try {
                  domain = window.document.domain;
                } catch (e) {}
                var match = /(.*)\:\/\/([^:\/]+)([:\d]*)\/{0,1}([\s\S]*)/.exec(url);
                if (match && match[2] === domain) {
                  source = loadSource(url);
                }
                sourceCache[url] = source ? source.split('\n') : [];
              }
              return sourceCache[url];
            }

            /**
             * Tries to use an externally loaded copy of source code to determine
             * the name of a function by looking at the name of the variable it was
             * assigned to, if any.
             * @param {string} url URL of source code.
             * @param {(string|number)} lineNo Line number in source code.
             * @return {string} The function name, if discoverable.
             * @memberof TraceKit.computeStackTrace
             */
            function guessFunctionName(url, lineNo) {
              var reFunctionArgNames = /function ([^(]*)\(([^)]*)\)/,
                reGuessFunction = /['"]?([0-9A-Za-z$_]+)['"]?\s*[:=]\s*(function|eval|new Function)/,
                line = '',
                maxLines = 10,
                source = getSource(url),
                m;
              if (!source.length) {
                return UNKNOWN_FUNCTION;
              }

              // Walk backwards from the first line in the function until we find the line which
              // matches the pattern above, which is the function definition
              for (var i = 0; i < maxLines; ++i) {
                line = source[lineNo - i] + line;
                if (!_isUndefined(line)) {
                  if (m = reGuessFunction.exec(line)) {
                    return m[1];
                  } else if (m = reFunctionArgNames.exec(line)) {
                    return m[1];
                  }
                }
              }
              return UNKNOWN_FUNCTION;
            }

            /**
             * Retrieves the surrounding lines from where an exception occurred.
             * @param {string} url URL of source code.
             * @param {(string|number)} line Line number in source code to center around for context.
             * @return {?Array.<string>} Lines of source code.
             * @memberof TraceKit.computeStackTrace
             */
            function gatherContext(url, line) {
              var source = getSource(url);
              if (!source.length) {
                return null;
              }
              var context = [],
                // linesBefore & linesAfter are inclusive with the offending line.
                // if linesOfContext is even, there will be one extra line
                //   *before* the offending line.
                linesBefore = Math.floor(TraceKit.linesOfContext / 2),
                // Add one extra line if linesOfContext is odd
                linesAfter = linesBefore + TraceKit.linesOfContext % 2,
                start = Math.max(0, line - linesBefore - 1),
                end = Math.min(source.length, line + linesAfter - 1);
              line -= 1; // convert to 0-based index

              for (var i = start; i < end; ++i) {
                if (!_isUndefined(source[i])) {
                  context.push(source[i]);
                }
              }
              return context.length > 0 ? context : null;
            }

            /**
             * Escapes special characters, except for whitespace, in a string to be
             * used inside a regular expression as a string literal.
             * @param {string} text The string.
             * @return {string} The escaped string literal.
             * @memberof TraceKit.computeStackTrace
             */
            function escapeRegExp(text) {
              return text.replace(/[\-\[\]{}()*+?.,\\\^$|#]/g, '\\$&');
            }

            /**
             * Escapes special characters in a string to be used inside a regular
             * expression as a string literal. Also ensures that HTML entities will
             * be matched the same as their literal friends.
             * @param {string} body The string.
             * @return {string} The escaped string.
             * @memberof TraceKit.computeStackTrace
             */
            function escapeCodeAsRegExpForMatchingInsideHTML(body) {
              return escapeRegExp(body).replace('<', '(?:<|&lt;)').replace('>', '(?:>|&gt;)').replace('&', '(?:&|&amp;)').replace('"', '(?:"|&quot;)').replace(/\s+/g, '\\s+');
            }

            /**
             * Determines where a code fragment occurs in the source code.
             * @param {RegExp} re The function definition.
             * @param {Array.<string>} urls A list of URLs to search.
             * @return {?Object.<string, (string|number)>} An object containing
             * the url, line, and column number of the defined function.
             * @memberof TraceKit.computeStackTrace
             */
            function findSourceInUrls(re, urls) {
              var source, m;
              for (var i = 0, j = urls.length; i < j; ++i) {
                if ((source = getSource(urls[i])).length) {
                  source = source.join('\n');
                  if (m = re.exec(source)) {
                    return {
                      'url': urls[i],
                      'line': source.substring(0, m.index).split('\n').length,
                      'column': m.index - source.lastIndexOf('\n', m.index) - 1
                    };
                  }
                }
              }
              return null;
            }

            /**
             * Determines at which column a code fragment occurs on a line of the
             * source code.
             * @param {string} fragment The code fragment.
             * @param {string} url The URL to search.
             * @param {(string|number)} line The line number to examine.
             * @return {?number} The column number.
             * @memberof TraceKit.computeStackTrace
             */
            function findSourceInLine(fragment, url, line) {
              var source = getSource(url),
                re = new RegExp('\\b' + escapeRegExp(fragment) + '\\b'),
                m;
              line -= 1;
              if (source && source.length > line && (m = re.exec(source[line]))) {
                return m.index;
              }
              return null;
            }

            /**
             * Determines where a function was defined within the source code.
             * @param {(Function|string)} func A function reference or serialized
             * function definition.
             * @return {?Object.<string, (string|number)>} An object containing
             * the url, line, and column number of the defined function.
             * @memberof TraceKit.computeStackTrace
             */
            function findSourceByFunctionBody(func) {
              if (_isUndefined(window && window.document)) {
                return;
              }
              var urls = [window.location.href],
                scripts = window.document.getElementsByTagName('script'),
                body,
                code = '' + func,
                codeRE = /^function(?:\s+([\w$]+))?\s*\(([\w\s,]*)\)\s*\{\s*(\S[\s\S]*\S)\s*\}\s*$/,
                eventRE = /^function on([\w$]+)\s*\(event\)\s*\{\s*(\S[\s\S]*\S)\s*\}\s*$/,
                re,
                parts,
                result;
              for (var i = 0; i < scripts.length; ++i) {
                var script = scripts[i];
                if (script.src) {
                  urls.push(script.src);
                }
              }
              if (!(parts = codeRE.exec(code))) {
                re = new RegExp(escapeRegExp(code).replace(/\s+/g, '\\s+'));
              }

              // not sure if this is really necessary, but I dont have a test
              // corpus large enough to confirm that and it was in the original.
              else {
                var name = parts[1] ? '\\s+' + parts[1] : '',
                  args = parts[2].split(',').join('\\s*,\\s*');
                body = escapeRegExp(parts[3]).replace(/;$/, ';?'); // semicolon is inserted if the function ends with a comment.replace(/\s+/g, '\\s+');
                re = new RegExp('function' + name + '\\s*\\(\\s*' + args + '\\s*\\)\\s*{\\s*' + body + '\\s*}');
              }

              // look for a normal function definition
              if (result = findSourceInUrls(re, urls)) {
                return result;
              }

              // look for an old-school event handler function
              if (parts = eventRE.exec(code)) {
                var event = parts[1];
                body = escapeCodeAsRegExpForMatchingInsideHTML(parts[2]);

                // look for a function defined in HTML as an onXXX handler
                re = new RegExp('on' + event + '=[\\\'"]\\s*' + body + '\\s*[\\\'"]', 'i');
                if (result = findSourceInUrls(re, urls[0])) {
                  return result;
                }

                // look for ???
                re = new RegExp(body);
                if (result = findSourceInUrls(re, urls)) {
                  return result;
                }
              }
              return null;
            }

            // Contents of Exception in various browsers.
            //
            // SAFARI:
            // ex.message = Can't find variable: qq
            // ex.line = 59
            // ex.sourceId = 580238192
            // ex.sourceURL = http://...
            // ex.expressionBeginOffset = 96
            // ex.expressionCaretOffset = 98
            // ex.expressionEndOffset = 98
            // ex.name = ReferenceError
            //
            // FIREFOX:
            // ex.message = qq is not defined
            // ex.fileName = http://...
            // ex.lineNumber = 59
            // ex.columnNumber = 69
            // ex.stack = ...stack trace... (see the example below)
            // ex.name = ReferenceError
            //
            // CHROME:
            // ex.message = qq is not defined
            // ex.name = ReferenceError
            // ex.type = not_defined
            // ex.arguments = ['aa']
            // ex.stack = ...stack trace...
            //
            // INTERNET EXPLORER:
            // ex.message = ...
            // ex.name = ReferenceError
            //
            // OPERA:
            // ex.message = ...message... (see the example below)
            // ex.name = ReferenceError
            // ex.opera#sourceloc = 11  (pretty much useless, duplicates the info in ex.message)
            // ex.stacktrace = n/a; see 'opera:config#UserPrefs|Exceptions Have Stacktrace'

            /**
             * Computes stack trace information from the stack property.
             * Chrome and Gecko use this property.
             * @param {Error} ex
             * @return {?TraceKit.StackTrace} Stack trace information.
             * @memberof TraceKit.computeStackTrace
             */
            function computeStackTraceFromStackProp(ex) {
              if (!ex.stack) {
                return null;
              }
              var chrome = /^\s*at (.*?) ?\(((?:file|https?|blob|chrome-extension|native|eval|webpack|<anonymous>|\/).*?)(?::(\d+))?(?::(\d+))?\)?\s*$/i,
                gecko = /^\s*(.*?)(?:\((.*?)\))?(?:^|@)((?:file|https?|blob|chrome|webpack|resource|\[native).*?|[^@]*bundle)(?::(\d+))?(?::(\d+))?\s*$/i,
                winjs = /^\s*at (?:((?:\[object object\])?.+) )?\(?((?:file|ms-appx|https?|webpack|blob):.*?):(\d+)(?::(\d+))?\)?\s*$/i,
                // Used to additionally parse URL/line/column from eval frames
                isEval,
                geckoEval = /(\S+) line (\d+)(?: > eval line \d+)* > eval/i,
                chromeEval = /\((\S*)(?::(\d+))(?::(\d+))\)/,
                lines = ex.stack.split('\n'),
                stack = [],
                submatch,
                parts,
                element,
                reference = /^(.*) is undefined$/.exec(ex.message);
              for (var i = 0, j = lines.length; i < j; ++i) {
                if (parts = chrome.exec(lines[i])) {
                  var isNative = parts[2] && parts[2].indexOf('native') === 0; // start of line
                  isEval = parts[2] && parts[2].indexOf('eval') === 0; // start of line
                  if (isEval && (submatch = chromeEval.exec(parts[2]))) {
                    // throw out eval line/column and use top-most line/column number
                    parts[2] = submatch[1]; // url
                    parts[3] = submatch[2]; // line
                    parts[4] = submatch[3]; // column
                  }
                  element = {
                    'url': !isNative ? parts[2] : null,
                    'func': parts[1] || UNKNOWN_FUNCTION,
                    'args': isNative ? [parts[2]] : [],
                    'line': parts[3] ? +parts[3] : null,
                    'column': parts[4] ? +parts[4] : null
                  };
                } else if (parts = winjs.exec(lines[i])) {
                  element = {
                    'url': parts[2],
                    'func': parts[1] || UNKNOWN_FUNCTION,
                    'args': [],
                    'line': +parts[3],
                    'column': parts[4] ? +parts[4] : null
                  };
                } else if (parts = gecko.exec(lines[i])) {
                  isEval = parts[3] && parts[3].indexOf(' > eval') > -1;
                  if (isEval && (submatch = geckoEval.exec(parts[3]))) {
                    // throw out eval line/column and use top-most line number
                    parts[3] = submatch[1];
                    parts[4] = submatch[2];
                    parts[5] = null; // no column when eval
                  } else if (i === 0 && !parts[5] && !_isUndefined(ex.columnNumber)) {
                    // FireFox uses this awesome columnNumber property for its top frame
                    // Also note, Firefox's column number is 0-based and everything else expects 1-based,
                    // so adding 1
                    // NOTE: this hack doesn't work if top-most frame is eval
                    stack[0].column = ex.columnNumber + 1;
                  }
                  element = {
                    'url': parts[3],
                    'func': parts[1] || UNKNOWN_FUNCTION,
                    'args': parts[2] ? parts[2].split(',') : [],
                    'line': parts[4] ? +parts[4] : null,
                    'column': parts[5] ? +parts[5] : null
                  };
                } else {
                  continue;
                }
                if (!element.func && element.line) {
                  element.func = guessFunctionName(element.url, element.line);
                }
                element.context = element.line ? gatherContext(element.url, element.line) : null;
                stack.push(element);
              }
              if (!stack.length) {
                return null;
              }
              if (stack[0] && stack[0].line && !stack[0].column && reference) {
                stack[0].column = findSourceInLine(reference[1], stack[0].url, stack[0].line);
              }
              return {
                'mode': 'stack',
                'name': ex.name,
                'message': ex.message,
                'stack': stack
              };
            }

            /**
             * Computes stack trace information from the stacktrace property.
             * Opera 10+ uses this property.
             * @param {Error} ex
             * @return {?TraceKit.StackTrace} Stack trace information.
             * @memberof TraceKit.computeStackTrace
             */
            function computeStackTraceFromStacktraceProp(ex) {
              // Access and store the stacktrace property before doing ANYTHING
              // else to it because Opera is not very good at providing it
              // reliably in other circumstances.
              var stacktrace = ex.stacktrace;
              if (!stacktrace) {
                return;
              }
              var opera10Regex = / line (\d+).*script (?:in )?(\S+)(?:: in function (\S+))?$/i,
                opera11Regex = / line (\d+), column (\d+)\s*(?:in (?:<anonymous function: ([^>]+)>|([^\)]+))\((.*)\))? in (.*):\s*$/i,
                lines = stacktrace.split('\n'),
                stack = [],
                parts;
              for (var line = 0; line < lines.length; line += 2) {
                var element = null;
                if (parts = opera10Regex.exec(lines[line])) {
                  element = {
                    'url': parts[2],
                    'line': +parts[1],
                    'column': null,
                    'func': parts[3],
                    'args': []
                  };
                } else if (parts = opera11Regex.exec(lines[line])) {
                  element = {
                    'url': parts[6],
                    'line': +parts[1],
                    'column': +parts[2],
                    'func': parts[3] || parts[4],
                    'args': parts[5] ? parts[5].split(',') : []
                  };
                }
                if (element) {
                  if (!element.func && element.line) {
                    element.func = guessFunctionName(element.url, element.line);
                  }
                  if (element.line) {
                    try {
                      element.context = gatherContext(element.url, element.line);
                    } catch (exc) {}
                  }
                  if (!element.context) {
                    element.context = [lines[line + 1]];
                  }
                  stack.push(element);
                }
              }
              if (!stack.length) {
                return null;
              }
              return {
                'mode': 'stacktrace',
                'name': ex.name,
                'message': ex.message,
                'stack': stack
              };
            }

            /**
             * NOT TESTED.
             * Computes stack trace information from an error message that includes
             * the stack trace.
             * Opera 9 and earlier use this method if the option to show stack
             * traces is turned on in opera:config.
             * @param {Error} ex
             * @return {?TraceKit.StackTrace} Stack information.
             * @memberof TraceKit.computeStackTrace
             */
            function computeStackTraceFromOperaMultiLineMessage(ex) {
              // TODO: Clean this function up
              // Opera includes a stack trace into the exception message. An example is:
              //
              // Statement on line 3: Undefined variable: undefinedFunc
              // Backtrace:
              //   Line 3 of linked script file://localhost/Users/andreyvit/Projects/TraceKit/javascript-client/sample.js: In function zzz
              //         undefinedFunc(a);
              //   Line 7 of inline#1 script in file://localhost/Users/andreyvit/Projects/TraceKit/javascript-client/sample.html: In function yyy
              //           zzz(x, y, z);
              //   Line 3 of inline#1 script in file://localhost/Users/andreyvit/Projects/TraceKit/javascript-client/sample.html: In function xxx
              //           yyy(a, a, a);
              //   Line 1 of function script
              //     try { xxx('hi'); return false; } catch(ex) { TraceKit.report(ex); }
              //   ...

              var lines = ex.message.split('\n');
              if (lines.length < 4) {
                return null;
              }
              var lineRE1 = /^\s*Line (\d+) of linked script ((?:file|https?|blob)\S+)(?:: in function (\S+))?\s*$/i,
                lineRE2 = /^\s*Line (\d+) of inline#(\d+) script in ((?:file|https?|blob)\S+)(?:: in function (\S+))?\s*$/i,
                lineRE3 = /^\s*Line (\d+) of function script\s*$/i,
                stack = [],
                scripts = window && window.document && window.document.getElementsByTagName('script'),
                inlineScriptBlocks = [],
                parts;
              for (var s in scripts) {
                if (_has(scripts, s) && !scripts[s].src) {
                  inlineScriptBlocks.push(scripts[s]);
                }
              }
              for (var line = 2; line < lines.length; line += 2) {
                var item = null;
                if (parts = lineRE1.exec(lines[line])) {
                  item = {
                    'url': parts[2],
                    'func': parts[3],
                    'args': [],
                    'line': +parts[1],
                    'column': null
                  };
                } else if (parts = lineRE2.exec(lines[line])) {
                  item = {
                    'url': parts[3],
                    'func': parts[4],
                    'args': [],
                    'line': +parts[1],
                    'column': null // TODO: Check to see if inline#1 (+parts[2]) points to the script number or column number.
                  };
                  var relativeLine = +parts[1]; // relative to the start of the <SCRIPT> block
                  var script = inlineScriptBlocks[parts[2] - 1];
                  if (script) {
                    var source = getSource(item.url);
                    if (source) {
                      source = source.join('\n');
                      var pos = source.indexOf(script.innerText);
                      if (pos >= 0) {
                        item.line = relativeLine + source.substring(0, pos).split('\n').length;
                      }
                    }
                  }
                } else if (parts = lineRE3.exec(lines[line])) {
                  var url = window.location.href.replace(/#.*$/, '');
                  var re = new RegExp(escapeCodeAsRegExpForMatchingInsideHTML(lines[line + 1]));
                  var src = findSourceInUrls(re, [url]);
                  item = {
                    'url': url,
                    'func': '',
                    'args': [],
                    'line': src ? src.line : parts[1],
                    'column': null
                  };
                }
                if (item) {
                  if (!item.func) {
                    item.func = guessFunctionName(item.url, item.line);
                  }
                  var context = gatherContext(item.url, item.line);
                  var midline = context ? context[Math.floor(context.length / 2)] : null;
                  if (context && midline.replace(/^\s*/, '') === lines[line + 1].replace(/^\s*/, '')) {
                    item.context = context;
                  } else {
                    // if (context) alert("Context mismatch. Correct midline:\n" + lines[i+1] + "\n\nMidline:\n" + midline + "\n\nContext:\n" + context.join("\n") + "\n\nURL:\n" + item.url);
                    item.context = [lines[line + 1]];
                  }
                  stack.push(item);
                }
              }
              if (!stack.length) {
                return null; // could not parse multiline exception message as Opera stack trace
              }
              return {
                'mode': 'multiline',
                'name': ex.name,
                'message': lines[0],
                'stack': stack
              };
            }

            /**
             * Adds information about the first frame to incomplete stack traces.
             * Safari and IE require this to get complete data on the first frame.
             * @param {TraceKit.StackTrace} stackInfo Stack trace information from
             * one of the compute* methods.
             * @param {string} url The URL of the script that caused an error.
             * @param {(number|string)} lineNo The line number of the script that
             * caused an error.
             * @param {string=} message The error generated by the browser, which
             * hopefully contains the name of the object that caused the error.
             * @return {boolean} Whether or not the stack information was
             * augmented.
             * @memberof TraceKit.computeStackTrace
             */
            function augmentStackTraceWithInitialElement(stackInfo, url, lineNo, message) {
              var initial = {
                'url': url,
                'line': lineNo
              };
              if (initial.url && initial.line) {
                stackInfo.incomplete = false;
                if (!initial.func) {
                  initial.func = guessFunctionName(initial.url, initial.line);
                }
                if (!initial.context) {
                  initial.context = gatherContext(initial.url, initial.line);
                }
                var reference = / '([^']+)' /.exec(message);
                if (reference) {
                  initial.column = findSourceInLine(reference[1], initial.url, initial.line);
                }
                if (stackInfo.stack.length > 0) {
                  if (stackInfo.stack[0].url === initial.url) {
                    if (stackInfo.stack[0].line === initial.line) {
                      return false; // already in stack trace
                    } else if (!stackInfo.stack[0].line && stackInfo.stack[0].func === initial.func) {
                      stackInfo.stack[0].line = initial.line;
                      stackInfo.stack[0].context = initial.context;
                      return false;
                    }
                  }
                }
                stackInfo.stack.unshift(initial);
                stackInfo.partial = true;
                return true;
              } else {
                stackInfo.incomplete = true;
              }
              return false;
            }

            /**
             * Computes stack trace information by walking the arguments.caller
             * chain at the time the exception occurred. This will cause earlier
             * frames to be missed but is the only way to get any stack trace in
             * Safari and IE. The top frame is restored by
             * {@link augmentStackTraceWithInitialElement}.
             * @param {Error} ex
             * @return {TraceKit.StackTrace=} Stack trace information.
             * @memberof TraceKit.computeStackTrace
             */
            function computeStackTraceByWalkingCallerChain(ex, depth) {
              var functionName = /function\s+([_$a-zA-Z\xA0-\uFFFF][_$a-zA-Z0-9\xA0-\uFFFF]*)?\s*\(/i,
                stack = [],
                funcs = {},
                recursion = false,
                parts,
                item,
                source;
              for (var curr = computeStackTraceByWalkingCallerChain.caller; curr && !recursion; curr = curr.caller) {
                if (curr === computeStackTrace || curr === TraceKit.report) {
                  continue;
                }
                item = {
                  'url': null,
                  'func': UNKNOWN_FUNCTION,
                  'args': [],
                  'line': null,
                  'column': null
                };
                if (curr.name) {
                  item.func = curr.name;
                } else if (parts = functionName.exec(curr.toString())) {
                  item.func = parts[1];
                }
                if (typeof item.func === 'undefined') {
                  try {
                    item.func = parts.input.substring(0, parts.input.indexOf('{'));
                  } catch (e) {}
                }
                if (source = findSourceByFunctionBody(curr)) {
                  item.url = source.url;
                  item.line = source.line;
                  if (item.func === UNKNOWN_FUNCTION) {
                    item.func = guessFunctionName(item.url, item.line);
                  }
                  var reference = / '([^']+)' /.exec(ex.message || ex.description);
                  if (reference) {
                    item.column = findSourceInLine(reference[1], source.url, source.line);
                  }
                }
                if (funcs['' + curr]) {
                  recursion = true;
                } else {
                  funcs['' + curr] = true;
                }
                stack.push(item);
              }
              if (depth) {
                stack.splice(0, depth);
              }
              var result = {
                'mode': 'callers',
                'name': ex.name,
                'message': ex.message,
                'stack': stack
              };
              augmentStackTraceWithInitialElement(result, ex.sourceURL || ex.fileName, ex.line || ex.lineNumber, ex.message || ex.description);
              return result;
            }

            /**
             * Computes a stack trace for an exception.
             * @param {Error} ex
             * @param {(string|number)=} depth
             * @memberof TraceKit.computeStackTrace
             */
            function computeStackTrace(ex, depth) {
              var stack = null;
              depth = depth == null ? 0 : +depth;
              try {
                // This must be tried first because Opera 10 *destroys*
                // its stacktrace property if you try to access the stack
                // property first!!
                stack = computeStackTraceFromStacktraceProp(ex);
                if (stack) {
                  return stack;
                }
              } catch (e) {
              }
              try {
                stack = computeStackTraceFromStackProp(ex);
                if (stack) {
                  return stack;
                }
              } catch (e) {
              }
              try {
                stack = computeStackTraceFromOperaMultiLineMessage(ex);
                if (stack) {
                  return stack;
                }
              } catch (e) {
              }
              try {
                stack = computeStackTraceByWalkingCallerChain(ex, depth + 1);
                if (stack) {
                  return stack;
                }
              } catch (e) {
              }
              return {
                'name': ex.name,
                'message': ex.message,
                'mode': 'failed'
              };
            }

            /**
             * Logs a stacktrace starting from the previous call and working down.
             * @param {(number|string)=} depth How many frames deep to trace.
             * @return {TraceKit.StackTrace} Stack trace information.
             * @memberof TraceKit.computeStackTrace
             */
            function computeStackTraceOfCaller(depth) {
              depth = (depth == null ? 0 : +depth) + 1; // "+ 1" because "ofCaller" should drop one frame
              try {
                throw new Error();
              } catch (ex) {
                return computeStackTrace(ex, depth + 1);
              }
            }
            computeStackTrace.augmentStackTraceWithInitialElement = augmentStackTraceWithInitialElement;
            computeStackTrace.computeStackTraceFromStackProp = computeStackTraceFromStackProp;
            computeStackTrace.guessFunctionName = guessFunctionName;
            computeStackTrace.gatherContext = gatherContext;
            computeStackTrace.ofCaller = computeStackTraceOfCaller;
            computeStackTrace.getSource = getSource;
            return computeStackTrace;
          }();

          /**
           * Extends support for global error handling for asynchronous browser
           * functions. Adopted from Closure Library's errorhandler.js
           * @memberof TraceKit
           */
          TraceKit.extendToAsynchronousCallbacks = function () {
            var _helper = function _helper(fnName) {
              var originalFn = window[fnName];
              window[fnName] = function traceKitAsyncExtension() {
                // Make a copy of the arguments
                var args = _slice.call(arguments);
                var originalCallback = args[0];
                if (typeof originalCallback === 'function') {
                  args[0] = TraceKit.wrap(originalCallback);
                }
                // IE < 9 doesn't support .call/.apply on setInterval/setTimeout, but it
                // also only supports 2 argument and doesn't care what "this" is, so we
                // can just call the original function directly.
                if (originalFn.apply) {
                  return originalFn.apply(this, args);
                } else {
                  return originalFn(args[0], args[1]);
                }
              };
            };
            _helper('setTimeout');
            _helper('setInterval');
          };

          //Default options:
          if (!TraceKit.remoteFetching) {
            TraceKit.remoteFetching = true;
          }
          if (!TraceKit.collectWindowErrors) {
            TraceKit.collectWindowErrors = true;
          }
          if (!TraceKit.linesOfContext || TraceKit.linesOfContext < 1) {
            // 5 lines before, the offending line, 5 lines after
            TraceKit.linesOfContext = 11;
          }

          // UMD export
          if (module.exports && window.module !== module) {
            module.exports = TraceKit;
          } else {
            window.TraceKit = TraceKit;
          }
        })(typeof window !== 'undefined' ? window : commonjsGlobal);
      })(tracekit);
      return tracekit.exports;
    }

    var tracekitExports = requireTracekit();

    // This code will eventually be packaged upstream into a WebSDK package.
    // Once it is released as a package, this distro will depend directly on the upstream package.
    // https://github.com/open-telemetry/opentelemetry-js/pull/4325
    /*
     * Copyright The OpenTelemetry Authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      https://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    const SESSION_ID_BYTES = 16;
    const SHARED_CHAR_CODES_ARRAY = Array(32);
    class SessionIdSpanProcessor {
      constructor() {
        this._idGenerator = getIdGenerator(SESSION_ID_BYTES);
        this._sessionId = this._idGenerator();
      }
      onStart(span) {
        span.setAttribute('session.id', this._sessionId);
      }
      onEnd() {}
      forceFlush() {
        return Promise.resolve();
      }
      shutdown() {
        return Promise.resolve();
      }
    }
    function getIdGenerator(bytes) {
      return function generateId() {
        for (let i = 0; i < bytes * 2; i++) {
          SHARED_CHAR_CODES_ARRAY[i] = Math.floor(Math.random() * 16) + 48;
          // valid hex characters in the range 48-57 and 97-102
          if (SHARED_CHAR_CODES_ARRAY[i] >= 58) {
            SHARED_CHAR_CODES_ARRAY[i] += 39;
          }
        }
        return String.fromCharCode.apply(null, SHARED_CHAR_CODES_ARRAY.slice(0, bytes * 2));
      };
    }

    // This code will eventually be packaged upstream into a WebSDK package.
    // Once it is released as a package, this distro will depend directly on the upstream package.
    // https://github.com/open-telemetry/opentelemetry-js/pull/4325
    /*
     * Copyright The OpenTelemetry Authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      https://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    /** This class represents everything needed to register a fully configured OpenTelemetry Web SDK */
    class WebSDK {
      /**
       * Create a new Web SDK instance
       */
      constructor(configuration = {}) {
        var _a, _b, _c, _d;
        this._resource = (_a = configuration.resource) !== null && _a !== void 0 ? _a : new Resource({});
        this._resourceDetectors = (_b = configuration.resourceDetectors) !== null && _b !== void 0 ? _b : [browserDetector];
        this._serviceName = configuration.serviceName;
        this._autoDetectResources = (_c = configuration.autoDetectResources) !== null && _c !== void 0 ? _c : true;
        if (configuration.spanProcessor || configuration.traceExporter) {
          const tracerProviderConfig = {};
          if (configuration.sampler) {
            tracerProviderConfig.sampler = configuration.sampler;
          }
          if (configuration.spanLimits) {
            tracerProviderConfig.spanLimits = configuration.spanLimits;
          }
          if (configuration.idGenerator) {
            tracerProviderConfig.idGenerator = configuration.idGenerator;
          }
          const spanProcessor = (_d = configuration.spanProcessor) !== null && _d !== void 0 ? _d : new BatchSpanProcessor(configuration.traceExporter);
          this._tracerProviderConfig = {
            tracerConfig: tracerProviderConfig,
            spanProcessor,
            contextManager: configuration.contextManager,
            textMapPropagator: configuration.textMapPropagator
          };
        }
        let instrumentations = [];
        if (configuration.instrumentations) {
          instrumentations = configuration.instrumentations;
        }
        this._instrumentations = instrumentations;
      }
      /**
       * Call this method to construct SDK components and register them with the OpenTelemetry API.
       */
      start() {
        var _a, _b, _c;
        if (this._disabled) {
          return;
        }
        registerInstrumentations({
          instrumentations: this._instrumentations
        });
        if (this._autoDetectResources) {
          const internalConfig = {
            detectors: this._resourceDetectors
          };
          this._resource = this._resource.merge(detectResourcesSync(internalConfig));
        }
        this._resource = this._serviceName === undefined ? this._resource : this._resource.merge(new Resource({
          [SEMRESATTRS_SERVICE_NAME]: this._serviceName
        }));
        const tracerProvider = new WebTracerProvider(Object.assign(Object.assign({}, (_a = this._tracerProviderConfig) === null || _a === void 0 ? void 0 : _a.tracerConfig), {
          resource: this._resource
        }));
        this._tracerProvider = tracerProvider;
        if (this._tracerProviderConfig) {
          tracerProvider.addSpanProcessor(this._tracerProviderConfig.spanProcessor);
        }
        tracerProvider.register({
          contextManager: (_b = this._tracerProviderConfig) === null || _b === void 0 ? void 0 : _b.contextManager,
          propagator: (_c = this._tracerProviderConfig) === null || _c === void 0 ? void 0 : _c.textMapPropagator
        });
        // add processor for adding the sessionId attribute
        tracerProvider.addSpanProcessor(new SessionIdSpanProcessor());
      }
      /* Experimental getter method: not currently part of the upstream
       * sdk's API */
      getResourceAttributes() {
        return this._resource.attributes;
      }
      shutdown() {
        const promises = [];
        if (this._tracerProvider) {
          promises.push(this._tracerProvider.shutdown());
        }
        return Promise.all(promises)
        // return void instead of the array from Promise.all
        .then(() => {});
      }
    }
    function configureHoneycombResource() {
      return new Resource({
        'honeycomb.distro.version': VERSION$2,
        'honeycomb.distro.runtime_version': 'browser'
      });
    }
    const defaultConfig = {
      path: true,
      hash: true,
      hostname: true,
      referrer: true,
      url: false,
      search: false
    };
    function configureEntryPageResource(config) {
      if (config === false || !(window === null || window === void 0 ? void 0 : window.location)) {
        return new Resource({});
      }
      const options = getOptions(config);
      const {
        href,
        pathname,
        search,
        hash,
        hostname
      } = window.location;
      const attributes = {
        'entry_page.url': optionalAttribute(options.url, href),
        'entry_page.path': optionalAttribute(options.path, pathname),
        'entry_page.search': optionalAttribute(options.search, search),
        'entry_page.hash': optionalAttribute(options.hash, hash),
        'entry_page.hostname': optionalAttribute(options.hostname, hostname),
        'entry_page.referrer': optionalAttribute(options.referrer, document.referrer)
      };
      return new Resource(attributes);
    }
    function getOptions(config) {
      if (!config) {
        return defaultConfig;
      }
      return Object.assign(Object.assign({}, defaultConfig), config);
    }
    function optionalAttribute(shouldInclude, attribute) {
      if (!shouldInclude) {
        return undefined;
      }
      return attribute;
    }
    const computeScreenSize = screenWidth => {
      if (screenWidth <= 768) return 'small';else if (screenWidth > 768 && screenWidth <= 1024) return 'medium';else if (screenWidth > 1024) return 'large';
      return 'unknown';
    };
    const computeNetworkType = networkInformation => {
      var _a;
      return (_a = networkInformation === null || networkInformation === void 0 ? void 0 : networkInformation.effectiveType) !== null && _a !== void 0 ? _a : 'unknown';
    };
    const computeDeviceType = (detectedDeviceType, detectedBrowserName) => {
      // ua-parser-js doesn't fill in device type unless it's in the user agent directly
      // which means that desktops/laptops show up as undefined
      // https://github.com/faisalman/ua-parser-js/issues/182
      //
      // we're going to do this:
      // browser name & device type both undefined -> unknown
      // browser name defined & device type undefined -> desktop
      // device type defined -> use that
      if (!detectedDeviceType && !detectedBrowserName) {
        return 'unknown';
      }
      if (!detectedDeviceType) {
        return 'desktop';
      }
      return detectedDeviceType;
    };
    const computeDeviceProperties = userAgent => {
      const uaParser = new UAParser(userAgent);
      const {
        name: browserName,
        version: browserVersion
      } = uaParser.getBrowser();
      return {
        browserName: browserName !== null && browserName !== void 0 ? browserName : 'unknown',
        browserVersion: browserVersion !== null && browserVersion !== void 0 ? browserVersion : 'unknown',
        deviceType: computeDeviceType(uaParser.getDevice().type, browserName)
      };
    };
    function configureBrowserAttributesResource() {
      const {
        browserName,
        browserVersion,
        deviceType
      } = computeDeviceProperties(navigator.userAgent);
      return new Resource({
        'user_agent.original': navigator.userAgent,
        //https://developer.mozilla.org/en-US/docs/Web/HTTP/Browser_detection_using_the_user_agent#mobile_tablet_or_desktop
        'browser.mobile': navigator.userAgent.includes('Mobi'),
        'browser.touch_screen_enabled': navigator.maxTouchPoints > 0,
        'browser.language': navigator.language,
        'browser.name': browserName,
        'browser.version': browserVersion,
        'device.type': deviceType,
        'network.effectiveType': computeNetworkType(navigator.connection),
        'screen.width': window.screen.width,
        'screen.height': window.screen.height,
        'screen.size': computeScreenSize(window.screen.width)
      });
    }

    /* Takes an array of resources and merges into one mega-resource */
    function mergeResources(resources) {
      let mergedResources = validateResource(resources[0]);
      for (let i = 1; i < resources.length; i++) {
        if (!resources[i]) {
          continue;
        }
        const resource = validateResource(resources[i]);
        mergedResources = mergedResources.merge(resource);
      }
      return mergedResources;
    }
    function validateResource(resource) {
      if (resource instanceof Resource) {
        return resource;
      }
      if (resource) {
        return new Resource(resource);
      }
      return new Resource({});
    }

    // Constants
    const DEFAULT_API_ENDPOINT = 'https://api.honeycomb.io';
    const TRACES_PATH = 'v1/traces';
    const DEFAULT_TRACES_ENDPOINT = `${DEFAULT_API_ENDPOINT}/${TRACES_PATH}`;
    const DEFAULT_SERVICE_NAME = 'unknown_service';
    const DEFAULT_SAMPLE_RATE = 1;
    /**
     * Default options for the Honeycomb Web SDK.
     */
    const defaultOptions = {
      apiKey: '',
      tracesApiKey: '',
      endpoint: DEFAULT_TRACES_ENDPOINT,
      tracesEndpoint: DEFAULT_TRACES_ENDPOINT,
      serviceName: DEFAULT_SERVICE_NAME,
      debug: false,
      sampleRate: 1,
      skipOptionsValidation: false,
      localVisualizations: false,
      webVitalsInstrumentationConfig: {
        enabled: true
      }
    };
    const createHoneycombSDKLogMessage = message => `@honeycombio/opentelemetry-web: ${message}`;
    const classicKeyRegex = /^[a-f0-9]*$/;
    const ingestClassicKeyRegex = /^hc[a-z]ic_[a-z0-9]*$/;
    /**
     * Determines whether the passed in apikey is classic or not.
     *
     * @param apikey the apikey
     * @returns a boolean to indicate if the apikey was a classic key
     */
    function isClassic(apikey) {
      if (apikey == null || apikey.length === 0) {
        return false;
      } else if (apikey.length === 32) {
        return classicKeyRegex.test(apikey);
      } else if (apikey.length === 64) {
        return ingestClassicKeyRegex.test(apikey);
      }
      return false;
    }
    /**
     * Checks for and appends v1/traces to provided URL if missing when using an HTTP
     * based exporter protocol.
     *
     * @param url the base URL to append traces path to if missing
     * @returns the endpoint with traces path appended if missing
     */
    function maybeAppendTracesPath(url) {
      if (url.endsWith(TRACES_PATH) || url.endsWith(`${TRACES_PATH}/`)) {
        return url;
      }
      return url.endsWith('/') ? url + TRACES_PATH : url + '/' + TRACES_PATH;
    }
    const getTracesEndpoint = options => {
      // use `tracesEndpoint` option unchanged if provided
      if (options === null || options === void 0 ? void 0 : options.tracesEndpoint) {
        return options.tracesEndpoint;
      }
      // use `endpoint` option if provided and append '/v1/traces' if not already appended
      if (options === null || options === void 0 ? void 0 : options.endpoint) {
        return maybeAppendTracesPath(options.endpoint);
      }
      return DEFAULT_TRACES_ENDPOINT;
    };
    const getTracesApiKey = options => {
      return (options === null || options === void 0 ? void 0 : options.tracesApiKey) || (options === null || options === void 0 ? void 0 : options.apiKey);
    };
    const getSampleRate = options => {
      if (
      // must be a whole positive integer
      typeof (options === null || options === void 0 ? void 0 : options.sampleRate) === 'number' && Number.isSafeInteger(options === null || options === void 0 ? void 0 : options.sampleRate) && (options === null || options === void 0 ? void 0 : options.sampleRate) >= 0) {
        return options === null || options === void 0 ? void 0 : options.sampleRate;
      }
      return DEFAULT_SAMPLE_RATE;
    };
    const MISSING_API_KEY_ERROR = createHoneycombSDKLogMessage(' Missing API Key. Set `apiKey` in HoneycombOptions. Telemetry will not be exported.');
    const MISSING_SERVICE_NAME_ERROR = createHoneycombSDKLogMessage(` Missing Service Name. Set \`serviceName\` in HoneycombOptions. Defaulting to '${defaultOptions.serviceName}'`);
    const IGNORED_DATASET_ERROR = createHoneycombSDKLogMessage(' Dataset is ignored in favor of service name.');
    const MISSING_DATASET_ERROR = createHoneycombSDKLogMessage(' Missing dataset. Specify either HONEYCOMB_DATASET environment variable or dataset in the options parameter.');
    const SKIPPING_OPTIONS_VALIDATION_MSG = createHoneycombSDKLogMessage(' Skipping options validation. To re-enable, set skipOptionsValidation option or HONEYCOMB_SKIP_OPTIONS_VALIDATION to false.');
    const SAMPLER_OVERRIDE_WARNING = createHoneycombSDKLogMessage(' Default deterministic sampler has been overridden. Honeycomb requires a resource attribute called SampleRate to properly show weighted values. Non-deterministic sampleRate could lead to missing spans in Honeycomb. See our docs for more details. https://docs.honeycomb.io/getting-data-in/opentelemetry/node-distro/#sampling-without-the-honeycomb-sdk');
    const MISSING_FIELDS_FOR_LOCAL_VISUALIZATIONS = createHoneycombSDKLogMessage(' Disabling local visualizations - must have both service name and API key configured.');
    const MISSING_FIELDS_FOR_GENERATING_LINKS = createHoneycombSDKLogMessage(' Disabling local visualizations - cannot infer auth and ui url roots from endpoint url.');
    const FAILED_AUTH_FOR_LOCAL_VISUALIZATIONS = createHoneycombSDKLogMessage(' Failed to get proper auth response from Honeycomb. No local visualization available.');
    const NO_EXPORTERS_DISABLED_DEFAULT = createHoneycombSDKLogMessage(' Default honeycomb exporter disabled but no exporters provided');
    const validateOptionsWarnings = options => {
      var _a;
      const logLevel = (options === null || options === void 0 ? void 0 : options.logLevel) ? options.logLevel : DiagLogLevel.DEBUG;
      if (options === null || options === void 0 ? void 0 : options.skipOptionsValidation) {
        if (logLevel >= DiagLogLevel.DEBUG) {
          console.debug(SKIPPING_OPTIONS_VALIDATION_MSG);
        }
        return;
      }
      // warn if api key is missing
      if (!(options === null || options === void 0 ? void 0 : options.apiKey) && logLevel >= DiagLogLevel.WARN) {
        console.warn(MISSING_API_KEY_ERROR);
      }
      // warn if service name is missing
      if (!(options === null || options === void 0 ? void 0 : options.serviceName) && logLevel >= DiagLogLevel.WARN) {
        console.warn(MISSING_SERVICE_NAME_ERROR);
      }
      // warn if dataset is set while using an environment-aware key
      if ((options === null || options === void 0 ? void 0 : options.apiKey) && !isClassic(options === null || options === void 0 ? void 0 : options.apiKey) && (options === null || options === void 0 ? void 0 : options.dataset) && logLevel >= DiagLogLevel.WARN) {
        console.warn(IGNORED_DATASET_ERROR);
      }
      // warn if dataset is missing if using classic key
      if ((options === null || options === void 0 ? void 0 : options.apiKey) && isClassic(options === null || options === void 0 ? void 0 : options.apiKey) && !(options === null || options === void 0 ? void 0 : options.dataset) && logLevel >= DiagLogLevel.WARN) {
        console.warn(MISSING_DATASET_ERROR);
      }
      // warn if custom sampler provided
      if ((options === null || options === void 0 ? void 0 : options.sampler) && logLevel >= DiagLogLevel.DEBUG) {
        console.debug(SAMPLER_OVERRIDE_WARNING);
      }
      // warn if no exporter will be set
      if ((options === null || options === void 0 ? void 0 : options.disableDefaultTraceExporter) === true && !(options === null || options === void 0 ? void 0 : options.traceExporter) && !((_a = options === null || options === void 0 ? void 0 : options.traceExporters) === null || _a === void 0 ? void 0 : _a.length)) {
        console.warn(NO_EXPORTERS_DISABLED_DEFAULT);
      }
      return options;
    };

    /**
     * Configures the Honeycomb Web SDK to log debug information to the console.
     * Enables the DiagConsoleLogger and sets the log level to DEBUG.
     * Logs the provided Honeycomb options to the console, as well as defaults.
     *
     * @param options the provided Honeycomb options
     */
    function configureDebug(options) {
      if (!(options === null || options === void 0 ? void 0 : options.debug)) {
        return;
      }
      diag.setLogger(new DiagConsoleLogger(), DiagLogLevel.DEBUG);
      diag.debug(createHoneycombSDKLogMessage(' Honeycomb Web SDK Debug Mode Enabled '));
      // traces endpoint must be computed from provided options
      const tracesEndpoint = getTracesEndpoint(options);
      const currentOptions = Object.assign(Object.assign(Object.assign({}, defaultOptions), options), {
        tracesEndpoint
      });
      debugTracesApiKey(currentOptions);
      debugServiceName(currentOptions);
      debugTracesEndpoint(currentOptions);
      debugSampleRate(currentOptions);
    }
    function debugTracesApiKey(options) {
      const tracesApiKey = getTracesApiKey(options) || '';
      if (!tracesApiKey) {
        diag.debug(MISSING_API_KEY_ERROR);
        return;
      }
      diag.debug(createHoneycombSDKLogMessage(`API Key configured for traces: '${tracesApiKey}'`));
    }
    function debugServiceName(options) {
      const serviceName = options.serviceName || defaultOptions.serviceName;
      if (serviceName === defaultOptions.serviceName) {
        diag.debug(MISSING_SERVICE_NAME_ERROR);
        return;
      }
      diag.debug(`@honeycombio/opentelemetry-web: Service Name configured for traces: '${serviceName}'`);
    }
    function debugTracesEndpoint(options) {
      const tracesEndpoint = getTracesEndpoint(options);
      if (!tracesEndpoint) {
        diag.debug(createHoneycombSDKLogMessage('No endpoint configured for traces'));
        return;
      }
      diag.debug(createHoneycombSDKLogMessage(`Endpoint configured for traces: '${tracesEndpoint}'`));
    }
    function debugSampleRate(options) {
      const sampleRate = getSampleRate(options);
      if (!sampleRate) {
        // this should never happen, but guard just in case?
        diag.debug('No sampler configured for traces');
        return;
      }
      diag.debug(createHoneycombSDKLogMessage(`Sample Rate configured for traces: '${sampleRate}'`));
    }

    /**
     * A {@link SpanProcessor} that reads entries stored in {@link Baggage}
     * from the parent context and adds the baggage entries' keys and values
     * to the span as attributes on span start.
     *
     * Keys and values added to Baggage will appear on subsequent child
     * spans for a trace within this service *and* be propagated to external
     * services in accordance with any configured propagation formats
     * configured. If the external services also have a Baggage span
     * processor, the keys and values will appear in those child spans as
     * well.
     *
     *  Warning 
     *
     * Do not put sensitive information in Baggage.
     *
     * To repeat: a consequence of adding data to Baggage is that the keys and
     * values will appear in all outgoing HTTP headers from the application.
     */
    class BaggageSpanProcessor {
      constructor() {}
      onStart(span, parentContext) {
        var _a, _b;
        ((_b = (_a = propagation.getBaggage(parentContext)) === null || _a === void 0 ? void 0 : _a.getAllEntries()) !== null && _b !== void 0 ? _b : []).forEach(entry => {
          span.setAttribute(entry[0], entry[1].value);
          diag.debug(`@honeycombio/opentelemetry-web:  Baggage in all outgoing headers: ${entry[0]}=${entry[1].value} `);
        });
      }
      onEnd() {}
      forceFlush() {
        return Promise.resolve();
      }
      shutdown() {
        return Promise.resolve();
      }
    }

    /**
     * A {@link SpanProcessor} that adds browser specific attributes to each span
     * that might change over the course of a session.
     * Static attributes (e.g. User Agent) are added to the Resource.
     */
    class BrowserAttributesSpanProcessor {
      constructor() {}
      onStart(span) {
        const {
          href,
          pathname,
          search,
          hash,
          hostname
        } = window.location;
        span.setAttributes({
          'browser.width': window.innerWidth,
          'browser.height': window.innerHeight,
          'page.hash': hash,
          'page.url': href,
          'page.route': pathname,
          'page.hostname': hostname,
          'page.search': search,
          'url.path': pathname
        });
      }
      onEnd() {}
      forceFlush() {
        return Promise.resolve();
      }
      shutdown() {
        return Promise.resolve();
      }
    }
    const TEAM_HEADER_KEY = 'x-honeycomb-team';
    const DATASET_HEADER_KEY = 'x-honeycomb-dataset';
    /**
     * Builds and returns an OTLP Traces exporter that sends data over http/json
     * @param options The {@link HoneycombOptions} used to configure the exporter
     * @returns a {@link SpanExporter} configured to send telemetry to Honeycomb over http/json
     */
    function configureHoneycombHttpJsonTraceExporter(options) {
      const apiKey = getTracesApiKey(options);
      return new OTLPTraceExporter({
        url: getTracesEndpoint(options),
        headers: configureHeaders(options, apiKey)
      });
    }
    function configureHeaders(options, apiKey) {
      const headers = Object.assign({}, options === null || options === void 0 ? void 0 : options.headers);
      if (apiKey && !headers[TEAM_HEADER_KEY]) {
        headers[TEAM_HEADER_KEY] = apiKey;
      }
      if (isClassic(apiKey) && (options === null || options === void 0 ? void 0 : options.dataset)) {
        headers[DATASET_HEADER_KEY] = options === null || options === void 0 ? void 0 : options.dataset;
      }
      return headers;
    }

    /**
     * Builds and returns a new {@link SpanExporter} that wraps the provided array
     * of {@link SpanExporter}s
     *
     * @param exporters the exporters to wrap with the composite exporter
     * @returns the configured {@link SpanExporter} instance
     */
    function configureCompositeExporter(exporters) {
      return new CompositeSpanExporter(exporters);
    }
    /**
     * A custom SpanExporter that wraps a number of other exporters and calls export and shutdown
     * for each.
     */
    class CompositeSpanExporter {
      constructor(exporters) {
        this._exporters = exporters;
      }
      export(spans, resultCallback) {
        this._exporters.forEach(exporter => exporter.export(spans, resultCallback));
        resultCallback({
          code: ExportResultCode.SUCCESS
        });
      }
      async shutdown() {
        const results = [];
        this._exporters.forEach(exporter => results.push(exporter.shutdown()));
        await Promise.all(results);
      }
    }

    /**
     * Builds and returns a {@link SpanExporter} that logs Honeycomb URLs for completed traces
     *
     * @remark This is not for production use.
     * @param options The {@link HoneycombOptions} used to configure the exporter
     * @returns the configured {@link ConsoleTraceLinkExporter} instance
     */
    function configureConsoleTraceLinkExporter(options) {
      const apiKey = getTracesApiKey(options);
      const {
        authRoot,
        uiRoot
      } = getUrlRoots((options === null || options === void 0 ? void 0 : options.tracesEndpoint) || getTracesEndpoint(options));
      return new ConsoleTraceLinkExporter(options === null || options === void 0 ? void 0 : options.serviceName, apiKey, options === null || options === void 0 ? void 0 : options.logLevel, authRoot, uiRoot);
    }
    const getUrlRoots = (endpoint = '') => {
      const url = new URL(endpoint);
      const subdomainRegex = /(api)([.|-])?(.*?)(\.?)(honeycomb\.io)(.*)/;
      const matches = subdomainRegex.exec(url.host);
      if (matches === null) {
        return {
          authRoot: undefined,
          uiRoot: undefined
        };
      }
      const isDashSubdomain = matches[2] === '-';
      let apiSubdomain;
      let uiSubdomain;
      if (isDashSubdomain) {
        apiSubdomain = `api-${matches[3]}`;
        uiSubdomain = `ui-${matches[3]}`;
      } else {
        apiSubdomain = matches[3] ? `api.${matches[3]}` : 'api';
        uiSubdomain = matches[3] ? `ui.${matches[3]}` : 'ui';
      }
      const authRoot = `${url.protocol}//${apiSubdomain}.honeycomb.io/1/auth`;
      const uiRoot = `${url.protocol}//${uiSubdomain}.honeycomb.io`;
      return {
        authRoot,
        uiRoot
      };
    };
    /**
     * A custom {@link SpanExporter} that logs Honeycomb URLs for completed traces.
     *
     * @remark This is not for production use.
     */
    class ConsoleTraceLinkExporter {
      constructor(serviceName, apikey, logLevel, authRoot, uiRoot) {
        this._traceUrl = '';
        this._logLevel = DiagLogLevel.DEBUG;
        if (logLevel) {
          this._logLevel = logLevel;
        }
        if (!serviceName || !apikey) {
          if (this._logLevel >= DiagLogLevel.DEBUG) {
            console.debug(MISSING_FIELDS_FOR_LOCAL_VISUALIZATIONS);
          }
          return;
        }
        if (!authRoot || !uiRoot) {
          if (this._logLevel >= DiagLogLevel.DEBUG) {
            console.debug(MISSING_FIELDS_FOR_GENERATING_LINKS);
          }
          return;
        }
        const options = {
          headers: {
            'x-honeycomb-team': apikey
          }
        };
        fetch(authRoot, options).then(resp => {
          if (resp.ok) {
            return resp.json();
          }
          throw new Error();
        }).then(data => {
          var _a, _b, _c;
          const respData = data;
          if ((_a = respData.team) === null || _a === void 0 ? void 0 : _a.slug) {
            this._traceUrl = buildTraceUrl(apikey, serviceName, (_b = respData.team) === null || _b === void 0 ? void 0 : _b.slug, (_c = respData.environment) === null || _c === void 0 ? void 0 : _c.slug, uiRoot);
          } else {
            throw new Error();
          }
        }).catch(() => {
          if (this._logLevel >= DiagLogLevel.INFO) {
            console.log(FAILED_AUTH_FOR_LOCAL_VISUALIZATIONS);
          }
        });
      }
      export(spans, resultCallback) {
        if (this._traceUrl) {
          spans.forEach(span => {
            // only log root spans (ones without a parent span)
            if (!span.parentSpanId && this._logLevel >= DiagLogLevel.INFO) {
              console.log(createHoneycombSDKLogMessage(`Honeycomb link: ${this._traceUrl}=${span.spanContext().traceId}`));
            }
          });
        }
        resultCallback({
          code: ExportResultCode.SUCCESS
        });
      }
      shutdown() {
        return Promise.resolve();
      }
    }
    /**
     * Builds and returns a URL that is used to log when a trace is completed in the {@link ConsoleTraceLinkExporter}.
     *
     * @param apikey the Honeycomb API key used to retrieve the Honeycomb team and environment
     * @param serviceName the Honeycomb service name (or classic dataset) where data is stored
     * @param team the Honeycomb team
     * @param environment the Honeycomb environment
     * @returns
     */
    function buildTraceUrl(apikey, serviceName, team, environment, uiRoot) {
      let url = `${uiRoot}/${team}`;
      if (!isClassic(apikey) && environment) {
        url += `/environments/${environment}`;
      }
      url += `/datasets/${serviceName}/trace?trace_id`;
      return url;
    }

    /**
     * Builds and returns Span Processor that combines the BatchSpanProcessor, BrowserSpanProcessor,
     * BaggageSpanProcessor, and optionally a user provided Span Processor.
     * @param options The {@link HoneycombOptions}
     * @returns a {@link CompositeSpanProcessor}
     */
    const configureSpanProcessors = options => {
      const honeycombSpanProcessor = new CompositeSpanProcessor();
      const honeycombTraceExporters = [];
      if (options === null || options === void 0 ? void 0 : options.localVisualizations) {
        honeycombTraceExporters.push(configureConsoleTraceLinkExporter(options));
      }
      // if there is a user-provided exporter, add to the composite exporter
      if (options === null || options === void 0 ? void 0 : options.traceExporter) {
        honeycombTraceExporters.push(options === null || options === void 0 ? void 0 : options.traceExporter);
      }
      // if there is an array of user-provided exporters, add them to the composite exporter
      // This will override the default honeycomb trace exporter.
      if (options === null || options === void 0 ? void 0 : options.traceExporters) {
        honeycombTraceExporters.push(...options.traceExporters);
      }
      // Disable this if a configuration option is present
      if ((options === null || options === void 0 ? void 0 : options.disableDefaultTraceExporter) !== true) {
        honeycombTraceExporters.unshift(configureHoneycombHttpJsonTraceExporter(options));
      }
      // We have to configure the exporter here because the way the base SDK is setup
      // does not allow having both a `spanProcessor` and `traceExporter` configured.
      honeycombSpanProcessor.addProcessor(new BatchSpanProcessor(configureCompositeExporter([...honeycombTraceExporters])));
      // we always want to add the baggage span processor
      honeycombSpanProcessor.addProcessor(new BaggageSpanProcessor());
      // we always want to add the browser attrs span processor
      honeycombSpanProcessor.addProcessor(new BrowserAttributesSpanProcessor());
      // if there is a user provided span processor, add it to the composite span processor
      if (options === null || options === void 0 ? void 0 : options.spanProcessor) {
        honeycombSpanProcessor.addProcessor(options === null || options === void 0 ? void 0 : options.spanProcessor);
      }
      // if there is an array of spanProcessors provided, add them to the composite span processor
      if (options === null || options === void 0 ? void 0 : options.spanProcessors) {
        options.spanProcessors.forEach(processor => {
          honeycombSpanProcessor.addProcessor(processor);
        });
      }
      return honeycombSpanProcessor;
    };
    /**
     * A {@link SpanProcessor} that combines multiple span processors into a single
     * span processor that can be passed into the SDKs `spanProcessor` option.
     */
    class CompositeSpanProcessor {
      constructor() {
        this.spanProcessors = [];
      }
      addProcessor(processor) {
        this.spanProcessors.push(processor);
      }
      getSpanProcessors() {
        return this.spanProcessors;
      }
      onStart(span, parentContext) {
        this.spanProcessors.forEach(processor => {
          processor.onStart(span, parentContext);
        });
      }
      onEnd(span) {
        this.spanProcessors.forEach(processor => {
          processor.onEnd(span);
        });
      }
      forceFlush() {
        return Promise.all(this.spanProcessors.map(processor => processor.forceFlush())).then(() => {});
      }
      shutdown() {
        return Promise.all(this.spanProcessors.map(processor => processor.forceFlush())).then(() => {});
      }
    }

    /**
     * Builds and returns a Deterministic Sampler that uses the provided sample rate to
     * configure the inner sampler.
     * @param options The {@link HoneycombOptions}
     * @returns a {@link DeterministicSampler}
     */
    const configureDeterministicSampler = options => {
      const sampleRate = getSampleRate(options);
      return new DeterministicSampler(sampleRate);
    };
    /**
     * A {@link Sampler} that uses a deterministic sample rate to configure the sampler.
     */
    class DeterministicSampler {
      constructor(sampleRate) {
        this._sampleRate = sampleRate;
        switch (sampleRate) {
          // sample rate of 0 means send nothing
          case 0:
            this._sampler = new AlwaysOffSampler();
            break;
          // sample rate of 1 is default, send everything
          case 1:
            this._sampler = new AlwaysOnSampler();
            break;
          default:
            {
              const ratio = 1.0 / sampleRate;
              this._sampler = new TraceIdRatioBasedSampler(ratio);
              break;
            }
        }
      }
      shouldSample(context, traceId, spanName, spanKind, attributes, links) {
        const result = this._sampler.shouldSample(context, traceId, spanName, spanKind, attributes, links);
        return Object.assign(Object.assign({}, result), {
          attributes: Object.assign(Object.assign({}, result.attributes), {
            SampleRate: this._sampleRate
          })
        });
      }
      toString() {
        return `DeterministicSampler(${this._sampler.toString()})`;
      }
    }
    var t,
      e,
      n = function () {
        var t = self.performance && performance.getEntriesByType && performance.getEntriesByType("navigation")[0];
        if (t && t.responseStart > 0 && t.responseStart < performance.now()) return t;
      },
      r = function (t) {
        if ("loading" === document.readyState) return "loading";
        var e = n();
        if (e) {
          if (t < e.domInteractive) return "loading";
          if (0 === e.domContentLoadedEventStart || t < e.domContentLoadedEventStart) return "dom-interactive";
          if (0 === e.domComplete || t < e.domComplete) return "dom-content-loaded";
        }
        return "complete";
      },
      i = function (t) {
        var e = t.nodeName;
        return 1 === t.nodeType ? e.toLowerCase() : e.toUpperCase().replace(/^#/, "");
      },
      a = function (t, e) {
        var n = "";
        try {
          for (; t && 9 !== t.nodeType;) {
            var r = t,
              a = r.id ? "#" + r.id : i(r) + (r.classList && r.classList.value && r.classList.value.trim() && r.classList.value.trim().length ? "." + r.classList.value.trim().replace(/\s+/g, ".") : "");
            if (n.length + a.length > (e || 100) - 1) return n || a;
            if (n = n ? a + ">" + n : a, r.id) break;
            t = r.parentNode;
          }
        } catch (t) {}
        return n;
      },
      o = -1,
      c = function () {
        return o;
      },
      u = function (t) {
        addEventListener("pageshow", function (e) {
          e.persisted && (o = e.timeStamp, t(e));
        }, true);
      },
      s = function () {
        var t = n();
        return t && t.activationStart || 0;
      },
      f = function (t, e) {
        var r = n(),
          i = "navigate";
        c() >= 0 ? i = "back-forward-cache" : r && (document.prerendering || s() > 0 ? i = "prerender" : document.wasDiscarded ? i = "restore" : r.type && (i = r.type.replace(/_/g, "-")));
        return {
          name: t,
          value: void 0 === e ? -1 : e,
          rating: "good",
          delta: 0,
          entries: [],
          id: "v4-".concat(Date.now(), "-").concat(Math.floor(8999999999999 * Math.random()) + 1e12),
          navigationType: i
        };
      },
      d = function (t, e, n) {
        try {
          if (PerformanceObserver.supportedEntryTypes.includes(t)) {
            var r = new PerformanceObserver(function (t) {
              Promise.resolve().then(function () {
                e(t.getEntries());
              });
            });
            return r.observe(Object.assign({
              type: t,
              buffered: !0
            }, n || {})), r;
          }
        } catch (t) {}
      },
      l = function (t, e, n, r) {
        var i, a;
        return function (o) {
          e.value >= 0 && (o || r) && ((a = e.value - (i || 0)) || void 0 === i) && (i = e.value, e.delta = a, e.rating = function (t, e) {
            return t > e[1] ? "poor" : t > e[0] ? "needs-improvement" : "good";
          }(e.value, n), t(e));
        };
      },
      m = function (t) {
        requestAnimationFrame(function () {
          return requestAnimationFrame(function () {
            return t();
          });
        });
      },
      p = function (t) {
        document.addEventListener("visibilitychange", function () {
          "hidden" === document.visibilityState && t();
        });
      },
      v = function (t) {
        var e = false;
        return function () {
          e || (t(), e = true);
        };
      },
      g = -1,
      h = function () {
        return "hidden" !== document.visibilityState || document.prerendering ? 1 / 0 : 0;
      },
      T = function (t) {
        "hidden" === document.visibilityState && g > -1 && (g = "visibilitychange" === t.type ? t.timeStamp : 0, E());
      },
      y = function () {
        addEventListener("visibilitychange", T, true), addEventListener("prerenderingchange", T, true);
      },
      E = function () {
        removeEventListener("visibilitychange", T, true), removeEventListener("prerenderingchange", T, true);
      },
      S = function () {
        return g < 0 && (g = h(), y(), u(function () {
          setTimeout(function () {
            g = h(), y();
          }, 0);
        })), {
          get firstHiddenTime() {
            return g;
          }
        };
      },
      b = function (t) {
        document.prerendering ? addEventListener("prerenderingchange", function () {
          return t();
        }, true) : t();
      },
      L = [1800, 3e3],
      C = function (t, e) {
        e = e || {}, b(function () {
          var n,
            r = S(),
            i = f("FCP"),
            a = d("paint", function (t) {
              t.forEach(function (t) {
                "first-contentful-paint" === t.name && (a.disconnect(), t.startTime < r.firstHiddenTime && (i.value = Math.max(t.startTime - s(), 0), i.entries.push(t), n(true)));
              });
            });
          a && (n = l(t, i, L, e.reportAllChanges), u(function (r) {
            i = f("FCP"), n = l(t, i, L, e.reportAllChanges), m(function () {
              i.value = performance.now() - r.timeStamp, n(true);
            });
          }));
        });
      },
      M = [.1, .25],
      D = function (t, e) {
        !function (t, e) {
          e = e || {}, C(v(function () {
            var n,
              r = f("CLS", 0),
              i = 0,
              a = [],
              o = function (t) {
                t.forEach(function (t) {
                  if (!t.hadRecentInput) {
                    var e = a[0],
                      n = a[a.length - 1];
                    i && t.startTime - n.startTime < 1e3 && t.startTime - e.startTime < 5e3 ? (i += t.value, a.push(t)) : (i = t.value, a = [t]);
                  }
                }), i > r.value && (r.value = i, r.entries = a, n());
              },
              c = d("layout-shift", o);
            c && (n = l(t, r, M, e.reportAllChanges), p(function () {
              o(c.takeRecords()), n(true);
            }), u(function () {
              i = 0, r = f("CLS", 0), n = l(t, r, M, e.reportAllChanges), m(function () {
                return n();
              });
            }), setTimeout(n, 0));
          }));
        }(function (e) {
          var n = function (t) {
            var e,
              n = {};
            if (t.entries.length) {
              var i = t.entries.reduce(function (t, e) {
                return t && t.value > e.value ? t : e;
              });
              if (i && i.sources && i.sources.length) {
                var o = (e = i.sources).find(function (t) {
                  return t.node && 1 === t.node.nodeType;
                }) || e[0];
                o && (n = {
                  largestShiftTarget: a(o.node),
                  largestShiftTime: i.startTime,
                  largestShiftValue: i.value,
                  largestShiftSource: o,
                  largestShiftEntry: i,
                  loadState: r(i.startTime)
                });
              }
            }
            return Object.assign(t, {
              attribution: n
            });
          }(e);
          t(n);
        }, e);
      },
      w = function (t, e) {
        C(function (e) {
          var i = function (t) {
            var e = {
              timeToFirstByte: 0,
              firstByteToFCP: t.value,
              loadState: r(c())
            };
            if (t.entries.length) {
              var i = n(),
                a = t.entries[t.entries.length - 1];
              if (i) {
                var o = i.activationStart || 0,
                  u = Math.max(0, i.responseStart - o);
                e = {
                  timeToFirstByte: u,
                  firstByteToFCP: t.value - u,
                  loadState: r(t.entries[0].startTime),
                  navigationEntry: i,
                  fcpEntry: a
                };
              }
            }
            return Object.assign(t, {
              attribution: e
            });
          }(e);
          t(i);
        }, e);
      },
      x = 0,
      I = 1 / 0,
      k = 0,
      A = function (t) {
        t.forEach(function (t) {
          t.interactionId && (I = Math.min(I, t.interactionId), k = Math.max(k, t.interactionId), x = k ? (k - I) / 7 + 1 : 0);
        });
      },
      F = function () {
        return t ? x : performance.interactionCount || 0;
      },
      P = function () {
        "interactionCount" in performance || t || (t = d("event", A, {
          type: "event",
          buffered: true,
          durationThreshold: 0
        }));
      },
      B = [],
      O = new Map(),
      R = 0,
      j = function () {
        var t = Math.min(B.length - 1, Math.floor((F() - R) / 50));
        return B[t];
      },
      q = [],
      H = function (t) {
        if (q.forEach(function (e) {
          return e(t);
        }), t.interactionId || "first-input" === t.entryType) {
          var e = B[B.length - 1],
            n = O.get(t.interactionId);
          if (n || B.length < 10 || t.duration > e.latency) {
            if (n) t.duration > n.latency ? (n.entries = [t], n.latency = t.duration) : t.duration === n.latency && t.startTime === n.entries[0].startTime && n.entries.push(t);else {
              var r = {
                id: t.interactionId,
                latency: t.duration,
                entries: [t]
              };
              O.set(r.id, r), B.push(r);
            }
            B.sort(function (t, e) {
              return e.latency - t.latency;
            }), B.length > 10 && B.splice(10).forEach(function (t) {
              return O.delete(t.id);
            });
          }
        }
      },
      N = function (t) {
        var e = self.requestIdleCallback || self.setTimeout,
          n = -1;
        return t = v(t), "hidden" === document.visibilityState ? t() : (n = e(t), p(t)), n;
      },
      W = [200, 500],
      z = function (t, e) {
        "PerformanceEventTiming" in self && "interactionId" in PerformanceEventTiming.prototype && (e = e || {}, b(function () {
          var n;
          P();
          var r,
            i = f("INP"),
            a = function (t) {
              N(function () {
                t.forEach(H);
                var e = j();
                e && e.latency !== i.value && (i.value = e.latency, i.entries = e.entries, r());
              });
            },
            o = d("event", a, {
              durationThreshold: null !== (n = e.durationThreshold) && void 0 !== n ? n : 40
            });
          r = l(t, i, W, e.reportAllChanges), o && (o.observe({
            type: "first-input",
            buffered: true
          }), p(function () {
            a(o.takeRecords()), r(true);
          }), u(function () {
            R = F(), B.length = 0, O.clear(), i = f("INP"), r = l(t, i, W, e.reportAllChanges);
          }));
        }));
      },
      U = [],
      V = [],
      _ = 0,
      G = new WeakMap(),
      J = new Map(),
      K = -1,
      Q = function (t) {
        U = U.concat(t), X();
      },
      X = function () {
        K < 0 && (K = N(Y));
      },
      Y = function () {
        J.size > 10 && J.forEach(function (t, e) {
          O.has(e) || J.delete(e);
        });
        var t = B.map(function (t) {
            return G.get(t.entries[0]);
          }),
          e = V.length - 50;
        V = V.filter(function (n, r) {
          return r >= e || t.includes(n);
        });
        for (var n = new Set(), r = 0; r < V.length; r++) {
          var i = V[r];
          nt(i.startTime, i.processingEnd).forEach(function (t) {
            n.add(t);
          });
        }
        var a = U.length - 1 - 50;
        U = U.filter(function (t, e) {
          return t.startTime > _ && e > a || n.has(t);
        }), K = -1;
      };
    q.push(function (t) {
      t.interactionId && t.target && !J.has(t.interactionId) && J.set(t.interactionId, t.target);
    }, function (t) {
      var e,
        n = t.startTime + t.duration;
      _ = Math.max(_, t.processingEnd);
      for (var r = V.length - 1; r >= 0; r--) {
        var i = V[r];
        if (Math.abs(n - i.renderTime) <= 8) {
          (e = i).startTime = Math.min(t.startTime, e.startTime), e.processingStart = Math.min(t.processingStart, e.processingStart), e.processingEnd = Math.max(t.processingEnd, e.processingEnd), e.entries.push(t);
          break;
        }
      }
      e || (e = {
        startTime: t.startTime,
        processingStart: t.processingStart,
        processingEnd: t.processingEnd,
        renderTime: n,
        entries: [t]
      }, V.push(e)), (t.interactionId || "first-input" === t.entryType) && G.set(t, e), X();
    });
    var Z,
      $,
      tt,
      et,
      nt = function (t, e) {
        for (var n, r = [], i = 0; n = U[i]; i++) if (!(n.startTime + n.duration < t)) {
          if (n.startTime > e) break;
          r.push(n);
        }
        return r;
      },
      rt = function (t, n) {
        e || (e = d("long-animation-frame", Q)), z(function (e) {
          var n = function (t) {
            var e = t.entries[0],
              n = G.get(e),
              i = e.processingStart,
              o = n.processingEnd,
              c = n.entries.sort(function (t, e) {
                return t.processingStart - e.processingStart;
              }),
              u = nt(e.startTime, o),
              s = t.entries.find(function (t) {
                return t.target;
              }),
              f = s && s.target || J.get(e.interactionId),
              d = [e.startTime + e.duration, o].concat(u.map(function (t) {
                return t.startTime + t.duration;
              })),
              l = Math.max.apply(Math, d),
              m = {
                interactionTarget: a(f),
                interactionTargetElement: f,
                interactionType: e.name.startsWith("key") ? "keyboard" : "pointer",
                interactionTime: e.startTime,
                nextPaintTime: l,
                processedEventEntries: c,
                longAnimationFrameEntries: u,
                inputDelay: i - e.startTime,
                processingDuration: o - i,
                presentationDelay: Math.max(l - o, 0),
                loadState: r(e.startTime)
              };
            return Object.assign(t, {
              attribution: m
            });
          }(e);
          t(n);
        }, n);
      },
      it = [2500, 4e3],
      at = {},
      ot = function (t, e) {
        !function (t, e) {
          e = e || {}, b(function () {
            var n,
              r = S(),
              i = f("LCP"),
              a = function (t) {
                e.reportAllChanges || (t = t.slice(-1)), t.forEach(function (t) {
                  t.startTime < r.firstHiddenTime && (i.value = Math.max(t.startTime - s(), 0), i.entries = [t], n());
                });
              },
              o = d("largest-contentful-paint", a);
            if (o) {
              n = l(t, i, it, e.reportAllChanges);
              var c = v(function () {
                at[i.id] || (a(o.takeRecords()), o.disconnect(), at[i.id] = true, n(true));
              });
              ["keydown", "click"].forEach(function (t) {
                addEventListener(t, function () {
                  return N(c);
                }, {
                  once: true,
                  capture: true
                });
              }), p(c), u(function (r) {
                i = f("LCP"), n = l(t, i, it, e.reportAllChanges), m(function () {
                  i.value = performance.now() - r.timeStamp, at[i.id] = true, n(true);
                });
              });
            }
          });
        }(function (e) {
          var r = function (t) {
            var e = {
              timeToFirstByte: 0,
              resourceLoadDelay: 0,
              resourceLoadDuration: 0,
              elementRenderDelay: t.value
            };
            if (t.entries.length) {
              var r = n();
              if (r) {
                var i = r.activationStart || 0,
                  o = t.entries[t.entries.length - 1],
                  c = o.url && performance.getEntriesByType("resource").filter(function (t) {
                    return t.name === o.url;
                  })[0],
                  u = Math.max(0, r.responseStart - i),
                  s = Math.max(u, c ? (c.requestStart || c.startTime) - i : 0),
                  f = Math.max(s, c ? c.responseEnd - i : 0),
                  d = Math.max(f, o.startTime - i);
                e = {
                  element: a(o.element),
                  timeToFirstByte: u,
                  resourceLoadDelay: s - u,
                  resourceLoadDuration: f - s,
                  elementRenderDelay: d - f,
                  navigationEntry: r,
                  lcpEntry: o
                }, o.url && (e.url = o.url), c && (e.lcpResourceEntry = c);
              }
            }
            return Object.assign(t, {
              attribution: e
            });
          }(e);
          t(r);
        }, e);
      },
      ct = [800, 1800],
      ut = function t(e) {
        document.prerendering ? b(function () {
          return t(e);
        }) : "complete" !== document.readyState ? addEventListener("load", function () {
          return t(e);
        }, true) : setTimeout(e, 0);
      },
      st = function (t, e) {
        e = e || {};
        var r = f("TTFB"),
          i = l(t, r, ct, e.reportAllChanges);
        ut(function () {
          var a = n();
          a && (r.value = Math.max(a.responseStart - s(), 0), r.entries = [a], i(true), u(function () {
            r = f("TTFB", 0), (i = l(t, r, ct, e.reportAllChanges))(true);
          }));
        });
      },
      ft = function (t, e) {
        st(function (e) {
          var n = function (t) {
            var e = {
              waitingDuration: 0,
              cacheDuration: 0,
              dnsDuration: 0,
              connectionDuration: 0,
              requestDuration: 0
            };
            if (t.entries.length) {
              var n = t.entries[0],
                r = n.activationStart || 0,
                i = Math.max((n.workerStart || n.fetchStart) - r, 0),
                a = Math.max(n.domainLookupStart - r, 0),
                o = Math.max(n.connectStart - r, 0),
                c = Math.max(n.connectEnd - r, 0);
              e = {
                waitingDuration: i,
                cacheDuration: a - i,
                dnsDuration: o - a,
                connectionDuration: c - o,
                requestDuration: t.value - c,
                navigationEntry: n
              };
            }
            return Object.assign(t, {
              attribution: e
            });
          }(e);
          t(n);
        }, e);
      },
      dt = {
        passive: true,
        capture: true
      },
      lt = new Date(),
      mt = function (t, e) {
        Z || (Z = e, $ = t, tt = new Date(), gt(removeEventListener), pt());
      },
      pt = function () {
        if ($ >= 0 && $ < tt - lt) {
          var t = {
            entryType: "first-input",
            name: Z.type,
            target: Z.target,
            cancelable: Z.cancelable,
            startTime: Z.timeStamp,
            processingStart: Z.timeStamp + $
          };
          et.forEach(function (e) {
            e(t);
          }), et = [];
        }
      },
      vt = function (t) {
        if (t.cancelable) {
          var e = (t.timeStamp > 1e12 ? new Date() : performance.now()) - t.timeStamp;
          "pointerdown" == t.type ? function (t, e) {
            var n = function () {
                mt(t, e), i();
              },
              r = function () {
                i();
              },
              i = function () {
                removeEventListener("pointerup", n, dt), removeEventListener("pointercancel", r, dt);
              };
            addEventListener("pointerup", n, dt), addEventListener("pointercancel", r, dt);
          }(e, t) : mt(e, t);
        }
      },
      gt = function (t) {
        ["mousedown", "keydown", "touchstart", "pointerdown"].forEach(function (e) {
          return t(e, vt, dt);
        });
      },
      ht = [100, 300],
      Tt = function (t, e) {
        e = e || {}, b(function () {
          var n,
            r = S(),
            i = f("FID"),
            a = function (t) {
              t.startTime < r.firstHiddenTime && (i.value = t.processingStart - t.startTime, i.entries.push(t), n(true));
            },
            o = function (t) {
              t.forEach(a);
            },
            c = d("first-input", o);
          n = l(t, i, ht, e.reportAllChanges), c && (p(v(function () {
            o(c.takeRecords()), c.disconnect();
          })), u(function () {
            var r;
            i = f("FID"), n = l(t, i, ht, e.reportAllChanges), et = [], $ = -1, Z = null, gt(addEventListener), r = a, et.push(r), pt();
          }));
        });
      },
      yt = function (t, e) {
        Tt(function (e) {
          var n = function (t) {
            var e = t.entries[0],
              n = {
                eventTarget: a(e.target),
                eventType: e.name,
                eventTime: e.startTime,
                eventEntry: e,
                loadState: r(e.startTime)
              };
            return Object.assign(t, {
              attribution: n
            });
          }(e);
          t(n);
        }, e);
      };

    // To avoid importing InstrumentationAbstract from:
    // import { InstrumentationAbstract } from '@opentelemetry/instrumentation/build/src/instrumentation';
    // When this is exposed we can import from there.
    class InstrumentationAbstract {
      constructor(instrumentationName, instrumentationVersion, config = {}) {
        this.instrumentationName = instrumentationName;
        this.instrumentationVersion = instrumentationVersion;
        /* Api to wrap instrumented method */
        // eslint-disable-next-line @typescript-eslint/unbound-method
        this._wrap = shimmerExports.wrap;
        /* Api to unwrap instrumented methods */
        // eslint-disable-next-line @typescript-eslint/unbound-method
        this._unwrap = shimmerExports.unwrap;
        /* Api to mass wrap instrumented method */
        // eslint-disable-next-line @typescript-eslint/unbound-method
        this._massWrap = shimmerExports.massWrap;
        /* Api to mass unwrap instrumented methods */
        // eslint-disable-next-line @typescript-eslint/unbound-method
        this._massUnwrap = shimmerExports.massUnwrap;
        this._config = Object.assign({
          enabled: true
        }, config);
        this._diag = diag.createComponentLogger({
          namespace: instrumentationName
        });
        this._tracer = trace.getTracer(instrumentationName, instrumentationVersion);
        this._meter = metrics.getMeter(instrumentationName, instrumentationVersion);
        this._updateMetricInstruments();
      }
      /* Returns meter */
      get meter() {
        return this._meter;
      }
      /**
       * Sets MeterProvider to this plugin
       * @param meterProvider
       */
      setMeterProvider(meterProvider) {
        this._meter = meterProvider.getMeter(this.instrumentationName, this.instrumentationVersion);
        this._updateMetricInstruments();
      }
      /**
       * Sets the new metric instruments with the current Meter.
       */
      _updateMetricInstruments() {
        return;
      }
      /* Returns InstrumentationConfig */
      getConfig() {
        return this._config;
      }
      /**
       * Sets InstrumentationConfig to this plugin
       * @param InstrumentationConfig
       */
      setConfig(config = {}) {
        this._config = Object.assign({}, config);
      }
      /**
       * Sets TraceProvider to this plugin
       * @param tracerProvider
       */
      setTracerProvider(tracerProvider) {
        this._tracer = tracerProvider.getTracer(this.instrumentationName, this.instrumentationVersion);
      }
      /* Returns tracer */
      get tracer() {
        return this._tracer;
      }
    }
    /**
     * Web vitals auto-instrumentation, sends spans automatically for CLS, LCP, INP, FCP, FID, TTFB.
     * Defaults to sending spans for CLS, LCP, INP, FCP and TTFB.
     * @param config The {@link WebVitalsInstrumentationConfig }
     */
    class WebVitalsInstrumentation extends InstrumentationAbstract {
      constructor({
        enabled = true,
        vitalsToTrack = ['CLS', 'LCP', 'INP', 'TTFB', 'FCP'],
        lcp,
        cls,
        inp,
        fid,
        fcp,
        ttfb
      } = {}) {
        const config = {
          enabled,
          vitalsToTrack,
          lcp,
          cls,
          inp,
          fid,
          fcp,
          ttfb
        };
        super('@honeycombio/instrumentation-web-vitals', VERSION$2, config);
        this.onReportCLS = (cls, clsOpts = {}) => {
          const {
            applyCustomAttributes
          } = clsOpts;
          if (!this.isEnabled()) return;
          const {
            name,
            attribution
          } = cls;
          const {
            largestShiftTarget,
            largestShiftTime,
            largestShiftValue,
            loadState,
            largestShiftEntry
          } = attribution;
          const attrPrefix = this.getAttrPrefix(name);
          const span = this.tracer.startSpan(name);
          span.setAttributes(Object.assign(Object.assign({}, this.getSharedAttributes(cls)), {
            [`${attrPrefix}.largest_shift_target`]: largestShiftTarget,
            [`${attrPrefix}.element`]: largestShiftTarget,
            [`${attrPrefix}.largest_shift_time`]: largestShiftTime,
            [`${attrPrefix}.largest_shift_value`]: largestShiftValue,
            [`${attrPrefix}.load_state`]: loadState,
            [`${attrPrefix}.had_recent_input`]: largestShiftEntry === null || largestShiftEntry === void 0 ? void 0 : largestShiftEntry.hadRecentInput
          }));
          if (applyCustomAttributes) {
            applyCustomAttributes(cls, span);
          }
          span.end();
        };
        this.onReportLCP = (lcp, lcpOpts = {}) => {
          const {
            applyCustomAttributes,
            dataAttributes
          } = lcpOpts;
          if (!this.isEnabled()) return;
          const {
            name,
            attribution
          } = lcp;
          const {
            element,
            url,
            timeToFirstByte,
            resourceLoadDelay,
            resourceLoadDuration,
            elementRenderDelay,
            lcpEntry
          } = attribution;
          const attrPrefix = this.getAttrPrefix(name);
          const span = this.tracer.startSpan(name);
          span.setAttributes(Object.assign(Object.assign({}, this.getSharedAttributes(lcp)), {
            [`${attrPrefix}.element`]: element,
            [`${attrPrefix}.url`]: url,
            [`${attrPrefix}.time_to_first_byte`]: timeToFirstByte,
            [`${attrPrefix}.resource_load_delay`]: resourceLoadDelay,
            [`${attrPrefix}.resource_load_duration`]: resourceLoadDuration,
            [`${attrPrefix}.element_render_delay`]: elementRenderDelay,
            // This will be deprecated in a future version
            [`${attrPrefix}.resource_load_time`]: resourceLoadDuration
          }));
          const el = lcpEntry === null || lcpEntry === void 0 ? void 0 : lcpEntry.element;
          if (el === null || el === void 0 ? void 0 : el.dataset) {
            for (const attrName in el.dataset) {
              const attrValue = el.dataset[attrName];
              if (
              // Value exists (including the empty string AND either
              attrValue !== undefined && (
              // dataAttributes is undefined (i.e. send all values as span attributes) OR
              dataAttributes === undefined ||
              // dataAttributes is specified AND attrName is in dataAttributes (i.e attribute name is in the supplied allowList)
              dataAttributes.includes(attrName))) {
                span.setAttribute(`${attrPrefix}.element.data.${attrName}`, attrValue);
              }
            }
          }
          if (applyCustomAttributes) {
            applyCustomAttributes(lcp, span);
          }
          span.end();
        };
        this.onReportINP = (inp, inpOpts = {
          includeTimingsAsSpans: false
        }) => {
          const {
            applyCustomAttributes,
            includeTimingsAsSpans
          } = inpOpts;
          if (!this.isEnabled()) return;
          const {
            name,
            attribution
          } = inp;
          const {
            inputDelay,
            interactionTarget,
            interactionTime,
            interactionType,
            loadState,
            nextPaintTime,
            presentationDelay,
            processingDuration,
            longAnimationFrameEntries: _loafEntries
          } = attribution;
          const longAnimationFrameEntries = _loafEntries;
          const attrPrefix = this.getAttrPrefix(name);
          const inpDuration = inputDelay + processingDuration + presentationDelay;
          this.tracer.startActiveSpan(name, {
            startTime: interactionTime
          }, inpSpan => {
            const inpAttributes = Object.assign(Object.assign({}, this.getSharedAttributes(inp)), {
              [`${attrPrefix}.input_delay`]: inputDelay,
              [`${attrPrefix}.interaction_target`]: interactionTarget,
              [`${attrPrefix}.interaction_time`]: interactionTime,
              [`${attrPrefix}.interaction_type`]: interactionType,
              [`${attrPrefix}.load_state`]: loadState,
              [`${attrPrefix}.next_paint_time`]: nextPaintTime,
              [`${attrPrefix}.presentation_delay`]: presentationDelay,
              [`${attrPrefix}.processing_duration`]: processingDuration,
              [`${attrPrefix}.duration`]: inpDuration,
              // These will be deprecated in a future version
              [`${attrPrefix}.element`]: interactionTarget,
              [`${attrPrefix}.event_type`]: interactionType
            });
            inpSpan.setAttributes(inpAttributes);
            if (applyCustomAttributes) {
              applyCustomAttributes(inp, inpSpan);
            }
            if (includeTimingsAsSpans) {
              longAnimationFrameEntries.forEach(perfEntry => {
                this.processPerformanceLongAnimationFrameTimingSpans(attrPrefix, perfEntry);
              });
            }
            inpSpan.end(interactionTime + inpDuration);
          });
        };
        this.onReportFCP = (fcp, fcpOpts = {}) => {
          const {
            applyCustomAttributes
          } = fcpOpts;
          if (!this.isEnabled()) return;
          const {
            name,
            attribution
          } = fcp;
          const {
            timeToFirstByte,
            firstByteToFCP,
            loadState
          } = attribution;
          const attrPrefix = this.getAttrPrefix(name);
          const span = this.tracer.startSpan(name);
          span.setAttributes(Object.assign(Object.assign({}, this.getSharedAttributes(fcp)), {
            [`${attrPrefix}.time_to_first_byte`]: timeToFirstByte,
            [`${attrPrefix}.time_since_first_byte`]: firstByteToFCP,
            [`${attrPrefix}.load_state`]: loadState
          }));
          if (applyCustomAttributes) {
            applyCustomAttributes(fcp, span);
          }
          span.end();
        };
        /**
         *  @deprecated this will be removed in the next major version, use INP instead.
         */
        this.onReportFID = (fid, fidOpts = {}) => {
          const {
            applyCustomAttributes
          } = fidOpts;
          if (!this.isEnabled()) return;
          const {
            name,
            attribution
          } = fid;
          const {
            eventTarget,
            eventType,
            loadState
          } = attribution;
          const attrPrefix = this.getAttrPrefix(name);
          const span = this.tracer.startSpan(name);
          span.setAttributes(Object.assign(Object.assign({}, this.getSharedAttributes(fid)), {
            [`${attrPrefix}.element`]: eventTarget,
            [`${attrPrefix}.event_type`]: eventType,
            [`${attrPrefix}.load_state`]: loadState
          }));
          if (applyCustomAttributes) {
            applyCustomAttributes(fid, span);
          }
          span.end();
        };
        this.onReportTTFB = (ttfb, ttfbOpts = {}) => {
          const {
            applyCustomAttributes
          } = ttfbOpts;
          if (!this.isEnabled()) return;
          const {
            name,
            attribution
          } = ttfb;
          const {
            cacheDuration,
            connectionDuration,
            dnsDuration,
            requestDuration,
            waitingDuration
          } = attribution;
          const attrPrefix = this.getAttrPrefix(name);
          const attributes = Object.assign(Object.assign({}, this.getSharedAttributes(ttfb)), {
            [`${attrPrefix}.waiting_duration`]: waitingDuration,
            [`${attrPrefix}.dns_duration`]: dnsDuration,
            [`${attrPrefix}.connection_duration`]: connectionDuration,
            [`${attrPrefix}.request_duration`]: requestDuration,
            [`${attrPrefix}.cache_duration`]: cacheDuration,
            // These will be deprecated ina future version
            [`${attrPrefix}.waiting_time`]: waitingDuration,
            [`${attrPrefix}.dns_time`]: dnsDuration,
            [`${attrPrefix}.connection_time`]: connectionDuration,
            [`${attrPrefix}.request_time`]: requestDuration
          });
          const span = this.tracer.startSpan(name);
          span.setAttributes(attributes);
          if (applyCustomAttributes) {
            applyCustomAttributes(ttfb, span);
          }
          span.end();
        };
        this.vitalsToTrack = [...vitalsToTrack];
        this.lcpOpts = lcp;
        this.clsOpts = cls;
        this.inpOpts = inp;
        this.fidOpts = fid;
        this.fcpOpts = fcp;
        this.ttfbOpts = ttfb;
        this._isEnabled = enabled;
        this._setupWebVitalsCallbacks();
      }
      init() {}
      _setupWebVitalsCallbacks() {
        if (this.vitalsToTrack.includes('CLS')) {
          D(vital => {
            this.onReportCLS(vital, this.clsOpts);
          }, this.clsOpts);
        }
        if (this.vitalsToTrack.includes('LCP')) {
          ot(vital => {
            this.onReportLCP(vital, this.lcpOpts);
          }, this.lcpOpts);
        }
        if (this.vitalsToTrack.includes('INP')) {
          rt(vital => {
            this.onReportINP(vital, this.inpOpts);
          }, this.inpOpts);
        }
        if (this.vitalsToTrack.includes('FID')) {
          yt(vital => {
            this.onReportFID(vital, this.fidOpts);
          }, this.fidOpts);
        }
        if (this.vitalsToTrack.includes('TTFB')) {
          ft(vital => {
            this.onReportTTFB(vital, this.ttfbOpts);
          }, this.ttfbOpts);
        }
        if (this.vitalsToTrack.includes('FCP')) {
          w(vital => {
            this.onReportFCP(vital, this.fcpOpts);
          }, this.fcpOpts);
        }
      }
      getAttrPrefix(name) {
        return name.toLowerCase();
      }
      getSharedAttributes(vital) {
        const {
          name,
          id,
          delta,
          rating,
          value,
          navigationType
        } = vital;
        const attrPrefix = this.getAttrPrefix(name);
        return {
          [`${attrPrefix}.id`]: id,
          [`${attrPrefix}.delta`]: delta,
          [`${attrPrefix}.value`]: value,
          [`${attrPrefix}.rating`]: rating,
          [`${attrPrefix}.navigation_type`]: navigationType
        };
      }
      getAttributesForPerformanceLongAnimationFrameTiming(prefix, perfEntry) {
        const loafAttributes = {
          [`${prefix}.duration`]: perfEntry.duration,
          [`${prefix}.entryType`]: perfEntry.entryType,
          [`${prefix}.name`]: perfEntry.name,
          [`${prefix}.renderStart`]: perfEntry.renderStart,
          [`${prefix}.startTime`]: perfEntry.startTime
        };
        return loafAttributes;
      }
      getAttributesForPerformanceScriptTiming(prefix, scriptPerfEntry) {
        const scriptAttributes = {
          [`${prefix}.entry_type`]: scriptPerfEntry.entryType,
          [`${prefix}.start_time`]: scriptPerfEntry.startTime,
          [`${prefix}.execution_start`]: scriptPerfEntry.executionStart,
          [`${prefix}.duration`]: scriptPerfEntry.duration,
          [`${prefix}.forced_style_and_layout_duration`]: scriptPerfEntry.forcedStyleAndLayoutDuration,
          [`${prefix}.invoker`]: scriptPerfEntry.invoker,
          [`${prefix}.pause_duration`]: scriptPerfEntry.pauseDuration,
          [`${prefix}.source_url`]: scriptPerfEntry.sourceURL,
          [`${prefix}.source_function_name`]: scriptPerfEntry.sourceFunctionName,
          [`${prefix}.source_char_position`]: scriptPerfEntry.sourceCharPosition,
          [`${prefix}.window_attribution`]: scriptPerfEntry.windowAttribution
        };
        return scriptAttributes;
      }
      processPerformanceLongAnimationFrameTimingSpans(parentPrefix, perfEntry) {
        if (!perfEntry) return;
        const prefix = `${parentPrefix}.timing`;
        const loafAttributes = this.getAttributesForPerformanceLongAnimationFrameTiming(prefix, perfEntry);
        this.tracer.startActiveSpan(perfEntry.name, {
          startTime: perfEntry.startTime
        }, span => {
          span.setAttributes(loafAttributes);
          this.processPerformanceScriptTimingSpans(prefix, perfEntry.scripts);
          span.end(perfEntry.startTime + perfEntry.duration);
        });
      }
      processPerformanceScriptTimingSpans(parentPrefix, perfScriptEntries) {
        if (!perfScriptEntries) return;
        if (!(perfScriptEntries === null || perfScriptEntries === void 0 ? void 0 : perfScriptEntries.length)) return;
        const prefix = `${parentPrefix}.script`;
        perfScriptEntries.map(scriptPerfEntry => {
          this.tracer.startActiveSpan(scriptPerfEntry.name, {
            startTime: scriptPerfEntry.startTime
          }, span => {
            const scriptAttributes = this.getAttributesForPerformanceScriptTiming(prefix, scriptPerfEntry);
            span.setAttributes(scriptAttributes);
            span.end(scriptPerfEntry.startTime + scriptPerfEntry.duration);
          });
        });
      }
      disable() {
        if (!this.isEnabled()) {
          this._diag.debug(`Instrumentation already disabled`);
          return;
        }
        this._isEnabled = false;
        this._diag.debug(`Instrumentation  disabled`);
      }
      enable() {
        if (this.isEnabled()) {
          this._diag.debug(`Instrumentation already enabled`);
          return;
        }
        this._isEnabled = true;
        this._diag.debug(`Instrumentation  enabled`);
        this._diag.debug(`Sending spans for ${this.vitalsToTrack.join(',')}`);
      }
      isEnabled() {
        return this._isEnabled;
      }
    }
    const LIBRARY_NAME = '@honeycombio/instrumentation-global-errors';
    /**
     * Extracts and structures the stack trace from an error object.
     *
     * This function breaks down the stack trace into arrays of strings and numbers
     * to comply with OTLP (OpenTelemetry Protocol) requirements, which do not accept
     * arrays of objects.
     *
     * @param {Error | undefined} error - The error object from which to extract the stack trace.
     * @returns {Object} An object containing structured stack trace information with arrays of columns, lines, functions, and URLs.
     */
    function getStructuredStackTrace(error) {
      if (!error) {
        return {};
      }
      // OTLP does not accept arrays of objects
      // breaking down the stack into arrays of strings/numbers
      const structuredStack = tracekitExports.computeStackTrace(error).stack;
      const lines = [];
      const columns = [];
      const functions = [];
      const urls = [];
      if (!Array.isArray(structuredStack)) {
        return {};
      }
      structuredStack.forEach(stackFrame => {
        lines.push(stackFrame.line);
        columns.push(stackFrame.column);
        functions.push(stackFrame.func);
        urls.push(stackFrame.url);
      });
      return {
        'exception.structured_stacktrace.columns': columns,
        'exception.structured_stacktrace.lines': lines,
        'exception.structured_stacktrace.functions': functions,
        'exception.structured_stacktrace.urls': urls
      };
    }
    /**
     * Records an exception as a span in the OpenTelemetry tracer.
     *
     * @param {Error} error - The error object to record.
     * @param {Attributes} [attributes={}] - Additional attributes to add to the span.
     * @param {Tracer} [tracer=trace.getTracer(LIBRARY_NAME)] - The tracer to use for recording the span.
     * @param {ApplyCustomErrorAttributesOnSpanFn} applyCustomAttributesOnSpan - Callback function to add custom attributes to the span and mutate the span.
     */
    function recordException(error, attributes = {}, tracer = trace.getTracer(LIBRARY_NAME), applyCustomAttributesOnSpan) {
      const message = error.message;
      const type = error.name;
      const errorAttributes = Object.assign(Object.assign({
        [ATTR_EXCEPTION_TYPE]: type,
        [ATTR_EXCEPTION_MESSAGE]: message,
        [ATTR_EXCEPTION_STACKTRACE]: error.stack
      }, getStructuredStackTrace(error)), attributes);
      const errorSpan = tracer.startSpan('exception', {
        attributes: errorAttributes
      }, context.active());
      if (applyCustomAttributesOnSpan) {
        applyCustomAttributesOnSpan(errorSpan, error);
      }
      errorSpan.setStatus({
        code: SpanStatusCode.ERROR,
        message
      });
      errorSpan.end();
    }
    /**
     * Global errors auto-instrumentation, sends spans automatically for exceptions that reach the window.
     * @param config The {@link GlobalErrorsInstrumentationConfig}
     */
    class GlobalErrorsInstrumentation extends InstrumentationAbstract {
      constructor({
        enabled = true,
        applyCustomAttributesOnSpan
      } = {}) {
        const config = {
          enabled,
          applyCustomAttributesOnSpan
        };
        super(LIBRARY_NAME, VERSION$2, config);
        this.onError = event => {
          const error = 'reason' in event ? event.reason : event.error;
          console.log(this.applyCustomAttributesOnSpan);
          if (error) {
            recordException(error, {}, this.tracer, this.applyCustomAttributesOnSpan);
          }
        };
        if (enabled) {
          this.enable();
        }
        this._isEnabled = enabled;
        this.applyCustomAttributesOnSpan = applyCustomAttributesOnSpan;
      }
      init() {}
      disable() {
        if (!this.isEnabled()) {
          this._diag.debug(`Instrumentation already disabled`);
          return;
        }
        this._isEnabled = false;
        window.removeEventListener('error', this.onError);
        window.removeEventListener('unhandledrejection', this.onError);
        this._diag.debug(`Instrumentation  disabled`);
      }
      enable() {
        if (this.isEnabled()) {
          this._diag.debug(`Instrumentation already enabled`);
          return;
        }
        this._isEnabled = true;
        window.addEventListener('error', this.onError);
        window.addEventListener('unhandledrejection', this.onError);
        this._diag.debug(`Instrumentation  enabled`);
      }
      isEnabled() {
        return this._isEnabled;
      }
    }
    class HoneycombWebSDK extends WebSDK {
      constructor(options) {
        var _a, _b;
        const instrumentations = [...((options === null || options === void 0 ? void 0 : options.instrumentations) || [])];
        // Automatically include web vitals instrumentation unless explicitly set to false
        if (((_a = options === null || options === void 0 ? void 0 : options.webVitalsInstrumentationConfig) === null || _a === void 0 ? void 0 : _a.enabled) !== false) {
          instrumentations.push(new WebVitalsInstrumentation(options === null || options === void 0 ? void 0 : options.webVitalsInstrumentationConfig));
        }
        // Automatically include global errors instrumentation unless explicitly set to false
        if (((_b = options === null || options === void 0 ? void 0 : options.globalErrorsInstrumentationConfig) === null || _b === void 0 ? void 0 : _b.enabled) !== false) {
          instrumentations.push(new GlobalErrorsInstrumentation(options === null || options === void 0 ? void 0 : options.globalErrorsInstrumentationConfig));
        }
        super(Object.assign(Object.assign({}, options), {
          instrumentations,
          resource: mergeResources([configureBrowserAttributesResource(), configureEntryPageResource(options === null || options === void 0 ? void 0 : options.entryPageAttributes), options === null || options === void 0 ? void 0 : options.resource, options === null || options === void 0 ? void 0 : options.resourceAttributes, configureHoneycombResource()]),
          sampler: configureDeterministicSampler(options),
          // Exporter is configured through the span processor because
          // the base SDK does not allow having both a spanProcessor and a
          // traceExporter configured at the same time.
          spanProcessor: configureSpanProcessors(options)
        }));
        validateOptionsWarnings(options);
        if (options === null || options === void 0 ? void 0 : options.debug) {
          configureDebug(options);
        }
      }
    }

    /*
     * Copyright The OpenTelemetry Authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      https://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    /**
     * check if an object has addEventListener and removeEventListener functions then it will return true.
     * Generally only called with a `TargetWithEvents` but may be called with an unknown / any.
     * @param obj - The object to check.
     */
    function isListenerObject(obj) {
      if (obj === void 0) {
        obj = {};
      }
      return typeof obj.addEventListener === 'function' && typeof obj.removeEventListener === 'function';
    }

    /*
     * Copyright The OpenTelemetry Authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      https://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    /// <reference types="zone.js" />
    /* Key name to be used to save a context reference in Zone */
    var ZONE_CONTEXT_KEY$1 = 'OT_ZONE_CONTEXT';
    /**
     * ZoneContextManager
     * This module provides an easy functionality for tracing action between asynchronous operations in web.
     * It was not possible with standard [StackContextManager]{@link https://github.com/open-telemetry/opentelemetry-js/blob/main/packages/opentelemetry-sdk-trace-web/src/StackContextManager.ts}.
     * It heavily depends on [zone.js]{@link https://www.npmjs.com/package/zone.js}.
     * It stores the information about context in zone. Each Context will have always new Zone;
     * It also supports binding a certain Span to a target that has "addEventListener" and "removeEventListener".
     * When this happens a new zone is being created and the provided Span is being assigned to this zone.
     */
    var ZoneContextManager = /** @class */function () {
      function ZoneContextManager() {
        /**
         * whether the context manager is enabled or not
         */
        this._enabled = false;
        /**
         * Helps to create a unique name for the zones - part of zone name
         */
        this._zoneCounter = 0;
      }
      /**
       * Returns the active context from certain zone name
       * @param activeZone
       */
      ZoneContextManager.prototype._activeContextFromZone = function (activeZone) {
        return activeZone && activeZone.get(ZONE_CONTEXT_KEY$1) || ROOT_CONTEXT;
      };
      /**
       * @param context A context (span) to be executed within target function
       * @param target Function to be executed within the context
       */
      // eslint-disable-next-line @typescript-eslint/ban-types
      ZoneContextManager.prototype._bindFunction = function (context, target) {
        var manager = this;
        var contextWrapper = function () {
          var _this = this;
          var args = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
          }
          return manager.with(context, function () {
            return target.apply(_this, args);
          });
        };
        Object.defineProperty(contextWrapper, 'length', {
          enumerable: false,
          configurable: true,
          writable: false,
          value: target.length
        });
        return contextWrapper;
      };
      /**
       * @param context A context (span) to be bind to target
       * @param obj target object on which the listeners will be patched
       */
      ZoneContextManager.prototype._bindListener = function (context, obj) {
        var target = obj;
        if (target.__ot_listeners !== undefined) {
          return obj;
        }
        target.__ot_listeners = {};
        if (typeof target.addEventListener === 'function') {
          target.addEventListener = this._patchAddEventListener(target, target.addEventListener, context);
        }
        if (typeof target.removeEventListener === 'function') {
          target.removeEventListener = this._patchRemoveEventListener(target, target.removeEventListener);
        }
        return obj;
      };
      /**
       * Creates a new unique zone name
       */
      ZoneContextManager.prototype._createZoneName = function () {
        this._zoneCounter++;
        var random = Math.random();
        return this._zoneCounter + "-" + random;
      };
      /**
       * Creates a new zone
       * @param zoneName zone name
       * @param context A context (span) to be bind with Zone
       */
      ZoneContextManager.prototype._createZone = function (zoneName, context) {
        var _a;
        return Zone.current.fork({
          name: zoneName,
          properties: (_a = {}, _a[ZONE_CONTEXT_KEY$1] = context, _a)
        });
      };
      /**
       * Returns the active zone
       */
      ZoneContextManager.prototype._getActiveZone = function () {
        return Zone.current;
      };
      /**
       * Patches addEventListener method
       * @param target any target that has "addEventListener" method
       * @param original reference to the patched method
       * @param [context] context to be bind to the listener
       */
      ZoneContextManager.prototype._patchAddEventListener = function (target, original, context) {
        var contextManager = this;
        return function (event, listener, opts) {
          if (target.__ot_listeners === undefined) {
            target.__ot_listeners = {};
          }
          var listeners = target.__ot_listeners[event];
          if (listeners === undefined) {
            listeners = new WeakMap();
            target.__ot_listeners[event] = listeners;
          }
          var patchedListener = contextManager.bind(context, listener);
          // store a weak reference of the user listener to ours
          listeners.set(listener, patchedListener);
          return original.call(this, event, patchedListener, opts);
        };
      };
      /**
       * Patches removeEventListener method
       * @param target any target that has "removeEventListener" method
       * @param original reference to the patched method
       */
      ZoneContextManager.prototype._patchRemoveEventListener = function (target, original) {
        return function (event, listener) {
          if (target.__ot_listeners === undefined || target.__ot_listeners[event] === undefined) {
            return original.call(this, event, listener);
          }
          var events = target.__ot_listeners[event];
          var patchedListener = events.get(listener);
          events.delete(listener);
          return original.call(this, event, patchedListener || listener);
        };
      };
      /**
       * Returns the active context
       */
      ZoneContextManager.prototype.active = function () {
        if (!this._enabled) {
          return ROOT_CONTEXT;
        }
        var activeZone = this._getActiveZone();
        var active = this._activeContextFromZone(activeZone);
        if (active) {
          return active;
        }
        return ROOT_CONTEXT;
      };
      /**
       * Binds a the certain context or the active one to the target function and then returns the target
       * @param context A context (span) to be bind to target
       * @param target a function or event emitter. When target or one of its callbacks is called,
       *  the provided context will be used as the active context for the duration of the call.
       */
      ZoneContextManager.prototype.bind = function (context, target) {
        // if no specific context to propagate is given, we use the current one
        if (context === undefined) {
          context = this.active();
        }
        if (typeof target === 'function') {
          return this._bindFunction(context, target);
        } else if (isListenerObject(target)) {
          this._bindListener(context, target);
        }
        return target;
      };
      /**
       * Disable the context manager (clears all the contexts)
       */
      ZoneContextManager.prototype.disable = function () {
        this._enabled = false;
        return this;
      };
      /**
       * Enables the context manager and creates a default(root) context
       */
      ZoneContextManager.prototype.enable = function () {
        this._enabled = true;
        return this;
      };
      /**
       * Calls the callback function [fn] with the provided [context].
       *     If [context] is undefined then it will use the active context.
       *     The context will be set as active
       * @param context A context (span) to be called with provided callback
       * @param fn Callback function
       * @param thisArg optional receiver to be used for calling fn
       * @param args optional arguments forwarded to fn
       */
      ZoneContextManager.prototype.with = function (context, fn, thisArg) {
        var args = [];
        for (var _i = 3; _i < arguments.length; _i++) {
          args[_i - 3] = arguments[_i];
        }
        var zoneName = this._createZoneName();
        var newZone = this._createZone(zoneName, context);
        return newZone.run(fn, thisArg, args);
      };
      return ZoneContextManager;
    }();

    var zone = {};

    var hasRequiredZone;
    function requireZone() {
      if (hasRequiredZone) return zone;
      hasRequiredZone = 1;
      /**
       * @license Angular v<unknown>
       * (c) 2010-2024 Google LLC. https://angular.io/
       * License: MIT
       */
      const global = globalThis;
      // __Zone_symbol_prefix global can be used to override the default zone
      // symbol prefix with a custom one if needed.
      function __symbol__(name) {
        const symbolPrefix = global['__Zone_symbol_prefix'] || '__zone_symbol__';
        return symbolPrefix + name;
      }
      function initZone() {
        const performance = global['performance'];
        function mark(name) {
          performance && performance['mark'] && performance['mark'](name);
        }
        function performanceMeasure(name, label) {
          performance && performance['measure'] && performance['measure'](name, label);
        }
        mark('Zone');
        class ZoneImpl {
          // tslint:disable-next-line:require-internal-with-underscore
          static {
            this.__symbol__ = __symbol__;
          }
          static assertZonePatched() {
            if (global['Promise'] !== patches['ZoneAwarePromise']) {
              throw new Error('Zone.js has detected that ZoneAwarePromise `(window|global).Promise` ' + 'has been overwritten.\n' + 'Most likely cause is that a Promise polyfill has been loaded ' + 'after Zone.js (Polyfilling Promise api is not necessary when zone.js is loaded. ' + 'If you must load one, do so before loading zone.js.)');
            }
          }
          static get root() {
            let zone = ZoneImpl.current;
            while (zone.parent) {
              zone = zone.parent;
            }
            return zone;
          }
          static get current() {
            return _currentZoneFrame.zone;
          }
          static get currentTask() {
            return _currentTask;
          }
          // tslint:disable-next-line:require-internal-with-underscore
          static __load_patch(name, fn, ignoreDuplicate = false) {
            if (patches.hasOwnProperty(name)) {
              // `checkDuplicate` option is defined from global variable
              // so it works for all modules.
              // `ignoreDuplicate` can work for the specified module
              const checkDuplicate = global[__symbol__('forceDuplicateZoneCheck')] === true;
              if (!ignoreDuplicate && checkDuplicate) {
                throw Error('Already loaded patch: ' + name);
              }
            } else if (!global['__Zone_disable_' + name]) {
              const perfName = 'Zone:' + name;
              mark(perfName);
              patches[name] = fn(global, ZoneImpl, _api);
              performanceMeasure(perfName, perfName);
            }
          }
          get parent() {
            return this._parent;
          }
          get name() {
            return this._name;
          }
          constructor(parent, zoneSpec) {
            this._parent = parent;
            this._name = zoneSpec ? zoneSpec.name || 'unnamed' : '<root>';
            this._properties = zoneSpec && zoneSpec.properties || {};
            this._zoneDelegate = new _ZoneDelegate(this, this._parent && this._parent._zoneDelegate, zoneSpec);
          }
          get(key) {
            const zone = this.getZoneWith(key);
            if (zone) return zone._properties[key];
          }
          getZoneWith(key) {
            let current = this;
            while (current) {
              if (current._properties.hasOwnProperty(key)) {
                return current;
              }
              current = current._parent;
            }
            return null;
          }
          fork(zoneSpec) {
            if (!zoneSpec) throw new Error('ZoneSpec required!');
            return this._zoneDelegate.fork(this, zoneSpec);
          }
          wrap(callback, source) {
            if (typeof callback !== 'function') {
              throw new Error('Expecting function got: ' + callback);
            }
            const _callback = this._zoneDelegate.intercept(this, callback, source);
            const zone = this;
            return function () {
              return zone.runGuarded(_callback, this, arguments, source);
            };
          }
          run(callback, applyThis, applyArgs, source) {
            _currentZoneFrame = {
              parent: _currentZoneFrame,
              zone: this
            };
            try {
              return this._zoneDelegate.invoke(this, callback, applyThis, applyArgs, source);
            } finally {
              _currentZoneFrame = _currentZoneFrame.parent;
            }
          }
          runGuarded(callback, applyThis = null, applyArgs, source) {
            _currentZoneFrame = {
              parent: _currentZoneFrame,
              zone: this
            };
            try {
              try {
                return this._zoneDelegate.invoke(this, callback, applyThis, applyArgs, source);
              } catch (error) {
                if (this._zoneDelegate.handleError(this, error)) {
                  throw error;
                }
              }
            } finally {
              _currentZoneFrame = _currentZoneFrame.parent;
            }
          }
          runTask(task, applyThis, applyArgs) {
            if (task.zone != this) {
              throw new Error('A task can only be run in the zone of creation! (Creation: ' + (task.zone || NO_ZONE).name + '; Execution: ' + this.name + ')');
            }
            const zoneTask = task;
            // https://github.com/angular/zone.js/issues/778, sometimes eventTask
            // will run in notScheduled(canceled) state, we should not try to
            // run such kind of task but just return
            const {
              type,
              data: {
                isPeriodic = false,
                isRefreshable = false
              } = {}
            } = task;
            if (task.state === notScheduled && (type === eventTask || type === macroTask)) {
              return;
            }
            const reEntryGuard = task.state != running;
            reEntryGuard && zoneTask._transitionTo(running, scheduled);
            const previousTask = _currentTask;
            _currentTask = zoneTask;
            _currentZoneFrame = {
              parent: _currentZoneFrame,
              zone: this
            };
            try {
              if (type == macroTask && task.data && !isPeriodic && !isRefreshable) {
                task.cancelFn = undefined;
              }
              try {
                return this._zoneDelegate.invokeTask(this, zoneTask, applyThis, applyArgs);
              } catch (error) {
                if (this._zoneDelegate.handleError(this, error)) {
                  throw error;
                }
              }
            } finally {
              // if the task's state is notScheduled or unknown, then it has already been cancelled
              // we should not reset the state to scheduled
              const state = task.state;
              if (state !== notScheduled && state !== unknown) {
                if (type == eventTask || isPeriodic || isRefreshable && state === scheduling) {
                  reEntryGuard && zoneTask._transitionTo(scheduled, running, scheduling);
                } else {
                  const zoneDelegates = zoneTask._zoneDelegates;
                  this._updateTaskCount(zoneTask, -1);
                  reEntryGuard && zoneTask._transitionTo(notScheduled, running, notScheduled);
                  if (isRefreshable) {
                    zoneTask._zoneDelegates = zoneDelegates;
                  }
                }
              }
              _currentZoneFrame = _currentZoneFrame.parent;
              _currentTask = previousTask;
            }
          }
          scheduleTask(task) {
            if (task.zone && task.zone !== this) {
              // check if the task was rescheduled, the newZone
              // should not be the children of the original zone
              let newZone = this;
              while (newZone) {
                if (newZone === task.zone) {
                  throw Error(`can not reschedule task to ${this.name} which is descendants of the original zone ${task.zone.name}`);
                }
                newZone = newZone.parent;
              }
            }
            task._transitionTo(scheduling, notScheduled);
            const zoneDelegates = [];
            task._zoneDelegates = zoneDelegates;
            task._zone = this;
            try {
              task = this._zoneDelegate.scheduleTask(this, task);
            } catch (err) {
              // should set task's state to unknown when scheduleTask throw error
              // because the err may from reschedule, so the fromState maybe notScheduled
              task._transitionTo(unknown, scheduling, notScheduled);
              // TODO: @JiaLiPassion, should we check the result from handleError?
              this._zoneDelegate.handleError(this, err);
              throw err;
            }
            if (task._zoneDelegates === zoneDelegates) {
              // we have to check because internally the delegate can reschedule the task.
              this._updateTaskCount(task, 1);
            }
            if (task.state == scheduling) {
              task._transitionTo(scheduled, scheduling);
            }
            return task;
          }
          scheduleMicroTask(source, callback, data, customSchedule) {
            return this.scheduleTask(new ZoneTask(microTask, source, callback, data, customSchedule, undefined));
          }
          scheduleMacroTask(source, callback, data, customSchedule, customCancel) {
            return this.scheduleTask(new ZoneTask(macroTask, source, callback, data, customSchedule, customCancel));
          }
          scheduleEventTask(source, callback, data, customSchedule, customCancel) {
            return this.scheduleTask(new ZoneTask(eventTask, source, callback, data, customSchedule, customCancel));
          }
          cancelTask(task) {
            if (task.zone != this) throw new Error('A task can only be cancelled in the zone of creation! (Creation: ' + (task.zone || NO_ZONE).name + '; Execution: ' + this.name + ')');
            if (task.state !== scheduled && task.state !== running) {
              return;
            }
            task._transitionTo(canceling, scheduled, running);
            try {
              this._zoneDelegate.cancelTask(this, task);
            } catch (err) {
              // if error occurs when cancelTask, transit the state to unknown
              task._transitionTo(unknown, canceling);
              this._zoneDelegate.handleError(this, err);
              throw err;
            }
            this._updateTaskCount(task, -1);
            task._transitionTo(notScheduled, canceling);
            task.runCount = -1;
            return task;
          }
          _updateTaskCount(task, count) {
            const zoneDelegates = task._zoneDelegates;
            if (count == -1) {
              task._zoneDelegates = null;
            }
            for (let i = 0; i < zoneDelegates.length; i++) {
              zoneDelegates[i]._updateTaskCount(task.type, count);
            }
          }
        }
        const DELEGATE_ZS = {
          name: '',
          onHasTask: (delegate, _, target, hasTaskState) => delegate.hasTask(target, hasTaskState),
          onScheduleTask: (delegate, _, target, task) => delegate.scheduleTask(target, task),
          onInvokeTask: (delegate, _, target, task, applyThis, applyArgs) => delegate.invokeTask(target, task, applyThis, applyArgs),
          onCancelTask: (delegate, _, target, task) => delegate.cancelTask(target, task)
        };
        class _ZoneDelegate {
          get zone() {
            return this._zone;
          }
          constructor(zone, parentDelegate, zoneSpec) {
            this._taskCounts = {
              'microTask': 0,
              'macroTask': 0,
              'eventTask': 0
            };
            this._zone = zone;
            this._parentDelegate = parentDelegate;
            this._forkZS = zoneSpec && (zoneSpec && zoneSpec.onFork ? zoneSpec : parentDelegate._forkZS);
            this._forkDlgt = zoneSpec && (zoneSpec.onFork ? parentDelegate : parentDelegate._forkDlgt);
            this._forkCurrZone = zoneSpec && (zoneSpec.onFork ? this._zone : parentDelegate._forkCurrZone);
            this._interceptZS = zoneSpec && (zoneSpec.onIntercept ? zoneSpec : parentDelegate._interceptZS);
            this._interceptDlgt = zoneSpec && (zoneSpec.onIntercept ? parentDelegate : parentDelegate._interceptDlgt);
            this._interceptCurrZone = zoneSpec && (zoneSpec.onIntercept ? this._zone : parentDelegate._interceptCurrZone);
            this._invokeZS = zoneSpec && (zoneSpec.onInvoke ? zoneSpec : parentDelegate._invokeZS);
            this._invokeDlgt = zoneSpec && (zoneSpec.onInvoke ? parentDelegate : parentDelegate._invokeDlgt);
            this._invokeCurrZone = zoneSpec && (zoneSpec.onInvoke ? this._zone : parentDelegate._invokeCurrZone);
            this._handleErrorZS = zoneSpec && (zoneSpec.onHandleError ? zoneSpec : parentDelegate._handleErrorZS);
            this._handleErrorDlgt = zoneSpec && (zoneSpec.onHandleError ? parentDelegate : parentDelegate._handleErrorDlgt);
            this._handleErrorCurrZone = zoneSpec && (zoneSpec.onHandleError ? this._zone : parentDelegate._handleErrorCurrZone);
            this._scheduleTaskZS = zoneSpec && (zoneSpec.onScheduleTask ? zoneSpec : parentDelegate._scheduleTaskZS);
            this._scheduleTaskDlgt = zoneSpec && (zoneSpec.onScheduleTask ? parentDelegate : parentDelegate._scheduleTaskDlgt);
            this._scheduleTaskCurrZone = zoneSpec && (zoneSpec.onScheduleTask ? this._zone : parentDelegate._scheduleTaskCurrZone);
            this._invokeTaskZS = zoneSpec && (zoneSpec.onInvokeTask ? zoneSpec : parentDelegate._invokeTaskZS);
            this._invokeTaskDlgt = zoneSpec && (zoneSpec.onInvokeTask ? parentDelegate : parentDelegate._invokeTaskDlgt);
            this._invokeTaskCurrZone = zoneSpec && (zoneSpec.onInvokeTask ? this._zone : parentDelegate._invokeTaskCurrZone);
            this._cancelTaskZS = zoneSpec && (zoneSpec.onCancelTask ? zoneSpec : parentDelegate._cancelTaskZS);
            this._cancelTaskDlgt = zoneSpec && (zoneSpec.onCancelTask ? parentDelegate : parentDelegate._cancelTaskDlgt);
            this._cancelTaskCurrZone = zoneSpec && (zoneSpec.onCancelTask ? this._zone : parentDelegate._cancelTaskCurrZone);
            this._hasTaskZS = null;
            this._hasTaskDlgt = null;
            this._hasTaskDlgtOwner = null;
            this._hasTaskCurrZone = null;
            const zoneSpecHasTask = zoneSpec && zoneSpec.onHasTask;
            const parentHasTask = parentDelegate && parentDelegate._hasTaskZS;
            if (zoneSpecHasTask || parentHasTask) {
              // If we need to report hasTask, than this ZS needs to do ref counting on tasks. In such
              // a case all task related interceptors must go through this ZD. We can't short circuit it.
              this._hasTaskZS = zoneSpecHasTask ? zoneSpec : DELEGATE_ZS;
              this._hasTaskDlgt = parentDelegate;
              this._hasTaskDlgtOwner = this;
              this._hasTaskCurrZone = this._zone;
              if (!zoneSpec.onScheduleTask) {
                this._scheduleTaskZS = DELEGATE_ZS;
                this._scheduleTaskDlgt = parentDelegate;
                this._scheduleTaskCurrZone = this._zone;
              }
              if (!zoneSpec.onInvokeTask) {
                this._invokeTaskZS = DELEGATE_ZS;
                this._invokeTaskDlgt = parentDelegate;
                this._invokeTaskCurrZone = this._zone;
              }
              if (!zoneSpec.onCancelTask) {
                this._cancelTaskZS = DELEGATE_ZS;
                this._cancelTaskDlgt = parentDelegate;
                this._cancelTaskCurrZone = this._zone;
              }
            }
          }
          fork(targetZone, zoneSpec) {
            return this._forkZS ? this._forkZS.onFork(this._forkDlgt, this.zone, targetZone, zoneSpec) : new ZoneImpl(targetZone, zoneSpec);
          }
          intercept(targetZone, callback, source) {
            return this._interceptZS ? this._interceptZS.onIntercept(this._interceptDlgt, this._interceptCurrZone, targetZone, callback, source) : callback;
          }
          invoke(targetZone, callback, applyThis, applyArgs, source) {
            return this._invokeZS ? this._invokeZS.onInvoke(this._invokeDlgt, this._invokeCurrZone, targetZone, callback, applyThis, applyArgs, source) : callback.apply(applyThis, applyArgs);
          }
          handleError(targetZone, error) {
            return this._handleErrorZS ? this._handleErrorZS.onHandleError(this._handleErrorDlgt, this._handleErrorCurrZone, targetZone, error) : true;
          }
          scheduleTask(targetZone, task) {
            let returnTask = task;
            if (this._scheduleTaskZS) {
              if (this._hasTaskZS) {
                returnTask._zoneDelegates.push(this._hasTaskDlgtOwner);
              }
              returnTask = this._scheduleTaskZS.onScheduleTask(this._scheduleTaskDlgt, this._scheduleTaskCurrZone, targetZone, task);
              if (!returnTask) returnTask = task;
            } else {
              if (task.scheduleFn) {
                task.scheduleFn(task);
              } else if (task.type == microTask) {
                scheduleMicroTask(task);
              } else {
                throw new Error('Task is missing scheduleFn.');
              }
            }
            return returnTask;
          }
          invokeTask(targetZone, task, applyThis, applyArgs) {
            return this._invokeTaskZS ? this._invokeTaskZS.onInvokeTask(this._invokeTaskDlgt, this._invokeTaskCurrZone, targetZone, task, applyThis, applyArgs) : task.callback.apply(applyThis, applyArgs);
          }
          cancelTask(targetZone, task) {
            let value;
            if (this._cancelTaskZS) {
              value = this._cancelTaskZS.onCancelTask(this._cancelTaskDlgt, this._cancelTaskCurrZone, targetZone, task);
            } else {
              if (!task.cancelFn) {
                throw Error('Task is not cancelable');
              }
              value = task.cancelFn(task);
            }
            return value;
          }
          hasTask(targetZone, isEmpty) {
            // hasTask should not throw error so other ZoneDelegate
            // can still trigger hasTask callback
            try {
              this._hasTaskZS && this._hasTaskZS.onHasTask(this._hasTaskDlgt, this._hasTaskCurrZone, targetZone, isEmpty);
            } catch (err) {
              this.handleError(targetZone, err);
            }
          }
          // tslint:disable-next-line:require-internal-with-underscore
          _updateTaskCount(type, count) {
            const counts = this._taskCounts;
            const prev = counts[type];
            const next = counts[type] = prev + count;
            if (next < 0) {
              throw new Error('More tasks executed then were scheduled.');
            }
            if (prev == 0 || next == 0) {
              const isEmpty = {
                microTask: counts['microTask'] > 0,
                macroTask: counts['macroTask'] > 0,
                eventTask: counts['eventTask'] > 0,
                change: type
              };
              this.hasTask(this._zone, isEmpty);
            }
          }
        }
        class ZoneTask {
          constructor(type, source, callback, options, scheduleFn, cancelFn) {
            // tslint:disable-next-line:require-internal-with-underscore
            this._zone = null;
            this.runCount = 0;
            // tslint:disable-next-line:require-internal-with-underscore
            this._zoneDelegates = null;
            // tslint:disable-next-line:require-internal-with-underscore
            this._state = 'notScheduled';
            this.type = type;
            this.source = source;
            this.data = options;
            this.scheduleFn = scheduleFn;
            this.cancelFn = cancelFn;
            if (!callback) {
              throw new Error('callback is not defined');
            }
            this.callback = callback;
            const self = this;
            // TODO: @JiaLiPassion options should have interface
            if (type === eventTask && options && options.useG) {
              this.invoke = ZoneTask.invokeTask;
            } else {
              this.invoke = function () {
                return ZoneTask.invokeTask.call(global, self, this, arguments);
              };
            }
          }
          static invokeTask(task, target, args) {
            if (!task) {
              task = this;
            }
            _numberOfNestedTaskFrames++;
            try {
              task.runCount++;
              return task.zone.runTask(task, target, args);
            } finally {
              if (_numberOfNestedTaskFrames == 1) {
                drainMicroTaskQueue();
              }
              _numberOfNestedTaskFrames--;
            }
          }
          get zone() {
            return this._zone;
          }
          get state() {
            return this._state;
          }
          cancelScheduleRequest() {
            this._transitionTo(notScheduled, scheduling);
          }
          // tslint:disable-next-line:require-internal-with-underscore
          _transitionTo(toState, fromState1, fromState2) {
            if (this._state === fromState1 || this._state === fromState2) {
              this._state = toState;
              if (toState == notScheduled) {
                this._zoneDelegates = null;
              }
            } else {
              throw new Error(`${this.type} '${this.source}': can not transition to '${toState}', expecting state '${fromState1}'${fromState2 ? " or '" + fromState2 + "'" : ''}, was '${this._state}'.`);
            }
          }
          toString() {
            if (this.data && typeof this.data.handleId !== 'undefined') {
              return this.data.handleId.toString();
            } else {
              return Object.prototype.toString.call(this);
            }
          }
          // add toJSON method to prevent cyclic error when
          // call JSON.stringify(zoneTask)
          toJSON() {
            return {
              type: this.type,
              state: this.state,
              source: this.source,
              zone: this.zone.name,
              runCount: this.runCount
            };
          }
        }
        //////////////////////////////////////////////////////
        //////////////////////////////////////////////////////
        ///  MICROTASK QUEUE
        //////////////////////////////////////////////////////
        //////////////////////////////////////////////////////
        const symbolSetTimeout = __symbol__('setTimeout');
        const symbolPromise = __symbol__('Promise');
        const symbolThen = __symbol__('then');
        let _microTaskQueue = [];
        let _isDrainingMicrotaskQueue = false;
        let nativeMicroTaskQueuePromise;
        function nativeScheduleMicroTask(func) {
          if (!nativeMicroTaskQueuePromise) {
            if (global[symbolPromise]) {
              nativeMicroTaskQueuePromise = global[symbolPromise].resolve(0);
            }
          }
          if (nativeMicroTaskQueuePromise) {
            let nativeThen = nativeMicroTaskQueuePromise[symbolThen];
            if (!nativeThen) {
              // native Promise is not patchable, we need to use `then` directly
              // issue 1078
              nativeThen = nativeMicroTaskQueuePromise['then'];
            }
            nativeThen.call(nativeMicroTaskQueuePromise, func);
          } else {
            global[symbolSetTimeout](func, 0);
          }
        }
        function scheduleMicroTask(task) {
          // if we are not running in any task, and there has not been anything scheduled
          // we must bootstrap the initial task creation by manually scheduling the drain
          if (_numberOfNestedTaskFrames === 0 && _microTaskQueue.length === 0) {
            // We are not running in Task, so we need to kickstart the microtask queue.
            nativeScheduleMicroTask(drainMicroTaskQueue);
          }
          task && _microTaskQueue.push(task);
        }
        function drainMicroTaskQueue() {
          if (!_isDrainingMicrotaskQueue) {
            _isDrainingMicrotaskQueue = true;
            while (_microTaskQueue.length) {
              const queue = _microTaskQueue;
              _microTaskQueue = [];
              for (let i = 0; i < queue.length; i++) {
                const task = queue[i];
                try {
                  task.zone.runTask(task, null, null);
                } catch (error) {
                  _api.onUnhandledError(error);
                }
              }
            }
            _api.microtaskDrainDone();
            _isDrainingMicrotaskQueue = false;
          }
        }
        //////////////////////////////////////////////////////
        //////////////////////////////////////////////////////
        ///  BOOTSTRAP
        //////////////////////////////////////////////////////
        //////////////////////////////////////////////////////
        const NO_ZONE = {
          name: 'NO ZONE'
        };
        const notScheduled = 'notScheduled',
          scheduling = 'scheduling',
          scheduled = 'scheduled',
          running = 'running',
          canceling = 'canceling',
          unknown = 'unknown';
        const microTask = 'microTask',
          macroTask = 'macroTask',
          eventTask = 'eventTask';
        const patches = {};
        const _api = {
          symbol: __symbol__,
          currentZoneFrame: () => _currentZoneFrame,
          onUnhandledError: noop,
          microtaskDrainDone: noop,
          scheduleMicroTask: scheduleMicroTask,
          showUncaughtError: () => !ZoneImpl[__symbol__('ignoreConsoleErrorUncaughtError')],
          patchEventTarget: () => [],
          patchOnProperties: noop,
          patchMethod: () => noop,
          bindArguments: () => [],
          patchThen: () => noop,
          patchMacroTask: () => noop,
          patchEventPrototype: () => noop,
          isIEOrEdge: () => false,
          getGlobalObjects: () => undefined,
          ObjectDefineProperty: () => noop,
          ObjectGetOwnPropertyDescriptor: () => undefined,
          ObjectCreate: () => undefined,
          ArraySlice: () => [],
          patchClass: () => noop,
          wrapWithCurrentZone: () => noop,
          filterProperties: () => [],
          attachOriginToPatched: () => noop,
          _redefineProperty: () => noop,
          patchCallbacks: () => noop,
          nativeScheduleMicroTask: nativeScheduleMicroTask
        };
        let _currentZoneFrame = {
          parent: null,
          zone: new ZoneImpl(null, null)
        };
        let _currentTask = null;
        let _numberOfNestedTaskFrames = 0;
        function noop() {}
        performanceMeasure('Zone', 'Zone');
        return ZoneImpl;
      }
      function loadZone() {
        // if global['Zone'] already exists (maybe zone.js was already loaded or
        // some other lib also registered a global object named Zone), we may need
        // to throw an error, but sometimes user may not want this error.
        // For example,
        // we have two web pages, page1 includes zone.js, page2 doesn't.
        // and the 1st time user load page1 and page2, everything work fine,
        // but when user load page2 again, error occurs because global['Zone'] already exists.
        // so we add a flag to let user choose whether to throw this error or not.
        // By default, if existing Zone is from zone.js, we will not throw the error.
        const global = globalThis;
        const checkDuplicate = global[__symbol__('forceDuplicateZoneCheck')] === true;
        if (global['Zone'] && (checkDuplicate || typeof global['Zone'].__symbol__ !== 'function')) {
          throw new Error('Zone already loaded.');
        }
        // Initialize global `Zone` constant.
        global['Zone'] ??= initZone();
        return global['Zone'];
      }

      /**
       * Suppress closure compiler errors about unknown 'Zone' variable
       * @fileoverview
       * @suppress {undefinedVars,globalThis,missingRequire}
       */
      // issue #989, to reduce bundle size, use short name
      /** Object.getOwnPropertyDescriptor */
      const ObjectGetOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
      /** Object.defineProperty */
      const ObjectDefineProperty = Object.defineProperty;
      /** Object.getPrototypeOf */
      const ObjectGetPrototypeOf = Object.getPrototypeOf;
      /** Object.create */
      const ObjectCreate = Object.create;
      /** Array.prototype.slice */
      const ArraySlice = Array.prototype.slice;
      /** addEventListener string const */
      const ADD_EVENT_LISTENER_STR = 'addEventListener';
      /** removeEventListener string const */
      const REMOVE_EVENT_LISTENER_STR = 'removeEventListener';
      /** zoneSymbol addEventListener */
      const ZONE_SYMBOL_ADD_EVENT_LISTENER = __symbol__(ADD_EVENT_LISTENER_STR);
      /** zoneSymbol removeEventListener */
      const ZONE_SYMBOL_REMOVE_EVENT_LISTENER = __symbol__(REMOVE_EVENT_LISTENER_STR);
      /** true string const */
      const TRUE_STR = 'true';
      /** false string const */
      const FALSE_STR = 'false';
      /** Zone symbol prefix string const. */
      const ZONE_SYMBOL_PREFIX = __symbol__('');
      function wrapWithCurrentZone(callback, source) {
        return Zone.current.wrap(callback, source);
      }
      function scheduleMacroTaskWithCurrentZone(source, callback, data, customSchedule, customCancel) {
        return Zone.current.scheduleMacroTask(source, callback, data, customSchedule, customCancel);
      }
      const zoneSymbol = __symbol__;
      const isWindowExists = typeof window !== 'undefined';
      const internalWindow = isWindowExists ? window : undefined;
      const _global = isWindowExists && internalWindow || globalThis;
      const REMOVE_ATTRIBUTE = 'removeAttribute';
      function bindArguments(args, source) {
        for (let i = args.length - 1; i >= 0; i--) {
          if (typeof args[i] === 'function') {
            args[i] = wrapWithCurrentZone(args[i], source + '_' + i);
          }
        }
        return args;
      }
      function patchPrototype(prototype, fnNames) {
        const source = prototype.constructor['name'];
        for (let i = 0; i < fnNames.length; i++) {
          const name = fnNames[i];
          const delegate = prototype[name];
          if (delegate) {
            const prototypeDesc = ObjectGetOwnPropertyDescriptor(prototype, name);
            if (!isPropertyWritable(prototypeDesc)) {
              continue;
            }
            prototype[name] = (delegate => {
              const patched = function () {
                return delegate.apply(this, bindArguments(arguments, source + '.' + name));
              };
              attachOriginToPatched(patched, delegate);
              return patched;
            })(delegate);
          }
        }
      }
      function isPropertyWritable(propertyDesc) {
        if (!propertyDesc) {
          return true;
        }
        if (propertyDesc.writable === false) {
          return false;
        }
        return !(typeof propertyDesc.get === 'function' && typeof propertyDesc.set === 'undefined');
      }
      const isWebWorker = typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope;
      // Make sure to access `process` through `_global` so that WebPack does not accidentally browserify
      // this code.
      const isNode = !('nw' in _global) && typeof _global.process !== 'undefined' && _global.process.toString() === '[object process]';
      const isBrowser = !isNode && !isWebWorker && !!(isWindowExists && internalWindow['HTMLElement']);
      // we are in electron of nw, so we are both browser and nodejs
      // Make sure to access `process` through `_global` so that WebPack does not accidentally browserify
      // this code.
      const isMix = typeof _global.process !== 'undefined' && _global.process.toString() === '[object process]' && !isWebWorker && !!(isWindowExists && internalWindow['HTMLElement']);
      const zoneSymbolEventNames$1 = {};
      const enableBeforeunloadSymbol = zoneSymbol('enable_beforeunload');
      const wrapFn = function (event) {
        // https://github.com/angular/zone.js/issues/911, in IE, sometimes
        // event will be undefined, so we need to use window.event
        event = event || _global.event;
        if (!event) {
          return;
        }
        let eventNameSymbol = zoneSymbolEventNames$1[event.type];
        if (!eventNameSymbol) {
          eventNameSymbol = zoneSymbolEventNames$1[event.type] = zoneSymbol('ON_PROPERTY' + event.type);
        }
        const target = this || event.target || _global;
        const listener = target[eventNameSymbol];
        let result;
        if (isBrowser && target === internalWindow && event.type === 'error') {
          // window.onerror have different signature
          // https://developer.mozilla.org/en-US/docs/Web/API/GlobalEventHandlers/onerror#window.onerror
          // and onerror callback will prevent default when callback return true
          const errorEvent = event;
          result = listener && listener.call(this, errorEvent.message, errorEvent.filename, errorEvent.lineno, errorEvent.colno, errorEvent.error);
          if (result === true) {
            event.preventDefault();
          }
        } else {
          result = listener && listener.apply(this, arguments);
          if (
          // https://github.com/angular/angular/issues/47579
          // https://www.w3.org/TR/2011/WD-html5-20110525/history.html#beforeunloadevent
          // This is the only specific case we should check for. The spec defines that the
          // `returnValue` attribute represents the message to show the user. When the event
          // is created, this attribute must be set to the empty string.
          event.type === 'beforeunload' &&
          // To prevent any breaking changes resulting from this change, given that
          // it was already causing a significant number of failures in G3, we have hidden
          // that behavior behind a global configuration flag. Consumers can enable this
          // flag explicitly if they want the `beforeunload` event to be handled as defined
          // in the specification.
          _global[enableBeforeunloadSymbol] &&
          // The IDL event definition is `attribute DOMString returnValue`, so we check whether
          // `typeof result` is a string.
          typeof result === 'string') {
            event.returnValue = result;
          } else if (result != undefined && !result) {
            event.preventDefault();
          }
        }
        return result;
      };
      function patchProperty(obj, prop, prototype) {
        let desc = ObjectGetOwnPropertyDescriptor(obj, prop);
        if (!desc && prototype) {
          // when patch window object, use prototype to check prop exist or not
          const prototypeDesc = ObjectGetOwnPropertyDescriptor(prototype, prop);
          if (prototypeDesc) {
            desc = {
              enumerable: true,
              configurable: true
            };
          }
        }
        // if the descriptor not exists or is not configurable
        // just return
        if (!desc || !desc.configurable) {
          return;
        }
        const onPropPatchedSymbol = zoneSymbol('on' + prop + 'patched');
        if (obj.hasOwnProperty(onPropPatchedSymbol) && obj[onPropPatchedSymbol]) {
          return;
        }
        // A property descriptor cannot have getter/setter and be writable
        // deleting the writable and value properties avoids this error:
        //
        // TypeError: property descriptors must not specify a value or be writable when a
        // getter or setter has been specified
        delete desc.writable;
        delete desc.value;
        const originalDescGet = desc.get;
        const originalDescSet = desc.set;
        // slice(2) cuz 'onclick' -> 'click', etc
        const eventName = prop.slice(2);
        let eventNameSymbol = zoneSymbolEventNames$1[eventName];
        if (!eventNameSymbol) {
          eventNameSymbol = zoneSymbolEventNames$1[eventName] = zoneSymbol('ON_PROPERTY' + eventName);
        }
        desc.set = function (newValue) {
          // in some of windows's onproperty callback, this is undefined
          // so we need to check it
          let target = this;
          if (!target && obj === _global) {
            target = _global;
          }
          if (!target) {
            return;
          }
          const previousValue = target[eventNameSymbol];
          if (typeof previousValue === 'function') {
            target.removeEventListener(eventName, wrapFn);
          }
          // issue #978, when onload handler was added before loading zone.js
          // we should remove it with originalDescSet
          originalDescSet && originalDescSet.call(target, null);
          target[eventNameSymbol] = newValue;
          if (typeof newValue === 'function') {
            target.addEventListener(eventName, wrapFn, false);
          }
        };
        // The getter would return undefined for unassigned properties but the default value of an
        // unassigned property is null
        desc.get = function () {
          // in some of windows's onproperty callback, this is undefined
          // so we need to check it
          let target = this;
          if (!target && obj === _global) {
            target = _global;
          }
          if (!target) {
            return null;
          }
          const listener = target[eventNameSymbol];
          if (listener) {
            return listener;
          } else if (originalDescGet) {
            // result will be null when use inline event attribute,
            // such as <button onclick="func();">OK</button>
            // because the onclick function is internal raw uncompiled handler
            // the onclick will be evaluated when first time event was triggered or
            // the property is accessed, https://github.com/angular/zone.js/issues/525
            // so we should use original native get to retrieve the handler
            let value = originalDescGet.call(this);
            if (value) {
              desc.set.call(this, value);
              if (typeof target[REMOVE_ATTRIBUTE] === 'function') {
                target.removeAttribute(prop);
              }
              return value;
            }
          }
          return null;
        };
        ObjectDefineProperty(obj, prop, desc);
        obj[onPropPatchedSymbol] = true;
      }
      function patchOnProperties(obj, properties, prototype) {
        if (properties) {
          for (let i = 0; i < properties.length; i++) {
            patchProperty(obj, 'on' + properties[i], prototype);
          }
        } else {
          const onProperties = [];
          for (const prop in obj) {
            if (prop.slice(0, 2) == 'on') {
              onProperties.push(prop);
            }
          }
          for (let j = 0; j < onProperties.length; j++) {
            patchProperty(obj, onProperties[j], prototype);
          }
        }
      }
      const originalInstanceKey = zoneSymbol('originalInstance');
      // wrap some native API on `window`
      function patchClass(className) {
        const OriginalClass = _global[className];
        if (!OriginalClass) return;
        // keep original class in global
        _global[zoneSymbol(className)] = OriginalClass;
        _global[className] = function () {
          const a = bindArguments(arguments, className);
          switch (a.length) {
            case 0:
              this[originalInstanceKey] = new OriginalClass();
              break;
            case 1:
              this[originalInstanceKey] = new OriginalClass(a[0]);
              break;
            case 2:
              this[originalInstanceKey] = new OriginalClass(a[0], a[1]);
              break;
            case 3:
              this[originalInstanceKey] = new OriginalClass(a[0], a[1], a[2]);
              break;
            case 4:
              this[originalInstanceKey] = new OriginalClass(a[0], a[1], a[2], a[3]);
              break;
            default:
              throw new Error('Arg list too long.');
          }
        };
        // attach original delegate to patched function
        attachOriginToPatched(_global[className], OriginalClass);
        const instance = new OriginalClass(function () {});
        let prop;
        for (prop in instance) {
          // https://bugs.webkit.org/show_bug.cgi?id=44721
          if (className === 'XMLHttpRequest' && prop === 'responseBlob') continue;
          (function (prop) {
            if (typeof instance[prop] === 'function') {
              _global[className].prototype[prop] = function () {
                return this[originalInstanceKey][prop].apply(this[originalInstanceKey], arguments);
              };
            } else {
              ObjectDefineProperty(_global[className].prototype, prop, {
                set: function (fn) {
                  if (typeof fn === 'function') {
                    this[originalInstanceKey][prop] = wrapWithCurrentZone(fn, className + '.' + prop);
                    // keep callback in wrapped function so we can
                    // use it in Function.prototype.toString to return
                    // the native one.
                    attachOriginToPatched(this[originalInstanceKey][prop], fn);
                  } else {
                    this[originalInstanceKey][prop] = fn;
                  }
                },
                get: function () {
                  return this[originalInstanceKey][prop];
                }
              });
            }
          })(prop);
        }
        for (prop in OriginalClass) {
          if (prop !== 'prototype' && OriginalClass.hasOwnProperty(prop)) {
            _global[className][prop] = OriginalClass[prop];
          }
        }
      }
      function patchMethod(target, name, patchFn) {
        let proto = target;
        while (proto && !proto.hasOwnProperty(name)) {
          proto = ObjectGetPrototypeOf(proto);
        }
        if (!proto && target[name]) {
          // somehow we did not find it, but we can see it. This happens on IE for Window properties.
          proto = target;
        }
        const delegateName = zoneSymbol(name);
        let delegate = null;
        if (proto && (!(delegate = proto[delegateName]) || !proto.hasOwnProperty(delegateName))) {
          delegate = proto[delegateName] = proto[name];
          // check whether proto[name] is writable
          // some property is readonly in safari, such as HtmlCanvasElement.prototype.toBlob
          const desc = proto && ObjectGetOwnPropertyDescriptor(proto, name);
          if (isPropertyWritable(desc)) {
            const patchDelegate = patchFn(delegate, delegateName, name);
            proto[name] = function () {
              return patchDelegate(this, arguments);
            };
            attachOriginToPatched(proto[name], delegate);
          }
        }
        return delegate;
      }
      // TODO: @JiaLiPassion, support cancel task later if necessary
      function patchMacroTask(obj, funcName, metaCreator) {
        let setNative = null;
        function scheduleTask(task) {
          const data = task.data;
          data.args[data.cbIdx] = function () {
            task.invoke.apply(this, arguments);
          };
          setNative.apply(data.target, data.args);
          return task;
        }
        setNative = patchMethod(obj, funcName, delegate => function (self, args) {
          const meta = metaCreator(self, args);
          if (meta.cbIdx >= 0 && typeof args[meta.cbIdx] === 'function') {
            return scheduleMacroTaskWithCurrentZone(meta.name, args[meta.cbIdx], meta, scheduleTask);
          } else {
            // cause an error by calling it directly.
            return delegate.apply(self, args);
          }
        });
      }
      function attachOriginToPatched(patched, original) {
        patched[zoneSymbol('OriginalDelegate')] = original;
      }
      let isDetectedIEOrEdge = false;
      let ieOrEdge = false;
      function isIE() {
        try {
          const ua = internalWindow.navigator.userAgent;
          if (ua.indexOf('MSIE ') !== -1 || ua.indexOf('Trident/') !== -1) {
            return true;
          }
        } catch (error) {}
        return false;
      }
      function isIEOrEdge() {
        if (isDetectedIEOrEdge) {
          return ieOrEdge;
        }
        isDetectedIEOrEdge = true;
        try {
          const ua = internalWindow.navigator.userAgent;
          if (ua.indexOf('MSIE ') !== -1 || ua.indexOf('Trident/') !== -1 || ua.indexOf('Edge/') !== -1) {
            ieOrEdge = true;
          }
        } catch (error) {}
        return ieOrEdge;
      }
      function isFunction(value) {
        return typeof value === 'function';
      }
      function isNumber(value) {
        return typeof value === 'number';
      }

      /**
       * @fileoverview
       * @suppress {missingRequire}
       */
      // Note that passive event listeners are now supported by most modern browsers,
      // including Chrome, Firefox, Safari, and Edge. There's a pending change that
      // would remove support for legacy browsers by zone.js. Removing `passiveSupported`
      // from the codebase will reduce the final code size for existing apps that still use zone.js.
      let passiveSupported = false;
      if (typeof window !== 'undefined') {
        try {
          const options = Object.defineProperty({}, 'passive', {
            get: function () {
              passiveSupported = true;
            }
          });
          // Note: We pass the `options` object as the event handler too. This is not compatible with the
          // signature of `addEventListener` or `removeEventListener` but enables us to remove the handler
          // without an actual handler.
          window.addEventListener('test', options, options);
          window.removeEventListener('test', options, options);
        } catch (err) {
          passiveSupported = false;
        }
      }
      // an identifier to tell ZoneTask do not create a new invoke closure
      const OPTIMIZED_ZONE_EVENT_TASK_DATA = {
        useG: true
      };
      const zoneSymbolEventNames = {};
      const globalSources = {};
      const EVENT_NAME_SYMBOL_REGX = new RegExp('^' + ZONE_SYMBOL_PREFIX + '(\\w+)(true|false)$');
      const IMMEDIATE_PROPAGATION_SYMBOL = zoneSymbol('propagationStopped');
      function prepareEventNames(eventName, eventNameToString) {
        const falseEventName = (eventNameToString ? eventNameToString(eventName) : eventName) + FALSE_STR;
        const trueEventName = (eventNameToString ? eventNameToString(eventName) : eventName) + TRUE_STR;
        const symbol = ZONE_SYMBOL_PREFIX + falseEventName;
        const symbolCapture = ZONE_SYMBOL_PREFIX + trueEventName;
        zoneSymbolEventNames[eventName] = {};
        zoneSymbolEventNames[eventName][FALSE_STR] = symbol;
        zoneSymbolEventNames[eventName][TRUE_STR] = symbolCapture;
      }
      function patchEventTarget(_global, api, apis, patchOptions) {
        const ADD_EVENT_LISTENER = patchOptions && patchOptions.add || ADD_EVENT_LISTENER_STR;
        const REMOVE_EVENT_LISTENER = patchOptions && patchOptions.rm || REMOVE_EVENT_LISTENER_STR;
        const LISTENERS_EVENT_LISTENER = patchOptions && patchOptions.listeners || 'eventListeners';
        const REMOVE_ALL_LISTENERS_EVENT_LISTENER = patchOptions && patchOptions.rmAll || 'removeAllListeners';
        const zoneSymbolAddEventListener = zoneSymbol(ADD_EVENT_LISTENER);
        const ADD_EVENT_LISTENER_SOURCE = '.' + ADD_EVENT_LISTENER + ':';
        const PREPEND_EVENT_LISTENER = 'prependListener';
        const PREPEND_EVENT_LISTENER_SOURCE = '.' + PREPEND_EVENT_LISTENER + ':';
        const invokeTask = function (task, target, event) {
          // for better performance, check isRemoved which is set
          // by removeEventListener
          if (task.isRemoved) {
            return;
          }
          const delegate = task.callback;
          if (typeof delegate === 'object' && delegate.handleEvent) {
            // create the bind version of handleEvent when invoke
            task.callback = event => delegate.handleEvent(event);
            task.originalDelegate = delegate;
          }
          // invoke static task.invoke
          // need to try/catch error here, otherwise, the error in one event listener
          // will break the executions of the other event listeners. Also error will
          // not remove the event listener when `once` options is true.
          let error;
          try {
            task.invoke(task, target, [event]);
          } catch (err) {
            error = err;
          }
          const options = task.options;
          if (options && typeof options === 'object' && options.once) {
            // if options.once is true, after invoke once remove listener here
            // only browser need to do this, nodejs eventEmitter will cal removeListener
            // inside EventEmitter.once
            const delegate = task.originalDelegate ? task.originalDelegate : task.callback;
            target[REMOVE_EVENT_LISTENER].call(target, event.type, delegate, options);
          }
          return error;
        };
        function globalCallback(context, event, isCapture) {
          // https://github.com/angular/zone.js/issues/911, in IE, sometimes
          // event will be undefined, so we need to use window.event
          event = event || _global.event;
          if (!event) {
            return;
          }
          // event.target is needed for Samsung TV and SourceBuffer
          // || global is needed https://github.com/angular/zone.js/issues/190
          const target = context || event.target || _global;
          const tasks = target[zoneSymbolEventNames[event.type][isCapture ? TRUE_STR : FALSE_STR]];
          if (tasks) {
            const errors = [];
            // invoke all tasks which attached to current target with given event.type and capture = false
            // for performance concern, if task.length === 1, just invoke
            if (tasks.length === 1) {
              const err = invokeTask(tasks[0], target, event);
              err && errors.push(err);
            } else {
              // https://github.com/angular/zone.js/issues/836
              // copy the tasks array before invoke, to avoid
              // the callback will remove itself or other listener
              const copyTasks = tasks.slice();
              for (let i = 0; i < copyTasks.length; i++) {
                if (event && event[IMMEDIATE_PROPAGATION_SYMBOL] === true) {
                  break;
                }
                const err = invokeTask(copyTasks[i], target, event);
                err && errors.push(err);
              }
            }
            // Since there is only one error, we don't need to schedule microTask
            // to throw the error.
            if (errors.length === 1) {
              throw errors[0];
            } else {
              for (let i = 0; i < errors.length; i++) {
                const err = errors[i];
                api.nativeScheduleMicroTask(() => {
                  throw err;
                });
              }
            }
          }
        }
        // global shared zoneAwareCallback to handle all event callback with capture = false
        const globalZoneAwareCallback = function (event) {
          return globalCallback(this, event, false);
        };
        // global shared zoneAwareCallback to handle all event callback with capture = true
        const globalZoneAwareCaptureCallback = function (event) {
          return globalCallback(this, event, true);
        };
        function patchEventTargetMethods(obj, patchOptions) {
          if (!obj) {
            return false;
          }
          let useGlobalCallback = true;
          if (patchOptions && patchOptions.useG !== undefined) {
            useGlobalCallback = patchOptions.useG;
          }
          const validateHandler = patchOptions && patchOptions.vh;
          let checkDuplicate = true;
          if (patchOptions && patchOptions.chkDup !== undefined) {
            checkDuplicate = patchOptions.chkDup;
          }
          let returnTarget = false;
          if (patchOptions && patchOptions.rt !== undefined) {
            returnTarget = patchOptions.rt;
          }
          let proto = obj;
          while (proto && !proto.hasOwnProperty(ADD_EVENT_LISTENER)) {
            proto = ObjectGetPrototypeOf(proto);
          }
          if (!proto && obj[ADD_EVENT_LISTENER]) {
            // somehow we did not find it, but we can see it. This happens on IE for Window properties.
            proto = obj;
          }
          if (!proto) {
            return false;
          }
          if (proto[zoneSymbolAddEventListener]) {
            return false;
          }
          const eventNameToString = patchOptions && patchOptions.eventNameToString;
          // We use a shared global `taskData` to pass data for `scheduleEventTask`,
          // eliminating the need to create a new object solely for passing data.
          // WARNING: This object has a static lifetime, meaning it is not created
          // each time `addEventListener` is called. It is instantiated only once
          // and captured by reference inside the `addEventListener` and
          // `removeEventListener` functions. Do not add any new properties to this
          // object, as doing so would necessitate maintaining the information
          // between `addEventListener` calls.
          const taskData = {};
          const nativeAddEventListener = proto[zoneSymbolAddEventListener] = proto[ADD_EVENT_LISTENER];
          const nativeRemoveEventListener = proto[zoneSymbol(REMOVE_EVENT_LISTENER)] = proto[REMOVE_EVENT_LISTENER];
          const nativeListeners = proto[zoneSymbol(LISTENERS_EVENT_LISTENER)] = proto[LISTENERS_EVENT_LISTENER];
          const nativeRemoveAllListeners = proto[zoneSymbol(REMOVE_ALL_LISTENERS_EVENT_LISTENER)] = proto[REMOVE_ALL_LISTENERS_EVENT_LISTENER];
          let nativePrependEventListener;
          if (patchOptions && patchOptions.prepend) {
            nativePrependEventListener = proto[zoneSymbol(patchOptions.prepend)] = proto[patchOptions.prepend];
          }
          /**
           * This util function will build an option object with passive option
           * to handle all possible input from the user.
           */
          function buildEventListenerOptions(options, passive) {
            if (!passiveSupported && typeof options === 'object' && options) {
              // doesn't support passive but user want to pass an object as options.
              // this will not work on some old browser, so we just pass a boolean
              // as useCapture parameter
              return !!options.capture;
            }
            if (!passiveSupported || !passive) {
              return options;
            }
            if (typeof options === 'boolean') {
              return {
                capture: options,
                passive: true
              };
            }
            if (!options) {
              return {
                passive: true
              };
            }
            if (typeof options === 'object' && options.passive !== false) {
              return {
                ...options,
                passive: true
              };
            }
            return options;
          }
          const customScheduleGlobal = function (task) {
            // if there is already a task for the eventName + capture,
            // just return, because we use the shared globalZoneAwareCallback here.
            if (taskData.isExisting) {
              return;
            }
            return nativeAddEventListener.call(taskData.target, taskData.eventName, taskData.capture ? globalZoneAwareCaptureCallback : globalZoneAwareCallback, taskData.options);
          };
          /**
           * In the context of events and listeners, this function will be
           * called at the end by `cancelTask`, which, in turn, calls `task.cancelFn`.
           * Cancelling a task is primarily used to remove event listeners from
           * the task target.
           */
          const customCancelGlobal = function (task) {
            // if task is not marked as isRemoved, this call is directly
            // from Zone.prototype.cancelTask, we should remove the task
            // from tasksList of target first
            if (!task.isRemoved) {
              const symbolEventNames = zoneSymbolEventNames[task.eventName];
              let symbolEventName;
              if (symbolEventNames) {
                symbolEventName = symbolEventNames[task.capture ? TRUE_STR : FALSE_STR];
              }
              const existingTasks = symbolEventName && task.target[symbolEventName];
              if (existingTasks) {
                for (let i = 0; i < existingTasks.length; i++) {
                  const existingTask = existingTasks[i];
                  if (existingTask === task) {
                    existingTasks.splice(i, 1);
                    // set isRemoved to data for faster invokeTask check
                    task.isRemoved = true;
                    if (task.removeAbortListener) {
                      task.removeAbortListener();
                      task.removeAbortListener = null;
                    }
                    if (existingTasks.length === 0) {
                      // all tasks for the eventName + capture have gone,
                      // remove globalZoneAwareCallback and remove the task cache from target
                      task.allRemoved = true;
                      task.target[symbolEventName] = null;
                    }
                    break;
                  }
                }
              }
            }
            // if all tasks for the eventName + capture have gone,
            // we will really remove the global event callback,
            // if not, return
            if (!task.allRemoved) {
              return;
            }
            return nativeRemoveEventListener.call(task.target, task.eventName, task.capture ? globalZoneAwareCaptureCallback : globalZoneAwareCallback, task.options);
          };
          const customScheduleNonGlobal = function (task) {
            return nativeAddEventListener.call(taskData.target, taskData.eventName, task.invoke, taskData.options);
          };
          const customSchedulePrepend = function (task) {
            return nativePrependEventListener.call(taskData.target, taskData.eventName, task.invoke, taskData.options);
          };
          const customCancelNonGlobal = function (task) {
            return nativeRemoveEventListener.call(task.target, task.eventName, task.invoke, task.options);
          };
          const customSchedule = useGlobalCallback ? customScheduleGlobal : customScheduleNonGlobal;
          const customCancel = useGlobalCallback ? customCancelGlobal : customCancelNonGlobal;
          const compareTaskCallbackVsDelegate = function (task, delegate) {
            const typeOfDelegate = typeof delegate;
            return typeOfDelegate === 'function' && task.callback === delegate || typeOfDelegate === 'object' && task.originalDelegate === delegate;
          };
          const compare = patchOptions && patchOptions.diff ? patchOptions.diff : compareTaskCallbackVsDelegate;
          const unpatchedEvents = Zone[zoneSymbol('UNPATCHED_EVENTS')];
          const passiveEvents = _global[zoneSymbol('PASSIVE_EVENTS')];
          function copyEventListenerOptions(options) {
            if (typeof options === 'object' && options !== null) {
              // We need to destructure the target `options` object since it may
              // be frozen or sealed (possibly provided implicitly by a third-party
              // library), or its properties may be readonly.
              const newOptions = {
                ...options
              };
              // The `signal` option was recently introduced, which caused regressions in
              // third-party scenarios where `AbortController` was directly provided to
              // `addEventListener` as options. For instance, in cases like
              // `document.addEventListener('keydown', callback, abortControllerInstance)`,
              // which is valid because `AbortController` includes a `signal` getter, spreading
              // `{...options}` wouldn't copy the `signal`. Additionally, using `Object.create`
              // isn't feasible since `AbortController` is a built-in object type, and attempting
              // to create a new object directly with it as the prototype might result in
              // unexpected behavior.
              if (options.signal) {
                newOptions.signal = options.signal;
              }
              return newOptions;
            }
            return options;
          }
          const makeAddListener = function (nativeListener, addSource, customScheduleFn, customCancelFn, returnTarget = false, prepend = false) {
            return function () {
              const target = this || _global;
              let eventName = arguments[0];
              if (patchOptions && patchOptions.transferEventName) {
                eventName = patchOptions.transferEventName(eventName);
              }
              let delegate = arguments[1];
              if (!delegate) {
                return nativeListener.apply(this, arguments);
              }
              if (isNode && eventName === 'uncaughtException') {
                // don't patch uncaughtException of nodejs to prevent endless loop
                return nativeListener.apply(this, arguments);
              }
              // don't create the bind delegate function for handleEvent
              // case here to improve addEventListener performance
              // we will create the bind delegate when invoke
              let isHandleEvent = false;
              if (typeof delegate !== 'function') {
                if (!delegate.handleEvent) {
                  return nativeListener.apply(this, arguments);
                }
                isHandleEvent = true;
              }
              if (validateHandler && !validateHandler(nativeListener, delegate, target, arguments)) {
                return;
              }
              const passive = passiveSupported && !!passiveEvents && passiveEvents.indexOf(eventName) !== -1;
              const options = copyEventListenerOptions(buildEventListenerOptions(arguments[2], passive));
              const signal = options?.signal;
              if (signal?.aborted) {
                // the signal is an aborted one, just return without attaching the event listener.
                return;
              }
              if (unpatchedEvents) {
                // check unpatched list
                for (let i = 0; i < unpatchedEvents.length; i++) {
                  if (eventName === unpatchedEvents[i]) {
                    if (passive) {
                      return nativeListener.call(target, eventName, delegate, options);
                    } else {
                      return nativeListener.apply(this, arguments);
                    }
                  }
                }
              }
              const capture = !options ? false : typeof options === 'boolean' ? true : options.capture;
              const once = options && typeof options === 'object' ? options.once : false;
              const zone = Zone.current;
              let symbolEventNames = zoneSymbolEventNames[eventName];
              if (!symbolEventNames) {
                prepareEventNames(eventName, eventNameToString);
                symbolEventNames = zoneSymbolEventNames[eventName];
              }
              const symbolEventName = symbolEventNames[capture ? TRUE_STR : FALSE_STR];
              let existingTasks = target[symbolEventName];
              let isExisting = false;
              if (existingTasks) {
                // already have task registered
                isExisting = true;
                if (checkDuplicate) {
                  for (let i = 0; i < existingTasks.length; i++) {
                    if (compare(existingTasks[i], delegate)) {
                      // same callback, same capture, same event name, just return
                      return;
                    }
                  }
                }
              } else {
                existingTasks = target[symbolEventName] = [];
              }
              let source;
              const constructorName = target.constructor['name'];
              const targetSource = globalSources[constructorName];
              if (targetSource) {
                source = targetSource[eventName];
              }
              if (!source) {
                source = constructorName + addSource + (eventNameToString ? eventNameToString(eventName) : eventName);
              }
              // In the code below, `options` should no longer be reassigned; instead, it
              // should only be mutated. This is because we pass that object to the native
              // `addEventListener`.
              // It's generally recommended to use the same object reference for options.
              // This ensures consistency and avoids potential issues.
              taskData.options = options;
              if (once) {
                // When using `addEventListener` with the `once` option, we don't pass
                // the `once` option directly to the native `addEventListener` method.
                // Instead, we keep the `once` setting and handle it ourselves.
                taskData.options.once = false;
              }
              taskData.target = target;
              taskData.capture = capture;
              taskData.eventName = eventName;
              taskData.isExisting = isExisting;
              const data = useGlobalCallback ? OPTIMIZED_ZONE_EVENT_TASK_DATA : undefined;
              // keep taskData into data to allow onScheduleEventTask to access the task information
              if (data) {
                data.taskData = taskData;
              }
              if (signal) {
                // When using `addEventListener` with the `signal` option, we don't pass
                // the `signal` option directly to the native `addEventListener` method.
                // Instead, we keep the `signal` setting and handle it ourselves.
                taskData.options.signal = undefined;
              }
              // The `scheduleEventTask` function will ultimately call `customScheduleGlobal`,
              // which in turn calls the native `addEventListener`. This is why `taskData.options`
              // is updated before scheduling the task, as `customScheduleGlobal` uses
              // `taskData.options` to pass it to the native `addEventListener`.
              const task = zone.scheduleEventTask(source, delegate, data, customScheduleFn, customCancelFn);
              if (signal) {
                // after task is scheduled, we need to store the signal back to task.options
                taskData.options.signal = signal;
                // Wrapping `task` in a weak reference would not prevent memory leaks. Weak references are
                // primarily used for preventing strong references cycles. `onAbort` is always reachable
                // as it's an event listener, so its closure retains a strong reference to the `task`.
                const onAbort = () => task.zone.cancelTask(task);
                nativeListener.call(signal, 'abort', onAbort, {
                  once: true
                });
                // We need to remove the `abort` listener when the event listener is going to be removed,
                // as it creates a closure that captures `task`. This closure retains a reference to the
                // `task` object even after it goes out of scope, preventing `task` from being garbage
                // collected.
                task.removeAbortListener = () => signal.removeEventListener('abort', onAbort);
              }
              // should clear taskData.target to avoid memory leak
              // issue, https://github.com/angular/angular/issues/20442
              taskData.target = null;
              // need to clear up taskData because it is a global object
              if (data) {
                data.taskData = null;
              }
              // have to save those information to task in case
              // application may call task.zone.cancelTask() directly
              if (once) {
                taskData.options.once = true;
              }
              if (!(!passiveSupported && typeof task.options === 'boolean')) {
                // if not support passive, and we pass an option object
                // to addEventListener, we should save the options to task
                task.options = options;
              }
              task.target = target;
              task.capture = capture;
              task.eventName = eventName;
              if (isHandleEvent) {
                // save original delegate for compare to check duplicate
                task.originalDelegate = delegate;
              }
              if (!prepend) {
                existingTasks.push(task);
              } else {
                existingTasks.unshift(task);
              }
              if (returnTarget) {
                return target;
              }
            };
          };
          proto[ADD_EVENT_LISTENER] = makeAddListener(nativeAddEventListener, ADD_EVENT_LISTENER_SOURCE, customSchedule, customCancel, returnTarget);
          if (nativePrependEventListener) {
            proto[PREPEND_EVENT_LISTENER] = makeAddListener(nativePrependEventListener, PREPEND_EVENT_LISTENER_SOURCE, customSchedulePrepend, customCancel, returnTarget, true);
          }
          proto[REMOVE_EVENT_LISTENER] = function () {
            const target = this || _global;
            let eventName = arguments[0];
            if (patchOptions && patchOptions.transferEventName) {
              eventName = patchOptions.transferEventName(eventName);
            }
            const options = arguments[2];
            const capture = !options ? false : typeof options === 'boolean' ? true : options.capture;
            const delegate = arguments[1];
            if (!delegate) {
              return nativeRemoveEventListener.apply(this, arguments);
            }
            if (validateHandler && !validateHandler(nativeRemoveEventListener, delegate, target, arguments)) {
              return;
            }
            const symbolEventNames = zoneSymbolEventNames[eventName];
            let symbolEventName;
            if (symbolEventNames) {
              symbolEventName = symbolEventNames[capture ? TRUE_STR : FALSE_STR];
            }
            const existingTasks = symbolEventName && target[symbolEventName];
            // `existingTasks` may not exist if the `addEventListener` was called before
            // it was patched by zone.js. Please refer to the attached issue for
            // clarification, particularly after the `if` condition, before calling
            // the native `removeEventListener`.
            if (existingTasks) {
              for (let i = 0; i < existingTasks.length; i++) {
                const existingTask = existingTasks[i];
                if (compare(existingTask, delegate)) {
                  existingTasks.splice(i, 1);
                  // set isRemoved to data for faster invokeTask check
                  existingTask.isRemoved = true;
                  if (existingTasks.length === 0) {
                    // all tasks for the eventName + capture have gone,
                    // remove globalZoneAwareCallback and remove the task cache from target
                    existingTask.allRemoved = true;
                    target[symbolEventName] = null;
                    // in the target, we have an event listener which is added by on_property
                    // such as target.onclick = function() {}, so we need to clear this internal
                    // property too if all delegates with capture=false were removed
                    // https:// github.com/angular/angular/issues/31643
                    // https://github.com/angular/angular/issues/54581
                    if (!capture && typeof eventName === 'string') {
                      const onPropertySymbol = ZONE_SYMBOL_PREFIX + 'ON_PROPERTY' + eventName;
                      target[onPropertySymbol] = null;
                    }
                  }
                  // In all other conditions, when `addEventListener` is called after being
                  // patched by zone.js, we would always find an event task on the `EventTarget`.
                  // This will trigger `cancelFn` on the `existingTask`, leading to `customCancelGlobal`,
                  // which ultimately removes an event listener and cleans up the abort listener
                  // (if an `AbortSignal` was provided when scheduling a task).
                  existingTask.zone.cancelTask(existingTask);
                  if (returnTarget) {
                    return target;
                  }
                  return;
                }
              }
            }
            // https://github.com/angular/zone.js/issues/930
            // We may encounter a situation where the `addEventListener` was
            // called on the event target before zone.js is loaded, resulting
            // in no task being stored on the event target due to its invocation
            // of the native implementation. In this scenario, we simply need to
            // invoke the native `removeEventListener`.
            return nativeRemoveEventListener.apply(this, arguments);
          };
          proto[LISTENERS_EVENT_LISTENER] = function () {
            const target = this || _global;
            let eventName = arguments[0];
            if (patchOptions && patchOptions.transferEventName) {
              eventName = patchOptions.transferEventName(eventName);
            }
            const listeners = [];
            const tasks = findEventTasks(target, eventNameToString ? eventNameToString(eventName) : eventName);
            for (let i = 0; i < tasks.length; i++) {
              const task = tasks[i];
              let delegate = task.originalDelegate ? task.originalDelegate : task.callback;
              listeners.push(delegate);
            }
            return listeners;
          };
          proto[REMOVE_ALL_LISTENERS_EVENT_LISTENER] = function () {
            const target = this || _global;
            let eventName = arguments[0];
            if (!eventName) {
              const keys = Object.keys(target);
              for (let i = 0; i < keys.length; i++) {
                const prop = keys[i];
                const match = EVENT_NAME_SYMBOL_REGX.exec(prop);
                let evtName = match && match[1];
                // in nodejs EventEmitter, removeListener event is
                // used for monitoring the removeListener call,
                // so just keep removeListener eventListener until
                // all other eventListeners are removed
                if (evtName && evtName !== 'removeListener') {
                  this[REMOVE_ALL_LISTENERS_EVENT_LISTENER].call(this, evtName);
                }
              }
              // remove removeListener listener finally
              this[REMOVE_ALL_LISTENERS_EVENT_LISTENER].call(this, 'removeListener');
            } else {
              if (patchOptions && patchOptions.transferEventName) {
                eventName = patchOptions.transferEventName(eventName);
              }
              const symbolEventNames = zoneSymbolEventNames[eventName];
              if (symbolEventNames) {
                const symbolEventName = symbolEventNames[FALSE_STR];
                const symbolCaptureEventName = symbolEventNames[TRUE_STR];
                const tasks = target[symbolEventName];
                const captureTasks = target[symbolCaptureEventName];
                if (tasks) {
                  const removeTasks = tasks.slice();
                  for (let i = 0; i < removeTasks.length; i++) {
                    const task = removeTasks[i];
                    let delegate = task.originalDelegate ? task.originalDelegate : task.callback;
                    this[REMOVE_EVENT_LISTENER].call(this, eventName, delegate, task.options);
                  }
                }
                if (captureTasks) {
                  const removeTasks = captureTasks.slice();
                  for (let i = 0; i < removeTasks.length; i++) {
                    const task = removeTasks[i];
                    let delegate = task.originalDelegate ? task.originalDelegate : task.callback;
                    this[REMOVE_EVENT_LISTENER].call(this, eventName, delegate, task.options);
                  }
                }
              }
            }
            if (returnTarget) {
              return this;
            }
          };
          // for native toString patch
          attachOriginToPatched(proto[ADD_EVENT_LISTENER], nativeAddEventListener);
          attachOriginToPatched(proto[REMOVE_EVENT_LISTENER], nativeRemoveEventListener);
          if (nativeRemoveAllListeners) {
            attachOriginToPatched(proto[REMOVE_ALL_LISTENERS_EVENT_LISTENER], nativeRemoveAllListeners);
          }
          if (nativeListeners) {
            attachOriginToPatched(proto[LISTENERS_EVENT_LISTENER], nativeListeners);
          }
          return true;
        }
        let results = [];
        for (let i = 0; i < apis.length; i++) {
          results[i] = patchEventTargetMethods(apis[i], patchOptions);
        }
        return results;
      }
      function findEventTasks(target, eventName) {
        if (!eventName) {
          const foundTasks = [];
          for (let prop in target) {
            const match = EVENT_NAME_SYMBOL_REGX.exec(prop);
            let evtName = match && match[1];
            if (evtName && (!eventName || evtName === eventName)) {
              const tasks = target[prop];
              if (tasks) {
                for (let i = 0; i < tasks.length; i++) {
                  foundTasks.push(tasks[i]);
                }
              }
            }
          }
          return foundTasks;
        }
        let symbolEventName = zoneSymbolEventNames[eventName];
        if (!symbolEventName) {
          prepareEventNames(eventName);
          symbolEventName = zoneSymbolEventNames[eventName];
        }
        const captureFalseTasks = target[symbolEventName[FALSE_STR]];
        const captureTrueTasks = target[symbolEventName[TRUE_STR]];
        if (!captureFalseTasks) {
          return captureTrueTasks ? captureTrueTasks.slice() : [];
        } else {
          return captureTrueTasks ? captureFalseTasks.concat(captureTrueTasks) : captureFalseTasks.slice();
        }
      }
      function patchEventPrototype(global, api) {
        const Event = global['Event'];
        if (Event && Event.prototype) {
          api.patchMethod(Event.prototype, 'stopImmediatePropagation', delegate => function (self, args) {
            self[IMMEDIATE_PROPAGATION_SYMBOL] = true;
            // we need to call the native stopImmediatePropagation
            // in case in some hybrid application, some part of
            // application will be controlled by zone, some are not
            delegate && delegate.apply(self, args);
          });
        }
      }

      /**
       * @fileoverview
       * @suppress {missingRequire}
       */
      function patchQueueMicrotask(global, api) {
        api.patchMethod(global, 'queueMicrotask', delegate => {
          return function (self, args) {
            Zone.current.scheduleMicroTask('queueMicrotask', args[0]);
          };
        });
      }

      /**
       * @fileoverview
       * @suppress {missingRequire}
       */
      const taskSymbol = zoneSymbol('zoneTask');
      function patchTimer(window, setName, cancelName, nameSuffix) {
        let setNative = null;
        let clearNative = null;
        setName += nameSuffix;
        cancelName += nameSuffix;
        const tasksByHandleId = {};
        function scheduleTask(task) {
          const data = task.data;
          data.args[0] = function () {
            return task.invoke.apply(this, arguments);
          };
          const handleOrId = setNative.apply(window, data.args);
          // Whlist on Node.js when get can the ID by using `[Symbol.toPrimitive]()` we do
          // to this so that we do not cause potentally leaks when using `setTimeout`
          // since this can be periodic when using `.refresh`.
          if (isNumber(handleOrId)) {
            data.handleId = handleOrId;
          } else {
            data.handle = handleOrId;
            // On Node.js a timeout and interval can be restarted over and over again by using the `.refresh` method.
            data.isRefreshable = isFunction(handleOrId.refresh);
          }
          return task;
        }
        function clearTask(task) {
          const {
            handle,
            handleId
          } = task.data;
          return clearNative.call(window, handle ?? handleId);
        }
        setNative = patchMethod(window, setName, delegate => function (self, args) {
          if (isFunction(args[0])) {
            const options = {
              isRefreshable: false,
              isPeriodic: nameSuffix === 'Interval',
              delay: nameSuffix === 'Timeout' || nameSuffix === 'Interval' ? args[1] || 0 : undefined,
              args: args
            };
            const callback = args[0];
            args[0] = function timer() {
              try {
                return callback.apply(this, arguments);
              } finally {
                // issue-934, task will be cancelled
                // even it is a periodic task such as
                // setInterval
                // https://github.com/angular/angular/issues/40387
                // Cleanup tasksByHandleId should be handled before scheduleTask
                // Since some zoneSpec may intercept and doesn't trigger
                // scheduleFn(scheduleTask) provided here.
                const {
                  handle,
                  handleId,
                  isPeriodic,
                  isRefreshable
                } = options;
                if (!isPeriodic && !isRefreshable) {
                  if (handleId) {
                    // in non-nodejs env, we remove timerId
                    // from local cache
                    delete tasksByHandleId[handleId];
                  } else if (handle) {
                    // Node returns complex objects as handleIds
                    // we remove task reference from timer object
                    handle[taskSymbol] = null;
                  }
                }
              }
            };
            const task = scheduleMacroTaskWithCurrentZone(setName, args[0], options, scheduleTask, clearTask);
            if (!task) {
              return task;
            }
            // Node.js must additionally support the ref and unref functions.
            const {
              handleId,
              handle,
              isRefreshable,
              isPeriodic
            } = task.data;
            if (handleId) {
              // for non nodejs env, we save handleId: task
              // mapping in local cache for clearTimeout
              tasksByHandleId[handleId] = task;
            } else if (handle) {
              // for nodejs env, we save task
              // reference in timerId Object for clearTimeout
              handle[taskSymbol] = task;
              if (isRefreshable && !isPeriodic) {
                const originalRefresh = handle.refresh;
                handle.refresh = function () {
                  const {
                    zone,
                    state
                  } = task;
                  if (state === 'notScheduled') {
                    task._state = 'scheduled';
                    zone._updateTaskCount(task, 1);
                  } else if (state === 'running') {
                    task._state = 'scheduling';
                  }
                  return originalRefresh.call(this);
                };
              }
            }
            return handle ?? handleId ?? task;
          } else {
            // cause an error by calling it directly.
            return delegate.apply(window, args);
          }
        });
        clearNative = patchMethod(window, cancelName, delegate => function (self, args) {
          const id = args[0];
          let task;
          if (isNumber(id)) {
            // non nodejs env.
            task = tasksByHandleId[id];
            delete tasksByHandleId[id];
          } else {
            // nodejs env ?? other environments.
            task = id?.[taskSymbol];
            if (task) {
              id[taskSymbol] = null;
            } else {
              task = id;
            }
          }
          if (task?.type) {
            if (task.cancelFn) {
              // Do not cancel already canceled functions
              task.zone.cancelTask(task);
            }
          } else {
            // cause an error by calling it directly.
            delegate.apply(window, args);
          }
        });
      }
      function patchCustomElements(_global, api) {
        const {
          isBrowser,
          isMix
        } = api.getGlobalObjects();
        if (!isBrowser && !isMix || !_global['customElements'] || !('customElements' in _global)) {
          return;
        }
        // https://html.spec.whatwg.org/multipage/custom-elements.html#concept-custom-element-definition-lifecycle-callbacks
        const callbacks = ['connectedCallback', 'disconnectedCallback', 'adoptedCallback', 'attributeChangedCallback', 'formAssociatedCallback', 'formDisabledCallback', 'formResetCallback', 'formStateRestoreCallback'];
        api.patchCallbacks(api, _global.customElements, 'customElements', 'define', callbacks);
      }
      function eventTargetPatch(_global, api) {
        if (Zone[api.symbol('patchEventTarget')]) {
          // EventTarget is already patched.
          return;
        }
        const {
          eventNames,
          zoneSymbolEventNames,
          TRUE_STR,
          FALSE_STR,
          ZONE_SYMBOL_PREFIX
        } = api.getGlobalObjects();
        //  predefine all __zone_symbol__ + eventName + true/false string
        for (let i = 0; i < eventNames.length; i++) {
          const eventName = eventNames[i];
          const falseEventName = eventName + FALSE_STR;
          const trueEventName = eventName + TRUE_STR;
          const symbol = ZONE_SYMBOL_PREFIX + falseEventName;
          const symbolCapture = ZONE_SYMBOL_PREFIX + trueEventName;
          zoneSymbolEventNames[eventName] = {};
          zoneSymbolEventNames[eventName][FALSE_STR] = symbol;
          zoneSymbolEventNames[eventName][TRUE_STR] = symbolCapture;
        }
        const EVENT_TARGET = _global['EventTarget'];
        if (!EVENT_TARGET || !EVENT_TARGET.prototype) {
          return;
        }
        api.patchEventTarget(_global, api, [EVENT_TARGET && EVENT_TARGET.prototype]);
        return true;
      }
      function patchEvent(global, api) {
        api.patchEventPrototype(global, api);
      }

      /**
       * @fileoverview
       * @suppress {globalThis}
       */
      function filterProperties(target, onProperties, ignoreProperties) {
        if (!ignoreProperties || ignoreProperties.length === 0) {
          return onProperties;
        }
        const tip = ignoreProperties.filter(ip => ip.target === target);
        if (!tip || tip.length === 0) {
          return onProperties;
        }
        const targetIgnoreProperties = tip[0].ignoreProperties;
        return onProperties.filter(op => targetIgnoreProperties.indexOf(op) === -1);
      }
      function patchFilteredProperties(target, onProperties, ignoreProperties, prototype) {
        // check whether target is available, sometimes target will be undefined
        // because different browser or some 3rd party plugin.
        if (!target) {
          return;
        }
        const filteredProperties = filterProperties(target, onProperties, ignoreProperties);
        patchOnProperties(target, filteredProperties, prototype);
      }
      /**
       * Get all event name properties which the event name startsWith `on`
       * from the target object itself, inherited properties are not considered.
       */
      function getOnEventNames(target) {
        return Object.getOwnPropertyNames(target).filter(name => name.startsWith('on') && name.length > 2).map(name => name.substring(2));
      }
      function propertyDescriptorPatch(api, _global) {
        if (isNode && !isMix) {
          return;
        }
        if (Zone[api.symbol('patchEvents')]) {
          // events are already been patched by legacy patch.
          return;
        }
        const ignoreProperties = _global['__Zone_ignore_on_properties'];
        // for browsers that we can patch the descriptor:  Chrome & Firefox
        let patchTargets = [];
        if (isBrowser) {
          const internalWindow = window;
          patchTargets = patchTargets.concat(['Document', 'SVGElement', 'Element', 'HTMLElement', 'HTMLBodyElement', 'HTMLMediaElement', 'HTMLFrameSetElement', 'HTMLFrameElement', 'HTMLIFrameElement', 'HTMLMarqueeElement', 'Worker']);
          const ignoreErrorProperties = isIE() ? [{
            target: internalWindow,
            ignoreProperties: ['error']
          }] : [];
          // in IE/Edge, onProp not exist in window object, but in WindowPrototype
          // so we need to pass WindowPrototype to check onProp exist or not
          patchFilteredProperties(internalWindow, getOnEventNames(internalWindow), ignoreProperties ? ignoreProperties.concat(ignoreErrorProperties) : ignoreProperties, ObjectGetPrototypeOf(internalWindow));
        }
        patchTargets = patchTargets.concat(['XMLHttpRequest', 'XMLHttpRequestEventTarget', 'IDBIndex', 'IDBRequest', 'IDBOpenDBRequest', 'IDBDatabase', 'IDBTransaction', 'IDBCursor', 'WebSocket']);
        for (let i = 0; i < patchTargets.length; i++) {
          const target = _global[patchTargets[i]];
          target && target.prototype && patchFilteredProperties(target.prototype, getOnEventNames(target.prototype), ignoreProperties);
        }
      }

      /**
       * @fileoverview
       * @suppress {missingRequire}
       */
      function patchBrowser(Zone) {
        Zone.__load_patch('legacy', global => {
          const legacyPatch = global[Zone.__symbol__('legacyPatch')];
          if (legacyPatch) {
            legacyPatch();
          }
        });
        Zone.__load_patch('timers', global => {
          const set = 'set';
          const clear = 'clear';
          patchTimer(global, set, clear, 'Timeout');
          patchTimer(global, set, clear, 'Interval');
          patchTimer(global, set, clear, 'Immediate');
        });
        Zone.__load_patch('requestAnimationFrame', global => {
          patchTimer(global, 'request', 'cancel', 'AnimationFrame');
          patchTimer(global, 'mozRequest', 'mozCancel', 'AnimationFrame');
          patchTimer(global, 'webkitRequest', 'webkitCancel', 'AnimationFrame');
        });
        Zone.__load_patch('blocking', (global, Zone) => {
          const blockingMethods = ['alert', 'prompt', 'confirm'];
          for (let i = 0; i < blockingMethods.length; i++) {
            const name = blockingMethods[i];
            patchMethod(global, name, (delegate, symbol, name) => {
              return function (s, args) {
                return Zone.current.run(delegate, global, args, name);
              };
            });
          }
        });
        Zone.__load_patch('EventTarget', (global, Zone, api) => {
          patchEvent(global, api);
          eventTargetPatch(global, api);
          // patch XMLHttpRequestEventTarget's addEventListener/removeEventListener
          const XMLHttpRequestEventTarget = global['XMLHttpRequestEventTarget'];
          if (XMLHttpRequestEventTarget && XMLHttpRequestEventTarget.prototype) {
            api.patchEventTarget(global, api, [XMLHttpRequestEventTarget.prototype]);
          }
        });
        Zone.__load_patch('MutationObserver', (global, Zone, api) => {
          patchClass('MutationObserver');
          patchClass('WebKitMutationObserver');
        });
        Zone.__load_patch('IntersectionObserver', (global, Zone, api) => {
          patchClass('IntersectionObserver');
        });
        Zone.__load_patch('FileReader', (global, Zone, api) => {
          patchClass('FileReader');
        });
        Zone.__load_patch('on_property', (global, Zone, api) => {
          propertyDescriptorPatch(api, global);
        });
        Zone.__load_patch('customElements', (global, Zone, api) => {
          patchCustomElements(global, api);
        });
        Zone.__load_patch('XHR', (global, Zone) => {
          // Treat XMLHttpRequest as a macrotask.
          patchXHR(global);
          const XHR_TASK = zoneSymbol('xhrTask');
          const XHR_SYNC = zoneSymbol('xhrSync');
          const XHR_LISTENER = zoneSymbol('xhrListener');
          const XHR_SCHEDULED = zoneSymbol('xhrScheduled');
          const XHR_URL = zoneSymbol('xhrURL');
          const XHR_ERROR_BEFORE_SCHEDULED = zoneSymbol('xhrErrorBeforeScheduled');
          function patchXHR(window) {
            const XMLHttpRequest = window['XMLHttpRequest'];
            if (!XMLHttpRequest) {
              // XMLHttpRequest is not available in service worker
              return;
            }
            const XMLHttpRequestPrototype = XMLHttpRequest.prototype;
            function findPendingTask(target) {
              return target[XHR_TASK];
            }
            let oriAddListener = XMLHttpRequestPrototype[ZONE_SYMBOL_ADD_EVENT_LISTENER];
            let oriRemoveListener = XMLHttpRequestPrototype[ZONE_SYMBOL_REMOVE_EVENT_LISTENER];
            if (!oriAddListener) {
              const XMLHttpRequestEventTarget = window['XMLHttpRequestEventTarget'];
              if (XMLHttpRequestEventTarget) {
                const XMLHttpRequestEventTargetPrototype = XMLHttpRequestEventTarget.prototype;
                oriAddListener = XMLHttpRequestEventTargetPrototype[ZONE_SYMBOL_ADD_EVENT_LISTENER];
                oriRemoveListener = XMLHttpRequestEventTargetPrototype[ZONE_SYMBOL_REMOVE_EVENT_LISTENER];
              }
            }
            const READY_STATE_CHANGE = 'readystatechange';
            const SCHEDULED = 'scheduled';
            function scheduleTask(task) {
              const data = task.data;
              const target = data.target;
              target[XHR_SCHEDULED] = false;
              target[XHR_ERROR_BEFORE_SCHEDULED] = false;
              // remove existing event listener
              const listener = target[XHR_LISTENER];
              if (!oriAddListener) {
                oriAddListener = target[ZONE_SYMBOL_ADD_EVENT_LISTENER];
                oriRemoveListener = target[ZONE_SYMBOL_REMOVE_EVENT_LISTENER];
              }
              if (listener) {
                oriRemoveListener.call(target, READY_STATE_CHANGE, listener);
              }
              const newListener = target[XHR_LISTENER] = () => {
                if (target.readyState === target.DONE) {
                  // sometimes on some browsers XMLHttpRequest will fire onreadystatechange with
                  // readyState=4 multiple times, so we need to check task state here
                  if (!data.aborted && target[XHR_SCHEDULED] && task.state === SCHEDULED) {
                    // check whether the xhr has registered onload listener
                    // if that is the case, the task should invoke after all
                    // onload listeners finish.
                    // Also if the request failed without response (status = 0), the load event handler
                    // will not be triggered, in that case, we should also invoke the placeholder callback
                    // to close the XMLHttpRequest::send macroTask.
                    // https://github.com/angular/angular/issues/38795
                    const loadTasks = target[Zone.__symbol__('loadfalse')];
                    if (target.status !== 0 && loadTasks && loadTasks.length > 0) {
                      const oriInvoke = task.invoke;
                      task.invoke = function () {
                        // need to load the tasks again, because in other
                        // load listener, they may remove themselves
                        const loadTasks = target[Zone.__symbol__('loadfalse')];
                        for (let i = 0; i < loadTasks.length; i++) {
                          if (loadTasks[i] === task) {
                            loadTasks.splice(i, 1);
                          }
                        }
                        if (!data.aborted && task.state === SCHEDULED) {
                          oriInvoke.call(task);
                        }
                      };
                      loadTasks.push(task);
                    } else {
                      task.invoke();
                    }
                  } else if (!data.aborted && target[XHR_SCHEDULED] === false) {
                    // error occurs when xhr.send()
                    target[XHR_ERROR_BEFORE_SCHEDULED] = true;
                  }
                }
              };
              oriAddListener.call(target, READY_STATE_CHANGE, newListener);
              const storedTask = target[XHR_TASK];
              if (!storedTask) {
                target[XHR_TASK] = task;
              }
              sendNative.apply(target, data.args);
              target[XHR_SCHEDULED] = true;
              return task;
            }
            function placeholderCallback() {}
            function clearTask(task) {
              const data = task.data;
              // Note - ideally, we would call data.target.removeEventListener here, but it's too late
              // to prevent it from firing. So instead, we store info for the event listener.
              data.aborted = true;
              return abortNative.apply(data.target, data.args);
            }
            const openNative = patchMethod(XMLHttpRequestPrototype, 'open', () => function (self, args) {
              self[XHR_SYNC] = args[2] == false;
              self[XHR_URL] = args[1];
              return openNative.apply(self, args);
            });
            const XMLHTTPREQUEST_SOURCE = 'XMLHttpRequest.send';
            const fetchTaskAborting = zoneSymbol('fetchTaskAborting');
            const fetchTaskScheduling = zoneSymbol('fetchTaskScheduling');
            const sendNative = patchMethod(XMLHttpRequestPrototype, 'send', () => function (self, args) {
              if (Zone.current[fetchTaskScheduling] === true) {
                // a fetch is scheduling, so we are using xhr to polyfill fetch
                // and because we already schedule macroTask for fetch, we should
                // not schedule a macroTask for xhr again
                return sendNative.apply(self, args);
              }
              if (self[XHR_SYNC]) {
                // if the XHR is sync there is no task to schedule, just execute the code.
                return sendNative.apply(self, args);
              } else {
                const options = {
                  target: self,
                  url: self[XHR_URL],
                  isPeriodic: false,
                  args: args,
                  aborted: false
                };
                const task = scheduleMacroTaskWithCurrentZone(XMLHTTPREQUEST_SOURCE, placeholderCallback, options, scheduleTask, clearTask);
                if (self && self[XHR_ERROR_BEFORE_SCHEDULED] === true && !options.aborted && task.state === SCHEDULED) {
                  // xhr request throw error when send
                  // we should invoke task instead of leaving a scheduled
                  // pending macroTask
                  task.invoke();
                }
              }
            });
            const abortNative = patchMethod(XMLHttpRequestPrototype, 'abort', () => function (self, args) {
              const task = findPendingTask(self);
              if (task && typeof task.type == 'string') {
                // If the XHR has already completed, do nothing.
                // If the XHR has already been aborted, do nothing.
                // Fix #569, call abort multiple times before done will cause
                // macroTask task count be negative number
                if (task.cancelFn == null || task.data && task.data.aborted) {
                  return;
                }
                task.zone.cancelTask(task);
              } else if (Zone.current[fetchTaskAborting] === true) {
                // the abort is called from fetch polyfill, we need to call native abort of XHR.
                return abortNative.apply(self, args);
              }
              // Otherwise, we are trying to abort an XHR which has not yet been sent, so there is no
              // task
              // to cancel. Do nothing.
            });
          }
        });
        Zone.__load_patch('geolocation', global => {
          /// GEO_LOCATION
          if (global['navigator'] && global['navigator'].geolocation) {
            patchPrototype(global['navigator'].geolocation, ['getCurrentPosition', 'watchPosition']);
          }
        });
        Zone.__load_patch('PromiseRejectionEvent', (global, Zone) => {
          // handle unhandled promise rejection
          function findPromiseRejectionHandler(evtName) {
            return function (e) {
              const eventTasks = findEventTasks(global, evtName);
              eventTasks.forEach(eventTask => {
                // windows has added unhandledrejection event listener
                // trigger the event listener
                const PromiseRejectionEvent = global['PromiseRejectionEvent'];
                if (PromiseRejectionEvent) {
                  const evt = new PromiseRejectionEvent(evtName, {
                    promise: e.promise,
                    reason: e.rejection
                  });
                  eventTask.invoke(evt);
                }
              });
            };
          }
          if (global['PromiseRejectionEvent']) {
            Zone[zoneSymbol('unhandledPromiseRejectionHandler')] = findPromiseRejectionHandler('unhandledrejection');
            Zone[zoneSymbol('rejectionHandledHandler')] = findPromiseRejectionHandler('rejectionhandled');
          }
        });
        Zone.__load_patch('queueMicrotask', (global, Zone, api) => {
          patchQueueMicrotask(global, api);
        });
      }
      function patchPromise(Zone) {
        Zone.__load_patch('ZoneAwarePromise', (global, Zone, api) => {
          const ObjectGetOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
          const ObjectDefineProperty = Object.defineProperty;
          function readableObjectToString(obj) {
            if (obj && obj.toString === Object.prototype.toString) {
              const className = obj.constructor && obj.constructor.name;
              return (className ? className : '') + ': ' + JSON.stringify(obj);
            }
            return obj ? obj.toString() : Object.prototype.toString.call(obj);
          }
          const __symbol__ = api.symbol;
          const _uncaughtPromiseErrors = [];
          const isDisableWrappingUncaughtPromiseRejection = global[__symbol__('DISABLE_WRAPPING_UNCAUGHT_PROMISE_REJECTION')] !== false;
          const symbolPromise = __symbol__('Promise');
          const symbolThen = __symbol__('then');
          const creationTrace = '__creationTrace__';
          api.onUnhandledError = e => {
            if (api.showUncaughtError()) {
              const rejection = e && e.rejection;
              if (rejection) {
                console.error('Unhandled Promise rejection:', rejection instanceof Error ? rejection.message : rejection, '; Zone:', e.zone.name, '; Task:', e.task && e.task.source, '; Value:', rejection, rejection instanceof Error ? rejection.stack : undefined);
              } else {
                console.error(e);
              }
            }
          };
          api.microtaskDrainDone = () => {
            while (_uncaughtPromiseErrors.length) {
              const uncaughtPromiseError = _uncaughtPromiseErrors.shift();
              try {
                uncaughtPromiseError.zone.runGuarded(() => {
                  if (uncaughtPromiseError.throwOriginal) {
                    throw uncaughtPromiseError.rejection;
                  }
                  throw uncaughtPromiseError;
                });
              } catch (error) {
                handleUnhandledRejection(error);
              }
            }
          };
          const UNHANDLED_PROMISE_REJECTION_HANDLER_SYMBOL = __symbol__('unhandledPromiseRejectionHandler');
          function handleUnhandledRejection(e) {
            api.onUnhandledError(e);
            try {
              const handler = Zone[UNHANDLED_PROMISE_REJECTION_HANDLER_SYMBOL];
              if (typeof handler === 'function') {
                handler.call(this, e);
              }
            } catch (err) {}
          }
          function isThenable(value) {
            return value && value.then;
          }
          function forwardResolution(value) {
            return value;
          }
          function forwardRejection(rejection) {
            return ZoneAwarePromise.reject(rejection);
          }
          const symbolState = __symbol__('state');
          const symbolValue = __symbol__('value');
          const symbolFinally = __symbol__('finally');
          const symbolParentPromiseValue = __symbol__('parentPromiseValue');
          const symbolParentPromiseState = __symbol__('parentPromiseState');
          const source = 'Promise.then';
          const UNRESOLVED = null;
          const RESOLVED = true;
          const REJECTED = false;
          const REJECTED_NO_CATCH = 0;
          function makeResolver(promise, state) {
            return v => {
              try {
                resolvePromise(promise, state, v);
              } catch (err) {
                resolvePromise(promise, false, err);
              }
              // Do not return value or you will break the Promise spec.
            };
          }
          const once = function () {
            let wasCalled = false;
            return function wrapper(wrappedFunction) {
              return function () {
                if (wasCalled) {
                  return;
                }
                wasCalled = true;
                wrappedFunction.apply(null, arguments);
              };
            };
          };
          const TYPE_ERROR = 'Promise resolved with itself';
          const CURRENT_TASK_TRACE_SYMBOL = __symbol__('currentTaskTrace');
          // Promise Resolution
          function resolvePromise(promise, state, value) {
            const onceWrapper = once();
            if (promise === value) {
              throw new TypeError(TYPE_ERROR);
            }
            if (promise[symbolState] === UNRESOLVED) {
              // should only get value.then once based on promise spec.
              let then = null;
              try {
                if (typeof value === 'object' || typeof value === 'function') {
                  then = value && value.then;
                }
              } catch (err) {
                onceWrapper(() => {
                  resolvePromise(promise, false, err);
                })();
                return promise;
              }
              // if (value instanceof ZoneAwarePromise) {
              if (state !== REJECTED && value instanceof ZoneAwarePromise && value.hasOwnProperty(symbolState) && value.hasOwnProperty(symbolValue) && value[symbolState] !== UNRESOLVED) {
                clearRejectedNoCatch(value);
                resolvePromise(promise, value[symbolState], value[symbolValue]);
              } else if (state !== REJECTED && typeof then === 'function') {
                try {
                  then.call(value, onceWrapper(makeResolver(promise, state)), onceWrapper(makeResolver(promise, false)));
                } catch (err) {
                  onceWrapper(() => {
                    resolvePromise(promise, false, err);
                  })();
                }
              } else {
                promise[symbolState] = state;
                const queue = promise[symbolValue];
                promise[symbolValue] = value;
                if (promise[symbolFinally] === symbolFinally) {
                  // the promise is generated by Promise.prototype.finally
                  if (state === RESOLVED) {
                    // the state is resolved, should ignore the value
                    // and use parent promise value
                    promise[symbolState] = promise[symbolParentPromiseState];
                    promise[symbolValue] = promise[symbolParentPromiseValue];
                  }
                }
                // record task information in value when error occurs, so we can
                // do some additional work such as render longStackTrace
                if (state === REJECTED && value instanceof Error) {
                  // check if longStackTraceZone is here
                  const trace = Zone.currentTask && Zone.currentTask.data && Zone.currentTask.data[creationTrace];
                  if (trace) {
                    // only keep the long stack trace into error when in longStackTraceZone
                    ObjectDefineProperty(value, CURRENT_TASK_TRACE_SYMBOL, {
                      configurable: true,
                      enumerable: false,
                      writable: true,
                      value: trace
                    });
                  }
                }
                for (let i = 0; i < queue.length;) {
                  scheduleResolveOrReject(promise, queue[i++], queue[i++], queue[i++], queue[i++]);
                }
                if (queue.length == 0 && state == REJECTED) {
                  promise[symbolState] = REJECTED_NO_CATCH;
                  let uncaughtPromiseError = value;
                  try {
                    // Here we throws a new Error to print more readable error log
                    // and if the value is not an error, zone.js builds an `Error`
                    // Object here to attach the stack information.
                    throw new Error('Uncaught (in promise): ' + readableObjectToString(value) + (value && value.stack ? '\n' + value.stack : ''));
                  } catch (err) {
                    uncaughtPromiseError = err;
                  }
                  if (isDisableWrappingUncaughtPromiseRejection) {
                    // If disable wrapping uncaught promise reject
                    // use the value instead of wrapping it.
                    uncaughtPromiseError.throwOriginal = true;
                  }
                  uncaughtPromiseError.rejection = value;
                  uncaughtPromiseError.promise = promise;
                  uncaughtPromiseError.zone = Zone.current;
                  uncaughtPromiseError.task = Zone.currentTask;
                  _uncaughtPromiseErrors.push(uncaughtPromiseError);
                  api.scheduleMicroTask(); // to make sure that it is running
                }
              }
            }
            // Resolving an already resolved promise is a noop.
            return promise;
          }
          const REJECTION_HANDLED_HANDLER = __symbol__('rejectionHandledHandler');
          function clearRejectedNoCatch(promise) {
            if (promise[symbolState] === REJECTED_NO_CATCH) {
              // if the promise is rejected no catch status
              // and queue.length > 0, means there is a error handler
              // here to handle the rejected promise, we should trigger
              // windows.rejectionhandled eventHandler or nodejs rejectionHandled
              // eventHandler
              try {
                const handler = Zone[REJECTION_HANDLED_HANDLER];
                if (handler && typeof handler === 'function') {
                  handler.call(this, {
                    rejection: promise[symbolValue],
                    promise: promise
                  });
                }
              } catch (err) {}
              promise[symbolState] = REJECTED;
              for (let i = 0; i < _uncaughtPromiseErrors.length; i++) {
                if (promise === _uncaughtPromiseErrors[i].promise) {
                  _uncaughtPromiseErrors.splice(i, 1);
                }
              }
            }
          }
          function scheduleResolveOrReject(promise, zone, chainPromise, onFulfilled, onRejected) {
            clearRejectedNoCatch(promise);
            const promiseState = promise[symbolState];
            const delegate = promiseState ? typeof onFulfilled === 'function' ? onFulfilled : forwardResolution : typeof onRejected === 'function' ? onRejected : forwardRejection;
            zone.scheduleMicroTask(source, () => {
              try {
                const parentPromiseValue = promise[symbolValue];
                const isFinallyPromise = !!chainPromise && symbolFinally === chainPromise[symbolFinally];
                if (isFinallyPromise) {
                  // if the promise is generated from finally call, keep parent promise's state and value
                  chainPromise[symbolParentPromiseValue] = parentPromiseValue;
                  chainPromise[symbolParentPromiseState] = promiseState;
                }
                // should not pass value to finally callback
                const value = zone.run(delegate, undefined, isFinallyPromise && delegate !== forwardRejection && delegate !== forwardResolution ? [] : [parentPromiseValue]);
                resolvePromise(chainPromise, true, value);
              } catch (error) {
                // if error occurs, should always return this error
                resolvePromise(chainPromise, false, error);
              }
            }, chainPromise);
          }
          const ZONE_AWARE_PROMISE_TO_STRING = 'function ZoneAwarePromise() { [native code] }';
          const noop = function () {};
          const AggregateError = global.AggregateError;
          class ZoneAwarePromise {
            static toString() {
              return ZONE_AWARE_PROMISE_TO_STRING;
            }
            static resolve(value) {
              if (value instanceof ZoneAwarePromise) {
                return value;
              }
              return resolvePromise(new this(null), RESOLVED, value);
            }
            static reject(error) {
              return resolvePromise(new this(null), REJECTED, error);
            }
            static withResolvers() {
              const result = {};
              result.promise = new ZoneAwarePromise((res, rej) => {
                result.resolve = res;
                result.reject = rej;
              });
              return result;
            }
            static any(values) {
              if (!values || typeof values[Symbol.iterator] !== 'function') {
                return Promise.reject(new AggregateError([], 'All promises were rejected'));
              }
              const promises = [];
              let count = 0;
              try {
                for (let v of values) {
                  count++;
                  promises.push(ZoneAwarePromise.resolve(v));
                }
              } catch (err) {
                return Promise.reject(new AggregateError([], 'All promises were rejected'));
              }
              if (count === 0) {
                return Promise.reject(new AggregateError([], 'All promises were rejected'));
              }
              let finished = false;
              const errors = [];
              return new ZoneAwarePromise((resolve, reject) => {
                for (let i = 0; i < promises.length; i++) {
                  promises[i].then(v => {
                    if (finished) {
                      return;
                    }
                    finished = true;
                    resolve(v);
                  }, err => {
                    errors.push(err);
                    count--;
                    if (count === 0) {
                      finished = true;
                      reject(new AggregateError(errors, 'All promises were rejected'));
                    }
                  });
                }
              });
            }
            static race(values) {
              let resolve;
              let reject;
              let promise = new this((res, rej) => {
                resolve = res;
                reject = rej;
              });
              function onResolve(value) {
                resolve(value);
              }
              function onReject(error) {
                reject(error);
              }
              for (let value of values) {
                if (!isThenable(value)) {
                  value = this.resolve(value);
                }
                value.then(onResolve, onReject);
              }
              return promise;
            }
            static all(values) {
              return ZoneAwarePromise.allWithCallback(values);
            }
            static allSettled(values) {
              const P = this && this.prototype instanceof ZoneAwarePromise ? this : ZoneAwarePromise;
              return P.allWithCallback(values, {
                thenCallback: value => ({
                  status: 'fulfilled',
                  value
                }),
                errorCallback: err => ({
                  status: 'rejected',
                  reason: err
                })
              });
            }
            static allWithCallback(values, callback) {
              let resolve;
              let reject;
              let promise = new this((res, rej) => {
                resolve = res;
                reject = rej;
              });
              // Start at 2 to prevent prematurely resolving if .then is called immediately.
              let unresolvedCount = 2;
              let valueIndex = 0;
              const resolvedValues = [];
              for (let value of values) {
                if (!isThenable(value)) {
                  value = this.resolve(value);
                }
                const curValueIndex = valueIndex;
                try {
                  value.then(value => {
                    resolvedValues[curValueIndex] = callback ? callback.thenCallback(value) : value;
                    unresolvedCount--;
                    if (unresolvedCount === 0) {
                      resolve(resolvedValues);
                    }
                  }, err => {
                    if (!callback) {
                      reject(err);
                    } else {
                      resolvedValues[curValueIndex] = callback.errorCallback(err);
                      unresolvedCount--;
                      if (unresolvedCount === 0) {
                        resolve(resolvedValues);
                      }
                    }
                  });
                } catch (thenErr) {
                  reject(thenErr);
                }
                unresolvedCount++;
                valueIndex++;
              }
              // Make the unresolvedCount zero-based again.
              unresolvedCount -= 2;
              if (unresolvedCount === 0) {
                resolve(resolvedValues);
              }
              return promise;
            }
            constructor(executor) {
              const promise = this;
              if (!(promise instanceof ZoneAwarePromise)) {
                throw new Error('Must be an instanceof Promise.');
              }
              promise[symbolState] = UNRESOLVED;
              promise[symbolValue] = []; // queue;
              try {
                const onceWrapper = once();
                executor && executor(onceWrapper(makeResolver(promise, RESOLVED)), onceWrapper(makeResolver(promise, REJECTED)));
              } catch (error) {
                resolvePromise(promise, false, error);
              }
            }
            get [Symbol.toStringTag]() {
              return 'Promise';
            }
            get [Symbol.species]() {
              return ZoneAwarePromise;
            }
            then(onFulfilled, onRejected) {
              // We must read `Symbol.species` safely because `this` may be anything. For instance, `this`
              // may be an object without a prototype (created through `Object.create(null)`); thus
              // `this.constructor` will be undefined. One of the use cases is SystemJS creating
              // prototype-less objects (modules) via `Object.create(null)`. The SystemJS creates an empty
              // object and copies promise properties into that object (within the `getOrCreateLoad`
              // function). The zone.js then checks if the resolved value has the `then` method and
              // invokes it with the `value` context. Otherwise, this will throw an error: `TypeError:
              // Cannot read properties of undefined (reading 'Symbol(Symbol.species)')`.
              let C = this.constructor?.[Symbol.species];
              if (!C || typeof C !== 'function') {
                C = this.constructor || ZoneAwarePromise;
              }
              const chainPromise = new C(noop);
              const zone = Zone.current;
              if (this[symbolState] == UNRESOLVED) {
                this[symbolValue].push(zone, chainPromise, onFulfilled, onRejected);
              } else {
                scheduleResolveOrReject(this, zone, chainPromise, onFulfilled, onRejected);
              }
              return chainPromise;
            }
            catch(onRejected) {
              return this.then(null, onRejected);
            }
            finally(onFinally) {
              // See comment on the call to `then` about why thee `Symbol.species` is safely accessed.
              let C = this.constructor?.[Symbol.species];
              if (!C || typeof C !== 'function') {
                C = ZoneAwarePromise;
              }
              const chainPromise = new C(noop);
              chainPromise[symbolFinally] = symbolFinally;
              const zone = Zone.current;
              if (this[symbolState] == UNRESOLVED) {
                this[symbolValue].push(zone, chainPromise, onFinally, onFinally);
              } else {
                scheduleResolveOrReject(this, zone, chainPromise, onFinally, onFinally);
              }
              return chainPromise;
            }
          }
          // Protect against aggressive optimizers dropping seemingly unused properties.
          // E.g. Closure Compiler in advanced mode.
          ZoneAwarePromise['resolve'] = ZoneAwarePromise.resolve;
          ZoneAwarePromise['reject'] = ZoneAwarePromise.reject;
          ZoneAwarePromise['race'] = ZoneAwarePromise.race;
          ZoneAwarePromise['all'] = ZoneAwarePromise.all;
          const NativePromise = global[symbolPromise] = global['Promise'];
          global['Promise'] = ZoneAwarePromise;
          const symbolThenPatched = __symbol__('thenPatched');
          function patchThen(Ctor) {
            const proto = Ctor.prototype;
            const prop = ObjectGetOwnPropertyDescriptor(proto, 'then');
            if (prop && (prop.writable === false || !prop.configurable)) {
              // check Ctor.prototype.then propertyDescriptor is writable or not
              // in meteor env, writable is false, we should ignore such case
              return;
            }
            const originalThen = proto.then;
            // Keep a reference to the original method.
            proto[symbolThen] = originalThen;
            Ctor.prototype.then = function (onResolve, onReject) {
              const wrapped = new ZoneAwarePromise((resolve, reject) => {
                originalThen.call(this, resolve, reject);
              });
              return wrapped.then(onResolve, onReject);
            };
            Ctor[symbolThenPatched] = true;
          }
          api.patchThen = patchThen;
          function zoneify(fn) {
            return function (self, args) {
              let resultPromise = fn.apply(self, args);
              if (resultPromise instanceof ZoneAwarePromise) {
                return resultPromise;
              }
              let ctor = resultPromise.constructor;
              if (!ctor[symbolThenPatched]) {
                patchThen(ctor);
              }
              return resultPromise;
            };
          }
          if (NativePromise) {
            patchThen(NativePromise);
            patchMethod(global, 'fetch', delegate => zoneify(delegate));
          }
          // This is not part of public API, but it is useful for tests, so we expose it.
          Promise[Zone.__symbol__('uncaughtPromiseErrors')] = _uncaughtPromiseErrors;
          return ZoneAwarePromise;
        });
      }
      function patchToString(Zone) {
        // override Function.prototype.toString to make zone.js patched function
        // look like native function
        Zone.__load_patch('toString', global => {
          // patch Func.prototype.toString to let them look like native
          const originalFunctionToString = Function.prototype.toString;
          const ORIGINAL_DELEGATE_SYMBOL = zoneSymbol('OriginalDelegate');
          const PROMISE_SYMBOL = zoneSymbol('Promise');
          const ERROR_SYMBOL = zoneSymbol('Error');
          const newFunctionToString = function toString() {
            if (typeof this === 'function') {
              const originalDelegate = this[ORIGINAL_DELEGATE_SYMBOL];
              if (originalDelegate) {
                if (typeof originalDelegate === 'function') {
                  return originalFunctionToString.call(originalDelegate);
                } else {
                  return Object.prototype.toString.call(originalDelegate);
                }
              }
              if (this === Promise) {
                const nativePromise = global[PROMISE_SYMBOL];
                if (nativePromise) {
                  return originalFunctionToString.call(nativePromise);
                }
              }
              if (this === Error) {
                const nativeError = global[ERROR_SYMBOL];
                if (nativeError) {
                  return originalFunctionToString.call(nativeError);
                }
              }
            }
            return originalFunctionToString.call(this);
          };
          newFunctionToString[ORIGINAL_DELEGATE_SYMBOL] = originalFunctionToString;
          Function.prototype.toString = newFunctionToString;
          // patch Object.prototype.toString to let them look like native
          const originalObjectToString = Object.prototype.toString;
          const PROMISE_OBJECT_TO_STRING = '[object Promise]';
          Object.prototype.toString = function () {
            if (typeof Promise === 'function' && this instanceof Promise) {
              return PROMISE_OBJECT_TO_STRING;
            }
            return originalObjectToString.call(this);
          };
        });
      }
      function patchCallbacks(api, target, targetName, method, callbacks) {
        const symbol = Zone.__symbol__(method);
        if (target[symbol]) {
          return;
        }
        const nativeDelegate = target[symbol] = target[method];
        target[method] = function (name, opts, options) {
          if (opts && opts.prototype) {
            callbacks.forEach(function (callback) {
              const source = `${targetName}.${method}::` + callback;
              const prototype = opts.prototype;
              // Note: the `patchCallbacks` is used for patching the `document.registerElement` and
              // `customElements.define`. We explicitly wrap the patching code into try-catch since
              // callbacks may be already patched by other web components frameworks (e.g. LWC), and they
              // make those properties non-writable. This means that patching callback will throw an error
              // `cannot assign to read-only property`. See this code as an example:
              // https://github.com/salesforce/lwc/blob/master/packages/@lwc/engine-core/src/framework/base-bridge-element.ts#L180-L186
              // We don't want to stop the application rendering if we couldn't patch some
              // callback, e.g. `attributeChangedCallback`.
              try {
                if (prototype.hasOwnProperty(callback)) {
                  const descriptor = api.ObjectGetOwnPropertyDescriptor(prototype, callback);
                  if (descriptor && descriptor.value) {
                    descriptor.value = api.wrapWithCurrentZone(descriptor.value, source);
                    api._redefineProperty(opts.prototype, callback, descriptor);
                  } else if (prototype[callback]) {
                    prototype[callback] = api.wrapWithCurrentZone(prototype[callback], source);
                  }
                } else if (prototype[callback]) {
                  prototype[callback] = api.wrapWithCurrentZone(prototype[callback], source);
                }
              } catch {
                // Note: we leave the catch block empty since there's no way to handle the error related
                // to non-writable property.
              }
            });
          }
          return nativeDelegate.call(target, name, opts, options);
        };
        api.attachOriginToPatched(target[method], nativeDelegate);
      }
      function patchUtil(Zone) {
        Zone.__load_patch('util', (global, Zone, api) => {
          // Collect native event names by looking at properties
          // on the global namespace, e.g. 'onclick'.
          const eventNames = getOnEventNames(global);
          api.patchOnProperties = patchOnProperties;
          api.patchMethod = patchMethod;
          api.bindArguments = bindArguments;
          api.patchMacroTask = patchMacroTask;
          // In earlier version of zone.js (<0.9.0), we use env name `__zone_symbol__BLACK_LISTED_EVENTS`
          // to define which events will not be patched by `Zone.js`. In newer version (>=0.9.0), we
          // change the env name to `__zone_symbol__UNPATCHED_EVENTS` to keep the name consistent with
          // angular repo. The  `__zone_symbol__BLACK_LISTED_EVENTS` is deprecated, but it is still be
          // supported for backwards compatibility.
          const SYMBOL_BLACK_LISTED_EVENTS = Zone.__symbol__('BLACK_LISTED_EVENTS');
          const SYMBOL_UNPATCHED_EVENTS = Zone.__symbol__('UNPATCHED_EVENTS');
          if (global[SYMBOL_UNPATCHED_EVENTS]) {
            global[SYMBOL_BLACK_LISTED_EVENTS] = global[SYMBOL_UNPATCHED_EVENTS];
          }
          if (global[SYMBOL_BLACK_LISTED_EVENTS]) {
            Zone[SYMBOL_BLACK_LISTED_EVENTS] = Zone[SYMBOL_UNPATCHED_EVENTS] = global[SYMBOL_BLACK_LISTED_EVENTS];
          }
          api.patchEventPrototype = patchEventPrototype;
          api.patchEventTarget = patchEventTarget;
          api.isIEOrEdge = isIEOrEdge;
          api.ObjectDefineProperty = ObjectDefineProperty;
          api.ObjectGetOwnPropertyDescriptor = ObjectGetOwnPropertyDescriptor;
          api.ObjectCreate = ObjectCreate;
          api.ArraySlice = ArraySlice;
          api.patchClass = patchClass;
          api.wrapWithCurrentZone = wrapWithCurrentZone;
          api.filterProperties = filterProperties;
          api.attachOriginToPatched = attachOriginToPatched;
          api._redefineProperty = Object.defineProperty;
          api.patchCallbacks = patchCallbacks;
          api.getGlobalObjects = () => ({
            globalSources,
            zoneSymbolEventNames,
            eventNames,
            isBrowser,
            isMix,
            isNode,
            TRUE_STR,
            FALSE_STR,
            ZONE_SYMBOL_PREFIX,
            ADD_EVENT_LISTENER_STR,
            REMOVE_EVENT_LISTENER_STR
          });
        });
      }
      function patchCommon(Zone) {
        patchPromise(Zone);
        patchToString(Zone);
        patchUtil(Zone);
      }
      const Zone$1 = loadZone();
      patchCommon(Zone$1);
      patchBrowser(Zone$1);
      return zone;
    }

    requireZone();

    /*
     * Copyright The OpenTelemetry Authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      https://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    var AttributeNames$3;
    (function (AttributeNames) {
      AttributeNames["DOCUMENT_LOAD"] = "documentLoad";
      AttributeNames["DOCUMENT_FETCH"] = "documentFetch";
      AttributeNames["RESOURCE_FETCH"] = "resourceFetch";
    })(AttributeNames$3 || (AttributeNames$3 = {}));

    /*
     * Copyright The OpenTelemetry Authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      https://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    // this is autogenerated file, see scripts/version-update.js
    var PACKAGE_VERSION$1 = '0.44.1';
    var PACKAGE_NAME$1 = '@opentelemetry/instrumentation-document-load';

    /*
     * Copyright The OpenTelemetry Authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      https://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    var EventNames$1;
    (function (EventNames) {
      EventNames["FIRST_PAINT"] = "firstPaint";
      EventNames["FIRST_CONTENTFUL_PAINT"] = "firstContentfulPaint";
    })(EventNames$1 || (EventNames$1 = {}));

    /*
     * Copyright The OpenTelemetry Authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      https://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    var getPerformanceNavigationEntries = function () {
      var _a, _b;
      var entries = {};
      var performanceNavigationTiming = (_b = (_a = otperformance).getEntriesByType) === null || _b === void 0 ? void 0 : _b.call(_a, 'navigation')[0];
      if (performanceNavigationTiming) {
        var keys = Object.values(PerformanceTimingNames);
        keys.forEach(function (key) {
          if (hasKey(performanceNavigationTiming, key)) {
            var value = performanceNavigationTiming[key];
            if (typeof value === 'number') {
              entries[key] = value;
            }
          }
        });
      } else {
        // // fallback to previous version
        var perf = otperformance;
        var performanceTiming_1 = perf.timing;
        if (performanceTiming_1) {
          var keys = Object.values(PerformanceTimingNames);
          keys.forEach(function (key) {
            if (hasKey(performanceTiming_1, key)) {
              var value = performanceTiming_1[key];
              if (typeof value === 'number') {
                entries[key] = value;
              }
            }
          });
        }
      }
      return entries;
    };
    var performancePaintNames = {
      'first-paint': EventNames$1.FIRST_PAINT,
      'first-contentful-paint': EventNames$1.FIRST_CONTENTFUL_PAINT
    };
    var addSpanPerformancePaintEvents = function (span) {
      var _a, _b;
      var performancePaintTiming = (_b = (_a = otperformance).getEntriesByType) === null || _b === void 0 ? void 0 : _b.call(_a, 'paint');
      if (performancePaintTiming) {
        performancePaintTiming.forEach(function (_a) {
          var name = _a.name,
            startTime = _a.startTime;
          if (hasKey(performancePaintNames, name)) {
            span.addEvent(performancePaintNames[name], startTime);
          }
        });
      }
    };

    /*
     * Copyright The OpenTelemetry Authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      https://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    var __extends$3 = undefined && undefined.__extends || function () {
      var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf || {
          __proto__: []
        } instanceof Array && function (d, b) {
          d.__proto__ = b;
        } || function (d, b) {
          for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
        };
        return extendStatics(d, b);
      };
      return function (d, b) {
        if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    /**
     * This class represents a document load plugin
     */
    var DocumentLoadInstrumentation = /** @class */function (_super) {
      __extends$3(DocumentLoadInstrumentation, _super);
      function DocumentLoadInstrumentation(config) {
        if (config === void 0) {
          config = {};
        }
        var _this = _super.call(this, PACKAGE_NAME$1, PACKAGE_VERSION$1, config) || this;
        _this.component = 'document-load';
        _this.version = '1';
        _this.moduleName = _this.component;
        return _this;
      }
      DocumentLoadInstrumentation.prototype.init = function () {};
      /**
       * callback to be executed when page is loaded
       */
      DocumentLoadInstrumentation.prototype._onDocumentLoaded = function () {
        var _this = this;
        // Timeout is needed as load event doesn't have yet the performance metrics for loadEnd.
        // Support for event "loadend" is very limited and cannot be used
        window.setTimeout(function () {
          _this._collectPerformance();
        });
      };
      /**
       * Adds spans for all resources
       * @param rootSpan
       */
      DocumentLoadInstrumentation.prototype._addResourcesSpans = function (rootSpan) {
        var _this = this;
        var _a, _b;
        var resources = (_b = (_a = otperformance).getEntriesByType) === null || _b === void 0 ? void 0 : _b.call(_a, 'resource');
        if (resources) {
          resources.forEach(function (resource) {
            _this._initResourceSpan(resource, rootSpan);
          });
        }
      };
      /**
       * Collects information about performance and creates appropriate spans
       */
      DocumentLoadInstrumentation.prototype._collectPerformance = function () {
        var _this = this;
        var metaElement = Array.from(document.getElementsByTagName('meta')).find(function (e) {
          return e.getAttribute('name') === TRACE_PARENT_HEADER;
        });
        var entries = getPerformanceNavigationEntries();
        var traceparent = metaElement && metaElement.content || '';
        context.with(propagation.extract(ROOT_CONTEXT, {
          traceparent: traceparent
        }), function () {
          var _a;
          var rootSpan = _this._startSpan(AttributeNames$3.DOCUMENT_LOAD, PerformanceTimingNames.FETCH_START, entries);
          if (!rootSpan) {
            return;
          }
          context.with(trace.setSpan(context.active(), rootSpan), function () {
            var fetchSpan = _this._startSpan(AttributeNames$3.DOCUMENT_FETCH, PerformanceTimingNames.FETCH_START, entries);
            if (fetchSpan) {
              fetchSpan.setAttribute(SEMATTRS_HTTP_URL$2, location.href);
              context.with(trace.setSpan(context.active(), fetchSpan), function () {
                var _a;
                if (!_this.getConfig().ignoreNetworkEvents) {
                  addSpanNetworkEvents(fetchSpan, entries);
                }
                _this._addCustomAttributesOnSpan(fetchSpan, (_a = _this.getConfig().applyCustomAttributesOnSpan) === null || _a === void 0 ? void 0 : _a.documentFetch);
                _this._endSpan(fetchSpan, PerformanceTimingNames.RESPONSE_END, entries);
              });
            }
          });
          rootSpan.setAttribute(SEMATTRS_HTTP_URL$2, location.href);
          rootSpan.setAttribute(SEMATTRS_HTTP_USER_AGENT$2, navigator.userAgent);
          _this._addResourcesSpans(rootSpan);
          if (!_this.getConfig().ignoreNetworkEvents) {
            addSpanNetworkEvent(rootSpan, PerformanceTimingNames.FETCH_START, entries);
            addSpanNetworkEvent(rootSpan, PerformanceTimingNames.UNLOAD_EVENT_START, entries);
            addSpanNetworkEvent(rootSpan, PerformanceTimingNames.UNLOAD_EVENT_END, entries);
            addSpanNetworkEvent(rootSpan, PerformanceTimingNames.DOM_INTERACTIVE, entries);
            addSpanNetworkEvent(rootSpan, PerformanceTimingNames.DOM_CONTENT_LOADED_EVENT_START, entries);
            addSpanNetworkEvent(rootSpan, PerformanceTimingNames.DOM_CONTENT_LOADED_EVENT_END, entries);
            addSpanNetworkEvent(rootSpan, PerformanceTimingNames.DOM_COMPLETE, entries);
            addSpanNetworkEvent(rootSpan, PerformanceTimingNames.LOAD_EVENT_START, entries);
            addSpanNetworkEvent(rootSpan, PerformanceTimingNames.LOAD_EVENT_END, entries);
          }
          if (!_this.getConfig().ignorePerformancePaintEvents) {
            addSpanPerformancePaintEvents(rootSpan);
          }
          _this._addCustomAttributesOnSpan(rootSpan, (_a = _this.getConfig().applyCustomAttributesOnSpan) === null || _a === void 0 ? void 0 : _a.documentLoad);
          _this._endSpan(rootSpan, PerformanceTimingNames.LOAD_EVENT_END, entries);
        });
      };
      /**
       * Helper function for ending span
       * @param span
       * @param performanceName name of performance entry for time end
       * @param entries
       */
      DocumentLoadInstrumentation.prototype._endSpan = function (span, performanceName, entries) {
        // span can be undefined when entries are missing the certain performance - the span will not be created
        if (span) {
          if (hasKey(entries, performanceName)) {
            span.end(entries[performanceName]);
          } else {
            // just end span
            span.end();
          }
        }
      };
      /**
       * Creates and ends a span with network information about resource added as timed events
       * @param resource
       * @param parentSpan
       */
      DocumentLoadInstrumentation.prototype._initResourceSpan = function (resource, parentSpan) {
        var _a;
        var span = this._startSpan(AttributeNames$3.RESOURCE_FETCH, PerformanceTimingNames.FETCH_START, resource, parentSpan);
        if (span) {
          span.setAttribute(SEMATTRS_HTTP_URL$2, resource.name);
          if (!this.getConfig().ignoreNetworkEvents) {
            addSpanNetworkEvents(span, resource);
          }
          this._addCustomAttributesOnResourceSpan(span, resource, (_a = this.getConfig().applyCustomAttributesOnSpan) === null || _a === void 0 ? void 0 : _a.resourceFetch);
          this._endSpan(span, PerformanceTimingNames.RESPONSE_END, resource);
        }
      };
      /**
       * Helper function for starting a span
       * @param spanName name of span
       * @param performanceName name of performance entry for time start
       * @param entries
       * @param parentSpan
       */
      DocumentLoadInstrumentation.prototype._startSpan = function (spanName, performanceName, entries, parentSpan) {
        if (hasKey(entries, performanceName) && typeof entries[performanceName] === 'number') {
          var span = this.tracer.startSpan(spanName, {
            startTime: entries[performanceName]
          }, parentSpan ? trace.setSpan(context.active(), parentSpan) : undefined);
          return span;
        }
        return undefined;
      };
      /**
       * executes callback {_onDocumentLoaded} when the page is loaded
       */
      DocumentLoadInstrumentation.prototype._waitForPageLoad = function () {
        if (window.document.readyState === 'complete') {
          this._onDocumentLoaded();
        } else {
          this._onDocumentLoaded = this._onDocumentLoaded.bind(this);
          window.addEventListener('load', this._onDocumentLoaded);
        }
      };
      /**
       * adds custom attributes to root span if configured
       */
      DocumentLoadInstrumentation.prototype._addCustomAttributesOnSpan = function (span, applyCustomAttributesOnSpan) {
        var _this = this;
        if (applyCustomAttributesOnSpan) {
          safeExecuteInTheMiddle(function () {
            return applyCustomAttributesOnSpan(span);
          }, function (error) {
            if (!error) {
              return;
            }
            _this._diag.error('addCustomAttributesOnSpan', error);
          });
        }
      };
      /**
       * adds custom attributes to span if configured
       */
      DocumentLoadInstrumentation.prototype._addCustomAttributesOnResourceSpan = function (span, resource, applyCustomAttributesOnSpan) {
        var _this = this;
        if (applyCustomAttributesOnSpan) {
          safeExecuteInTheMiddle(function () {
            return applyCustomAttributesOnSpan(span, resource);
          }, function (error) {
            if (!error) {
              return;
            }
            _this._diag.error('addCustomAttributesOnResourceSpan', error);
          });
        }
      };
      /**
       * implements enable function
       */
      DocumentLoadInstrumentation.prototype.enable = function () {
        // remove previously attached load to avoid adding the same event twice
        // in case of multiple enable calling.
        window.removeEventListener('load', this._onDocumentLoaded);
        this._waitForPageLoad();
      };
      /**
       * implements disable function
       */
      DocumentLoadInstrumentation.prototype.disable = function () {
        window.removeEventListener('load', this._onDocumentLoaded);
      };
      return DocumentLoadInstrumentation;
    }(InstrumentationBase);

    /*
     * Copyright The OpenTelemetry Authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      https://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    /**
     * https://github.com/open-telemetry/opentelemetry-specification/blob/master/specification/trace/semantic_conventions/http.md
     */
    var AttributeNames$2;
    (function (AttributeNames) {
      AttributeNames["COMPONENT"] = "component";
      AttributeNames["HTTP_ERROR_NAME"] = "http.error_name";
      AttributeNames["HTTP_STATUS_TEXT"] = "http.status_text";
    })(AttributeNames$2 || (AttributeNames$2 = {}));

    /*
     * Copyright The OpenTelemetry Authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      https://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    var TMP_HTTP_METHOD$1 = 'http.method';
    var TMP_HTTP_URL$1 = 'http.url';
    var TMP_HTTP_HOST$1 = 'http.host';
    var TMP_HTTP_SCHEME$1 = 'http.scheme';
    var TMP_HTTP_STATUS_CODE$1 = 'http.status_code';
    var TMP_HTTP_USER_AGENT$1 = 'http.user_agent';
    var TMP_HTTP_REQUEST_CONTENT_LENGTH_UNCOMPRESSED$1 = 'http.request_content_length_uncompressed';
    /**
     * HTTP request method.
     *
     * @deprecated Use ATTR_HTTP_METHOD in [incubating entry-point]({@link https://github.com/open-telemetry/opentelemetry-js/blob/main/semantic-conventions/README.md#unstable-semconv}).
     */
    var SEMATTRS_HTTP_METHOD$1 = TMP_HTTP_METHOD$1;
    /**
     * Full HTTP request URL in the form `scheme://host[:port]/path?query[#fragment]`. Usually the fragment is not transmitted over HTTP, but if it is known, it should be included nevertheless.
     *
     * Note: `http.url` MUST NOT contain credentials passed via URL in form of `https://username:password@www.example.com/`. In such case the attribute&#39;s value should be `https://www.example.com/`.
     *
     * @deprecated Use ATTR_HTTP_URL in [incubating entry-point]({@link https://github.com/open-telemetry/opentelemetry-js/blob/main/semantic-conventions/README.md#unstable-semconv}).
     */
    var SEMATTRS_HTTP_URL$1 = TMP_HTTP_URL$1;
    /**
     * The value of the [HTTP host header](https://tools.ietf.org/html/rfc7230#section-5.4). An empty Host header should also be reported, see note.
     *
     * Note: When the header is present but empty the attribute SHOULD be set to the empty string. Note that this is a valid situation that is expected in certain cases, according the aforementioned [section of RFC 7230](https://tools.ietf.org/html/rfc7230#section-5.4). When the header is not set the attribute MUST NOT be set.
     *
     * @deprecated Use ATTR_HTTP_HOST in [incubating entry-point]({@link https://github.com/open-telemetry/opentelemetry-js/blob/main/semantic-conventions/README.md#unstable-semconv}).
     */
    var SEMATTRS_HTTP_HOST$1 = TMP_HTTP_HOST$1;
    /**
     * The URI scheme identifying the used protocol.
     *
     * @deprecated Use ATTR_HTTP_SCHEME in [incubating entry-point]({@link https://github.com/open-telemetry/opentelemetry-js/blob/main/semantic-conventions/README.md#unstable-semconv}).
     */
    var SEMATTRS_HTTP_SCHEME$1 = TMP_HTTP_SCHEME$1;
    /**
     * [HTTP response status code](https://tools.ietf.org/html/rfc7231#section-6).
     *
     * @deprecated Use ATTR_HTTP_STATUS_CODE in [incubating entry-point]({@link https://github.com/open-telemetry/opentelemetry-js/blob/main/semantic-conventions/README.md#unstable-semconv}).
     */
    var SEMATTRS_HTTP_STATUS_CODE$1 = TMP_HTTP_STATUS_CODE$1;
    /**
     * Value of the [HTTP User-Agent](https://tools.ietf.org/html/rfc7231#section-5.5.3) header sent by the client.
     *
     * @deprecated Use ATTR_HTTP_USER_AGENT in [incubating entry-point]({@link https://github.com/open-telemetry/opentelemetry-js/blob/main/semantic-conventions/README.md#unstable-semconv}).
     */
    var SEMATTRS_HTTP_USER_AGENT$1 = TMP_HTTP_USER_AGENT$1;
    /**
     * The size of the uncompressed request payload body after transport decoding. Not set if transport encoding not used.
     *
     * @deprecated Use ATTR_HTTP_REQUEST_CONTENT_LENGTH_UNCOMPRESSED in [incubating entry-point]({@link https://github.com/open-telemetry/opentelemetry-js/blob/main/semantic-conventions/README.md#unstable-semconv}).
     */
    var SEMATTRS_HTTP_REQUEST_CONTENT_LENGTH_UNCOMPRESSED$1 = TMP_HTTP_REQUEST_CONTENT_LENGTH_UNCOMPRESSED$1;

    /*
     * Copyright The OpenTelemetry Authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      https://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    var __awaiter = undefined && undefined.__awaiter || function (thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function (resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator = undefined && undefined.__generator || function (thisArg, body) {
      var _ = {
          label: 0,
          sent: function () {
            if (t[0] & 1) throw t[1];
            return t[1];
          },
          trys: [],
          ops: []
        },
        f,
        y,
        t,
        g;
      return g = {
        next: verb(0),
        "throw": verb(1),
        "return": verb(2)
      }, typeof Symbol === "function" && (g[Symbol.iterator] = function () {
        return this;
      }), g;
      function verb(n) {
        return function (v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
          if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
          if (y = 0, t) op = [op[0] & 2, t.value];
          switch (op[0]) {
            case 0:
            case 1:
              t = op;
              break;
            case 4:
              _.label++;
              return {
                value: op[1],
                done: false
              };
            case 5:
              _.label++;
              y = op[1];
              op = [0];
              continue;
            case 7:
              op = _.ops.pop();
              _.trys.pop();
              continue;
            default:
              if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                _ = 0;
                continue;
              }
              if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                _.label = op[1];
                break;
              }
              if (op[0] === 6 && _.label < t[1]) {
                _.label = t[1];
                t = op;
                break;
              }
              if (t && _.label < t[2]) {
                _.label = t[2];
                _.ops.push(op);
                break;
              }
              if (t[2]) _.ops.pop();
              _.trys.pop();
              continue;
          }
          op = body.call(thisArg, _);
        } catch (e) {
          op = [6, e];
          y = 0;
        } finally {
          f = t = 0;
        }
        if (op[0] & 5) throw op[1];
        return {
          value: op[0] ? op[1] : void 0,
          done: true
        };
      }
    };
    var __values$1 = undefined && undefined.__values || function (o) {
      var s = typeof Symbol === "function" && Symbol.iterator,
        m = s && o[s],
        i = 0;
      if (m) return m.call(o);
      if (o && typeof o.length === "number") return {
        next: function () {
          if (o && i >= o.length) o = void 0;
          return {
            value: o && o[i++],
            done: !o
          };
        }
      };
      throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    };
    var __read$2 = undefined && undefined.__read || function (o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m) return o;
      var i = m.call(o),
        r,
        ar = [],
        e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
      } catch (error) {
        e = {
          error: error
        };
      } finally {
        try {
          if (r && !r.done && (m = i["return"])) m.call(i);
        } finally {
          if (e) throw e.error;
        }
      }
      return ar;
    };
    var DIAG_LOGGER$1 = diag.createComponentLogger({
      namespace: '@opentelemetry/opentelemetry-instrumentation-fetch/utils'
    });
    /**
     * Helper function to determine payload content length for fetch requests
     *
     * The fetch API is kinda messy: there are a couple of ways the body can be passed in.
     *
     * In all cases, the body param can be some variation of ReadableStream,
     * and ReadableStreams can only be read once! We want to avoid consuming the body here,
     * because that would mean that the body never gets sent with the actual fetch request.
     *
     * Either the first arg is a Request object, which can be cloned
     *   so we can clone that object and read the body of the clone
     *   without disturbing the original argument
     *   However, reading the body here can only be done async; the body() method returns a promise
     *   this means this entire function has to return a promise
     *
     * OR the first arg is a url/string
     *   in which case the second arg has type RequestInit
     *   RequestInit is NOT cloneable, but RequestInit.body is writable
     *   so we can chain it into ReadableStream.pipeThrough()
     *
     *   ReadableStream.pipeThrough() lets us process a stream and returns a new stream
     *   So we can measure the body length as it passes through the pie, but need to attach
     *   the new stream to the original request
     *   so that the browser still has access to the body.
     *
     * @param body
     * @returns promise that resolves to the content length of the body
     */
    function getFetchBodyLength() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      if (args[0] instanceof URL || typeof args[0] === 'string') {
        var requestInit = args[1];
        if (!(requestInit === null || requestInit === void 0 ? void 0 : requestInit.body)) {
          return Promise.resolve();
        }
        if (requestInit.body instanceof ReadableStream) {
          var _a = _getBodyNonDestructively(requestInit.body),
            body = _a.body,
            length_1 = _a.length;
          requestInit.body = body;
          return length_1;
        } else {
          return Promise.resolve(getXHRBodyLength$1(requestInit.body));
        }
      } else {
        var info = args[0];
        if (!(info === null || info === void 0 ? void 0 : info.body)) {
          return Promise.resolve();
        }
        return info.clone().text().then(function (t) {
          return getByteLength$1(t);
        });
      }
    }
    function _getBodyNonDestructively(body) {
      // can't read a ReadableStream without destroying it
      // but we CAN pipe it through and return a new ReadableStream
      // some (older) platforms don't expose the pipeThrough method and in that scenario, we're out of luck;
      //   there's no way to read the stream without consuming it.
      if (!body.pipeThrough) {
        DIAG_LOGGER$1.warn('Platform has ReadableStream but not pipeThrough!');
        return {
          body: body,
          length: Promise.resolve(undefined)
        };
      }
      var length = 0;
      var resolveLength;
      var lengthPromise = new Promise(function (resolve) {
        resolveLength = resolve;
      });
      var transform = new TransformStream({
        start: function () {},
        transform: function (chunk, controller) {
          return __awaiter(this, void 0, void 0, function () {
            var bytearray;
            return __generator(this, function (_a) {
              switch (_a.label) {
                case 0:
                  return [4 /*yield*/, chunk];
                case 1:
                  bytearray = _a.sent();
                  length += bytearray.byteLength;
                  controller.enqueue(chunk);
                  return [2 /*return*/];
              }
            });
          });
        },
        flush: function () {
          resolveLength(length);
        }
      });
      return {
        body: body.pipeThrough(transform),
        length: lengthPromise
      };
    }
    /**
     * Helper function to determine payload content length for XHR requests
     * @param body
     * @returns content length
     */
    function getXHRBodyLength$1(body) {
      if (typeof Document !== 'undefined' && body instanceof Document) {
        return new XMLSerializer().serializeToString(document).length;
      }
      // XMLHttpRequestBodyInit expands to the following:
      if (body instanceof Blob) {
        return body.size;
      }
      // ArrayBuffer | ArrayBufferView
      if (body.byteLength !== undefined) {
        return body.byteLength;
      }
      if (body instanceof FormData) {
        return getFormDataSize$1(body);
      }
      if (body instanceof URLSearchParams) {
        return getByteLength$1(body.toString());
      }
      if (typeof body === 'string') {
        return getByteLength$1(body);
      }
      DIAG_LOGGER$1.warn('unknown body type');
      return undefined;
    }
    var TEXT_ENCODER$1 = new TextEncoder();
    function getByteLength$1(s) {
      return TEXT_ENCODER$1.encode(s).byteLength;
    }
    function getFormDataSize$1(formData) {
      var e_1, _a;
      var size = 0;
      try {
        for (var _b = __values$1(formData.entries()), _c = _b.next(); !_c.done; _c = _b.next()) {
          var _d = __read$2(_c.value, 2),
            key = _d[0],
            value = _d[1];
          size += key.length;
          if (value instanceof Blob) {
            size += value.size;
          } else {
            size += value.length;
          }
        }
      } catch (e_1_1) {
        e_1 = {
          error: e_1_1
        };
      } finally {
        try {
          if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
        } finally {
          if (e_1) throw e_1.error;
        }
      }
      return size;
    }

    /*
     * Copyright The OpenTelemetry Authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      https://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    // this is autogenerated file, see scripts/version-update.js
    var VERSION$1 = '0.57.2';

    /*
     * Copyright The OpenTelemetry Authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      https://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    var __extends$2 = undefined && undefined.__extends || function () {
      var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf || {
          __proto__: []
        } instanceof Array && function (d, b) {
          d.__proto__ = b;
        } || function (d, b) {
          for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
        };
        return extendStatics(d, b);
      };
      return function (d, b) {
        if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var __read$1 = undefined && undefined.__read || function (o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m) return o;
      var i = m.call(o),
        r,
        ar = [],
        e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
      } catch (error) {
        e = {
          error: error
        };
      } finally {
        try {
          if (r && !r.done && (m = i["return"])) m.call(i);
        } finally {
          if (e) throw e.error;
        }
      }
      return ar;
    };
    var __spreadArray = undefined && undefined.__spreadArray || function (to, from, pack) {
      if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
          if (!ar) ar = Array.prototype.slice.call(from, 0, i);
          ar[i] = from[i];
        }
      }
      return to.concat(ar || Array.prototype.slice.call(from));
    };
    var _a;
    // how long to wait for observer to collect information about resources
    // this is needed as event "load" is called before observer
    // hard to say how long it should really wait, seems like 300ms is
    // safe enough
    var OBSERVER_WAIT_TIME_MS$1 = 300;
    var isNode = typeof process === 'object' && ((_a = process.release) === null || _a === void 0 ? void 0 : _a.name) === 'node';
    /**
     * This class represents a fetch plugin for auto instrumentation
     */
    var FetchInstrumentation = /** @class */function (_super) {
      __extends$2(FetchInstrumentation, _super);
      function FetchInstrumentation(config) {
        if (config === void 0) {
          config = {};
        }
        var _this = _super.call(this, '@opentelemetry/instrumentation-fetch', VERSION$1, config) || this;
        _this.component = 'fetch';
        _this.version = VERSION$1;
        _this.moduleName = _this.component;
        _this._usedResources = new WeakSet();
        _this._tasksCount = 0;
        return _this;
      }
      FetchInstrumentation.prototype.init = function () {};
      /**
       * Add cors pre flight child span
       * @param span
       * @param corsPreFlightRequest
       */
      FetchInstrumentation.prototype._addChildSpan = function (span, corsPreFlightRequest) {
        var childSpan = this.tracer.startSpan('CORS Preflight', {
          startTime: corsPreFlightRequest[PerformanceTimingNames.FETCH_START]
        }, trace.setSpan(context.active(), span));
        addSpanNetworkEvents(childSpan, corsPreFlightRequest, this.getConfig().ignoreNetworkEvents);
        childSpan.end(corsPreFlightRequest[PerformanceTimingNames.RESPONSE_END]);
      };
      /**
       * Adds more attributes to span just before ending it
       * @param span
       * @param response
       */
      FetchInstrumentation.prototype._addFinalSpanAttributes = function (span, response) {
        var parsedUrl = parseUrl(response.url);
        span.setAttribute(SEMATTRS_HTTP_STATUS_CODE$1, response.status);
        if (response.statusText != null) {
          span.setAttribute(AttributeNames$2.HTTP_STATUS_TEXT, response.statusText);
        }
        span.setAttribute(SEMATTRS_HTTP_HOST$1, parsedUrl.host);
        span.setAttribute(SEMATTRS_HTTP_SCHEME$1, parsedUrl.protocol.replace(':', ''));
        if (typeof navigator !== 'undefined') {
          span.setAttribute(SEMATTRS_HTTP_USER_AGENT$1, navigator.userAgent);
        }
      };
      /**
       * Add headers
       * @param options
       * @param spanUrl
       */
      FetchInstrumentation.prototype._addHeaders = function (options, spanUrl) {
        if (!shouldPropagateTraceHeaders(spanUrl, this.getConfig().propagateTraceHeaderCorsUrls)) {
          var headers = {};
          propagation.inject(context.active(), headers);
          if (Object.keys(headers).length > 0) {
            this._diag.debug('headers inject skipped due to CORS policy');
          }
          return;
        }
        if (options instanceof Request) {
          propagation.inject(context.active(), options.headers, {
            set: function (h, k, v) {
              return h.set(k, typeof v === 'string' ? v : String(v));
            }
          });
        } else if (options.headers instanceof Headers) {
          propagation.inject(context.active(), options.headers, {
            set: function (h, k, v) {
              return h.set(k, typeof v === 'string' ? v : String(v));
            }
          });
        } else if (options.headers instanceof Map) {
          propagation.inject(context.active(), options.headers, {
            set: function (h, k, v) {
              return h.set(k, typeof v === 'string' ? v : String(v));
            }
          });
        } else {
          var headers = {};
          propagation.inject(context.active(), headers);
          options.headers = Object.assign({}, headers, options.headers || {});
        }
      };
      /**
       * Clears the resource timings and all resources assigned with spans
       *     when {@link FetchPluginConfig.clearTimingResources} is
       *     set to true (default false)
       * @private
       */
      FetchInstrumentation.prototype._clearResources = function () {
        if (this._tasksCount === 0 && this.getConfig().clearTimingResources) {
          performance.clearResourceTimings();
          this._usedResources = new WeakSet();
        }
      };
      /**
       * Creates a new span
       * @param url
       * @param options
       */
      FetchInstrumentation.prototype._createSpan = function (url, options) {
        var _a;
        if (options === void 0) {
          options = {};
        }
        if (isUrlIgnored(url, this.getConfig().ignoreUrls)) {
          this._diag.debug('ignoring span as url matches ignored url');
          return;
        }
        var method = (options.method || 'GET').toUpperCase();
        var spanName = "HTTP " + method;
        return this.tracer.startSpan(spanName, {
          kind: SpanKind.CLIENT,
          attributes: (_a = {}, _a[AttributeNames$2.COMPONENT] = this.moduleName, _a[SEMATTRS_HTTP_METHOD$1] = method, _a[SEMATTRS_HTTP_URL$1] = url, _a)
        });
      };
      /**
       * Finds appropriate resource and add network events to the span
       * @param span
       * @param resourcesObserver
       * @param endTime
       */
      FetchInstrumentation.prototype._findResourceAndAddNetworkEvents = function (span, resourcesObserver, endTime) {
        var resources = resourcesObserver.entries;
        if (!resources.length) {
          if (!performance.getEntriesByType) {
            return;
          }
          // fallback - either Observer is not available or it took longer
          // then OBSERVER_WAIT_TIME_MS and observer didn't collect enough
          // information
          resources = performance.getEntriesByType('resource');
        }
        var resource = getResource(resourcesObserver.spanUrl, resourcesObserver.startTime, endTime, resources, this._usedResources, 'fetch');
        if (resource.mainRequest) {
          var mainRequest = resource.mainRequest;
          this._markResourceAsUsed(mainRequest);
          var corsPreFlightRequest = resource.corsPreFlightRequest;
          if (corsPreFlightRequest) {
            this._addChildSpan(span, corsPreFlightRequest);
            this._markResourceAsUsed(corsPreFlightRequest);
          }
          addSpanNetworkEvents(span, mainRequest, this.getConfig().ignoreNetworkEvents);
        }
      };
      /**
       * Marks certain [resource]{@link PerformanceResourceTiming} when information
       * from this is used to add events to span.
       * This is done to avoid reusing the same resource again for next span
       * @param resource
       */
      FetchInstrumentation.prototype._markResourceAsUsed = function (resource) {
        this._usedResources.add(resource);
      };
      /**
       * Finish span, add attributes, network events etc.
       * @param span
       * @param spanData
       * @param response
       */
      FetchInstrumentation.prototype._endSpan = function (span, spanData, response) {
        var _this = this;
        var endTime = millisToHrTime(Date.now());
        var performanceEndTime = hrTime();
        this._addFinalSpanAttributes(span, response);
        setTimeout(function () {
          var _a;
          (_a = spanData.observer) === null || _a === void 0 ? void 0 : _a.disconnect();
          _this._findResourceAndAddNetworkEvents(span, spanData, performanceEndTime);
          _this._tasksCount--;
          _this._clearResources();
          span.end(endTime);
        }, OBSERVER_WAIT_TIME_MS$1);
      };
      /**
       * Patches the constructor of fetch
       */
      FetchInstrumentation.prototype._patchConstructor = function () {
        var _this = this;
        return function (original) {
          var plugin = _this;
          return function patchConstructor() {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
              args[_i] = arguments[_i];
            }
            var self = this;
            var url = parseUrl(args[0] instanceof Request ? args[0].url : String(args[0])).href;
            var options = args[0] instanceof Request ? args[0] : args[1] || {};
            var createdSpan = plugin._createSpan(url, options);
            if (!createdSpan) {
              return original.apply(this, args);
            }
            var spanData = plugin._prepareSpanData(url);
            if (plugin.getConfig().measureRequestSize) {
              getFetchBodyLength.apply(void 0, __spreadArray([], __read$1(args), false)).then(function (length) {
                if (!length) return;
                createdSpan.setAttribute(SEMATTRS_HTTP_REQUEST_CONTENT_LENGTH_UNCOMPRESSED$1, length);
              }).catch(function (error) {
                plugin._diag.warn('getFetchBodyLength', error);
              });
            }
            function endSpanOnError(span, error) {
              plugin._applyAttributesAfterFetch(span, options, error);
              plugin._endSpan(span, spanData, {
                status: error.status || 0,
                statusText: error.message,
                url: url
              });
            }
            function endSpanOnSuccess(span, response) {
              plugin._applyAttributesAfterFetch(span, options, response);
              if (response.status >= 200 && response.status < 400) {
                plugin._endSpan(span, spanData, response);
              } else {
                plugin._endSpan(span, spanData, {
                  status: response.status,
                  statusText: response.statusText,
                  url: url
                });
              }
            }
            function onSuccess(span, resolve, response) {
              try {
                var resClone = response.clone();
                var resClone4Hook_1 = response.clone();
                var body = resClone.body;
                if (body) {
                  var reader_1 = body.getReader();
                  var read_1 = function () {
                    reader_1.read().then(function (_a) {
                      var done = _a.done;
                      if (done) {
                        endSpanOnSuccess(span, resClone4Hook_1);
                      } else {
                        read_1();
                      }
                    }, function (error) {
                      endSpanOnError(span, error);
                    });
                  };
                  read_1();
                } else {
                  // some older browsers don't have .body implemented
                  endSpanOnSuccess(span, response);
                }
              } finally {
                resolve(response);
              }
            }
            function onError(span, reject, error) {
              try {
                endSpanOnError(span, error);
              } finally {
                reject(error);
              }
            }
            return new Promise(function (resolve, reject) {
              return context.with(trace.setSpan(context.active(), createdSpan), function () {
                plugin._addHeaders(options, url);
                plugin._tasksCount++;
                // TypeScript complains about arrow function captured a this typed as globalThis
                // ts(7041)
                return original.apply(self, options instanceof Request ? [options] : [url, options]).then(onSuccess.bind(self, createdSpan, resolve), onError.bind(self, createdSpan, reject));
              });
            });
          };
        };
      };
      FetchInstrumentation.prototype._applyAttributesAfterFetch = function (span, request, result) {
        var _this = this;
        var applyCustomAttributesOnSpan = this.getConfig().applyCustomAttributesOnSpan;
        if (applyCustomAttributesOnSpan) {
          safeExecuteInTheMiddle(function () {
            return applyCustomAttributesOnSpan(span, request, result);
          }, function (error) {
            if (!error) {
              return;
            }
            _this._diag.error('applyCustomAttributesOnSpan', error);
          });
        }
      };
      /**
       * Prepares a span data - needed later for matching appropriate network
       *     resources
       * @param spanUrl
       */
      FetchInstrumentation.prototype._prepareSpanData = function (spanUrl) {
        var startTime = hrTime();
        var entries = [];
        if (typeof PerformanceObserver !== 'function') {
          return {
            entries: entries,
            startTime: startTime,
            spanUrl: spanUrl
          };
        }
        var observer = new PerformanceObserver(function (list) {
          var perfObsEntries = list.getEntries();
          perfObsEntries.forEach(function (entry) {
            if (entry.initiatorType === 'fetch' && entry.name === spanUrl) {
              entries.push(entry);
            }
          });
        });
        observer.observe({
          entryTypes: ['resource']
        });
        return {
          entries: entries,
          observer: observer,
          startTime: startTime,
          spanUrl: spanUrl
        };
      };
      /**
       * implements enable function
       */
      FetchInstrumentation.prototype.enable = function () {
        if (isNode) {
          // Node.js v18+ *does* have a global `fetch()`, but this package does not
          // support instrumenting it.
          this._diag.warn("this instrumentation is intended for web usage only, it does not instrument Node.js's fetch()");
          return;
        }
        if (isWrapped(fetch)) {
          this._unwrap(_globalThis, 'fetch');
          this._diag.debug('removing previous patch for constructor');
        }
        this._wrap(_globalThis, 'fetch', this._patchConstructor());
      };
      /**
       * implements unpatch function
       */
      FetchInstrumentation.prototype.disable = function () {
        if (isNode) {
          return;
        }
        this._unwrap(_globalThis, 'fetch');
        this._usedResources = new WeakSet();
      };
      return FetchInstrumentation;
    }(InstrumentationBase);

    /*
     * Copyright The OpenTelemetry Authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      https://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    var AttributeNames$1;
    (function (AttributeNames) {
      AttributeNames["EVENT_TYPE"] = "event_type";
      AttributeNames["TARGET_ELEMENT"] = "target_element";
      AttributeNames["TARGET_XPATH"] = "target_xpath";
      AttributeNames["HTTP_URL"] = "http.url";
    })(AttributeNames$1 || (AttributeNames$1 = {}));

    /*
     * Copyright The OpenTelemetry Authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      https://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    // this is autogenerated file, see scripts/version-update.js
    var PACKAGE_VERSION = '0.44.1';
    var PACKAGE_NAME = '@opentelemetry/instrumentation-user-interaction';

    /*
     * Copyright The OpenTelemetry Authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      https://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    var __extends$1 = undefined && undefined.__extends || function () {
      var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf || {
          __proto__: []
        } instanceof Array && function (d, b) {
          d.__proto__ = b;
        } || function (d, b) {
          for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
        };
        return extendStatics(d, b);
      };
      return function (d, b) {
        if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var ZONE_CONTEXT_KEY = 'OT_ZONE_CONTEXT';
    var EVENT_NAVIGATION_NAME = 'Navigation:';
    var DEFAULT_EVENT_NAMES = ['click'];
    function defaultShouldPreventSpanCreation() {
      return false;
    }
    /**
     * This class represents a UserInteraction plugin for auto instrumentation.
     * If zone.js is available then it patches the zone otherwise it patches
     * addEventListener of HTMLElement
     */
    var UserInteractionInstrumentation = /** @class */function (_super) {
      __extends$1(UserInteractionInstrumentation, _super);
      function UserInteractionInstrumentation(config) {
        if (config === void 0) {
          config = {};
        }
        var _a;
        var _this = _super.call(this, PACKAGE_NAME, PACKAGE_VERSION, config) || this;
        _this.version = PACKAGE_VERSION;
        _this.moduleName = 'user-interaction';
        _this._spansData = new WeakMap();
        // for addEventListener/removeEventListener state
        _this._wrappedListeners = new WeakMap();
        // for event bubbling
        _this._eventsSpanMap = new WeakMap();
        _this._eventNames = new Set((_a = config === null || config === void 0 ? void 0 : config.eventNames) !== null && _a !== void 0 ? _a : DEFAULT_EVENT_NAMES);
        _this._shouldPreventSpanCreation = typeof (config === null || config === void 0 ? void 0 : config.shouldPreventSpanCreation) === 'function' ? config.shouldPreventSpanCreation : defaultShouldPreventSpanCreation;
        return _this;
      }
      UserInteractionInstrumentation.prototype.init = function () {};
      /**
       * This will check if last task was timeout and will save the time to
       * fix the user interaction when nothing happens
       * This timeout comes from xhr plugin which is needed to collect information
       * about last xhr main request from observer
       * @param task
       * @param span
       */
      UserInteractionInstrumentation.prototype._checkForTimeout = function (task, span) {
        var spanData = this._spansData.get(span);
        if (spanData) {
          if (task.source === 'setTimeout') {
            spanData.hrTimeLastTimeout = hrTime();
          } else if (task.source !== 'Promise.then' && task.source !== 'setTimeout') {
            spanData.hrTimeLastTimeout = undefined;
          }
        }
      };
      /**
       * Controls whether or not to create a span, based on the event type.
       */
      UserInteractionInstrumentation.prototype._allowEventName = function (eventName) {
        return this._eventNames.has(eventName);
      };
      /**
       * Creates a new span
       * @param element
       * @param eventName
       * @param parentSpan
       */
      UserInteractionInstrumentation.prototype._createSpan = function (element, eventName, parentSpan) {
        var _a;
        if (!(element instanceof HTMLElement)) {
          return undefined;
        }
        if (!element.getAttribute) {
          return undefined;
        }
        if (element.hasAttribute('disabled')) {
          return undefined;
        }
        if (!this._allowEventName(eventName)) {
          return undefined;
        }
        var xpath = getElementXPath(element, true);
        try {
          var span = this.tracer.startSpan(eventName, {
            attributes: (_a = {}, _a[AttributeNames$1.EVENT_TYPE] = eventName, _a[AttributeNames$1.TARGET_ELEMENT] = element.tagName, _a[AttributeNames$1.TARGET_XPATH] = xpath, _a[AttributeNames$1.HTTP_URL] = window.location.href, _a)
          }, parentSpan ? trace.setSpan(context.active(), parentSpan) : undefined);
          if (this._shouldPreventSpanCreation(eventName, element, span) === true) {
            return undefined;
          }
          this._spansData.set(span, {
            taskCount: 0
          });
          return span;
        } catch (e) {
          this._diag.error('failed to start create new user interaction span', e);
        }
        return undefined;
      };
      /**
       * Decrement number of tasks that left in zone,
       * This is needed to be able to end span when no more tasks left
       * @param span
       */
      UserInteractionInstrumentation.prototype._decrementTask = function (span) {
        var spanData = this._spansData.get(span);
        if (spanData) {
          spanData.taskCount--;
          if (spanData.taskCount === 0) {
            this._tryToEndSpan(span, spanData.hrTimeLastTimeout);
          }
        }
      };
      /**
       * Return the current span
       * @param zone
       * @private
       */
      UserInteractionInstrumentation.prototype._getCurrentSpan = function (zone) {
        var context = zone.get(ZONE_CONTEXT_KEY);
        if (context) {
          return trace.getSpan(context);
        }
        return context;
      };
      /**
       * Increment number of tasks that are run within the same zone.
       *     This is needed to be able to end span when no more tasks left
       * @param span
       */
      UserInteractionInstrumentation.prototype._incrementTask = function (span) {
        var spanData = this._spansData.get(span);
        if (spanData) {
          spanData.taskCount++;
        }
      };
      /**
       * Returns true iff we should use the patched callback; false if it's already been patched
       */
      UserInteractionInstrumentation.prototype.addPatchedListener = function (on, type, listener, wrappedListener) {
        var listener2Type = this._wrappedListeners.get(listener);
        if (!listener2Type) {
          listener2Type = new Map();
          this._wrappedListeners.set(listener, listener2Type);
        }
        var element2patched = listener2Type.get(type);
        if (!element2patched) {
          element2patched = new Map();
          listener2Type.set(type, element2patched);
        }
        if (element2patched.has(on)) {
          return false;
        }
        element2patched.set(on, wrappedListener);
        return true;
      };
      /**
       * Returns the patched version of the callback (or undefined)
       */
      UserInteractionInstrumentation.prototype.removePatchedListener = function (on, type, listener) {
        var listener2Type = this._wrappedListeners.get(listener);
        if (!listener2Type) {
          return undefined;
        }
        var element2patched = listener2Type.get(type);
        if (!element2patched) {
          return undefined;
        }
        var patched = element2patched.get(on);
        if (patched) {
          element2patched.delete(on);
          if (element2patched.size === 0) {
            listener2Type.delete(type);
            if (listener2Type.size === 0) {
              this._wrappedListeners.delete(listener);
            }
          }
        }
        return patched;
      };
      // utility method to deal with the Function|EventListener nature of addEventListener
      UserInteractionInstrumentation.prototype._invokeListener = function (listener, target, args) {
        if (typeof listener === 'function') {
          return listener.apply(target, args);
        } else {
          return listener.handleEvent(args[0]);
        }
      };
      /**
       * This patches the addEventListener of HTMLElement to be able to
       * auto instrument the click events
       * This is done when zone is not available
       */
      UserInteractionInstrumentation.prototype._patchAddEventListener = function () {
        var plugin = this;
        return function (original) {
          return function addEventListenerPatched(type, listener, useCapture) {
            // Forward calls with listener = null
            if (!listener) {
              return original.call(this, type, listener, useCapture);
            }
            // filter out null (typeof null === 'object')
            var once = useCapture && typeof useCapture === 'object' && useCapture.once;
            var patchedListener = function () {
              var _this = this;
              var args = [];
              for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
              }
              var parentSpan;
              var event = args[0];
              var target = event === null || event === void 0 ? void 0 : event.target;
              if (event) {
                parentSpan = plugin._eventsSpanMap.get(event);
              }
              if (once) {
                plugin.removePatchedListener(this, type, listener);
              }
              var span = plugin._createSpan(target, type, parentSpan);
              if (span) {
                if (event) {
                  plugin._eventsSpanMap.set(event, span);
                }
                return context.with(trace.setSpan(context.active(), span), function () {
                  var result = plugin._invokeListener(listener, _this, args);
                  // no zone so end span immediately
                  span.end();
                  return result;
                });
              } else {
                return plugin._invokeListener(listener, this, args);
              }
            };
            if (plugin.addPatchedListener(this, type, listener, patchedListener)) {
              return original.call(this, type, patchedListener, useCapture);
            }
          };
        };
      };
      /**
       * This patches the removeEventListener of HTMLElement to handle the fact that
       * we patched the original callbacks
       * This is done when zone is not available
       */
      UserInteractionInstrumentation.prototype._patchRemoveEventListener = function () {
        var plugin = this;
        return function (original) {
          return function removeEventListenerPatched(type, listener, useCapture) {
            var wrappedListener = plugin.removePatchedListener(this, type, listener);
            if (wrappedListener) {
              return original.call(this, type, wrappedListener, useCapture);
            } else {
              return original.call(this, type, listener, useCapture);
            }
          };
        };
      };
      /**
       * Most browser provide event listener api via EventTarget in prototype chain.
       * Exception to this is IE 11 which has it on the prototypes closest to EventTarget:
       *
       * * - has addEventListener in IE
       * ** - has addEventListener in all other browsers
       * ! - missing in IE
       *
       * HTMLElement -> Element -> Node * -> EventTarget **! -> Object
       * Document -> Node * -> EventTarget **! -> Object
       * Window * -> WindowProperties ! -> EventTarget **! -> Object
       */
      UserInteractionInstrumentation.prototype._getPatchableEventTargets = function () {
        return window.EventTarget ? [EventTarget.prototype] : [Node.prototype, Window.prototype];
      };
      /**
       * Patches the history api
       */
      UserInteractionInstrumentation.prototype._patchHistoryApi = function () {
        this._unpatchHistoryApi();
        this._wrap(history, 'replaceState', this._patchHistoryMethod());
        this._wrap(history, 'pushState', this._patchHistoryMethod());
        this._wrap(history, 'back', this._patchHistoryMethod());
        this._wrap(history, 'forward', this._patchHistoryMethod());
        this._wrap(history, 'go', this._patchHistoryMethod());
      };
      /**
       * Patches the certain history api method
       */
      UserInteractionInstrumentation.prototype._patchHistoryMethod = function () {
        var plugin = this;
        return function (original) {
          return function patchHistoryMethod() {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
              args[_i] = arguments[_i];
            }
            var url = "" + location.pathname + location.hash + location.search;
            var result = original.apply(this, args);
            var urlAfter = "" + location.pathname + location.hash + location.search;
            if (url !== urlAfter) {
              plugin._updateInteractionName(urlAfter);
            }
            return result;
          };
        };
      };
      /**
       * unpatch the history api methods
       */
      UserInteractionInstrumentation.prototype._unpatchHistoryApi = function () {
        if (isWrapped(history.replaceState)) this._unwrap(history, 'replaceState');
        if (isWrapped(history.pushState)) this._unwrap(history, 'pushState');
        if (isWrapped(history.back)) this._unwrap(history, 'back');
        if (isWrapped(history.forward)) this._unwrap(history, 'forward');
        if (isWrapped(history.go)) this._unwrap(history, 'go');
      };
      /**
       * Updates interaction span name
       * @param url
       */
      UserInteractionInstrumentation.prototype._updateInteractionName = function (url) {
        var span = trace.getSpan(context.active());
        if (span && typeof span.updateName === 'function') {
          span.updateName(EVENT_NAVIGATION_NAME + " " + url);
        }
      };
      /**
       * Patches zone cancel task - this is done to be able to correctly
       * decrement the number of remaining tasks
       */
      UserInteractionInstrumentation.prototype._patchZoneCancelTask = function () {
        var plugin = this;
        return function (original) {
          return function patchCancelTask(task) {
            var currentZone = Zone.current;
            var currentSpan = plugin._getCurrentSpan(currentZone);
            if (currentSpan && plugin._shouldCountTask(task, currentZone)) {
              plugin._decrementTask(currentSpan);
            }
            return original.call(this, task);
          };
        };
      };
      /**
       * Patches zone schedule task - this is done to be able to correctly
       * increment the number of tasks running within current zone but also to
       * save time in case of timeout running from xhr plugin when waiting for
       * main request from PerformanceResourceTiming
       */
      UserInteractionInstrumentation.prototype._patchZoneScheduleTask = function () {
        var plugin = this;
        return function (original) {
          return function patchScheduleTask(task) {
            var currentZone = Zone.current;
            var currentSpan = plugin._getCurrentSpan(currentZone);
            if (currentSpan && plugin._shouldCountTask(task, currentZone)) {
              plugin._incrementTask(currentSpan);
              plugin._checkForTimeout(task, currentSpan);
            }
            return original.call(this, task);
          };
        };
      };
      /**
       * Patches zone run task - this is done to be able to create a span when
       * user interaction starts
       * @private
       */
      UserInteractionInstrumentation.prototype._patchZoneRunTask = function () {
        var plugin = this;
        return function (original) {
          return function patchRunTask(task, applyThis, applyArgs) {
            var event = Array.isArray(applyArgs) && applyArgs[0] instanceof Event ? applyArgs[0] : undefined;
            var target = event === null || event === void 0 ? void 0 : event.target;
            var span;
            var activeZone = this;
            if (target) {
              span = plugin._createSpan(target, task.eventName);
              if (span) {
                plugin._incrementTask(span);
                return activeZone.run(function () {
                  try {
                    return context.with(trace.setSpan(context.active(), span), function () {
                      var currentZone = Zone.current;
                      task._zone = currentZone;
                      return original.call(currentZone, task, applyThis, applyArgs);
                    });
                  } finally {
                    plugin._decrementTask(span);
                  }
                });
              }
            } else {
              span = plugin._getCurrentSpan(activeZone);
            }
            try {
              return original.call(activeZone, task, applyThis, applyArgs);
            } finally {
              if (span && plugin._shouldCountTask(task, activeZone)) {
                plugin._decrementTask(span);
              }
            }
          };
        };
      };
      /**
       * Decides if task should be counted.
       * @param task
       * @param currentZone
       * @private
       */
      UserInteractionInstrumentation.prototype._shouldCountTask = function (task, currentZone) {
        if (task._zone) {
          currentZone = task._zone;
        }
        if (!currentZone || !task.data || task.data.isPeriodic) {
          return false;
        }
        var currentSpan = this._getCurrentSpan(currentZone);
        if (!currentSpan) {
          return false;
        }
        if (!this._spansData.get(currentSpan)) {
          return false;
        }
        return task.type === 'macroTask' || task.type === 'microTask';
      };
      /**
       * Will try to end span when such span still exists.
       * @param span
       * @param endTime
       * @private
       */
      UserInteractionInstrumentation.prototype._tryToEndSpan = function (span, endTime) {
        if (span) {
          var spanData = this._spansData.get(span);
          if (spanData) {
            span.end(endTime);
            this._spansData.delete(span);
          }
        }
      };
      /**
       * implements enable function
       */
      UserInteractionInstrumentation.prototype.enable = function () {
        var _this = this;
        var ZoneWithPrototype = this._getZoneWithPrototype();
        this._diag.debug('applying patch to', this.moduleName, this.version, 'zone:', !!ZoneWithPrototype);
        if (ZoneWithPrototype) {
          if (isWrapped(ZoneWithPrototype.prototype.runTask)) {
            this._unwrap(ZoneWithPrototype.prototype, 'runTask');
            this._diag.debug('removing previous patch from method runTask');
          }
          if (isWrapped(ZoneWithPrototype.prototype.scheduleTask)) {
            this._unwrap(ZoneWithPrototype.prototype, 'scheduleTask');
            this._diag.debug('removing previous patch from method scheduleTask');
          }
          if (isWrapped(ZoneWithPrototype.prototype.cancelTask)) {
            this._unwrap(ZoneWithPrototype.prototype, 'cancelTask');
            this._diag.debug('removing previous patch from method cancelTask');
          }
          this._zonePatched = true;
          this._wrap(ZoneWithPrototype.prototype, 'runTask', this._patchZoneRunTask());
          this._wrap(ZoneWithPrototype.prototype, 'scheduleTask', this._patchZoneScheduleTask());
          this._wrap(ZoneWithPrototype.prototype, 'cancelTask', this._patchZoneCancelTask());
        } else {
          this._zonePatched = false;
          var targets = this._getPatchableEventTargets();
          targets.forEach(function (target) {
            if (isWrapped(target.addEventListener)) {
              _this._unwrap(target, 'addEventListener');
              _this._diag.debug('removing previous patch from method addEventListener');
            }
            if (isWrapped(target.removeEventListener)) {
              _this._unwrap(target, 'removeEventListener');
              _this._diag.debug('removing previous patch from method removeEventListener');
            }
            _this._wrap(target, 'addEventListener', _this._patchAddEventListener());
            _this._wrap(target, 'removeEventListener', _this._patchRemoveEventListener());
          });
        }
        this._patchHistoryApi();
      };
      /**
       * implements unpatch function
       */
      UserInteractionInstrumentation.prototype.disable = function () {
        var _this = this;
        var ZoneWithPrototype = this._getZoneWithPrototype();
        this._diag.debug('removing patch from', this.moduleName, this.version, 'zone:', !!ZoneWithPrototype);
        if (ZoneWithPrototype && this._zonePatched) {
          if (isWrapped(ZoneWithPrototype.prototype.runTask)) {
            this._unwrap(ZoneWithPrototype.prototype, 'runTask');
          }
          if (isWrapped(ZoneWithPrototype.prototype.scheduleTask)) {
            this._unwrap(ZoneWithPrototype.prototype, 'scheduleTask');
          }
          if (isWrapped(ZoneWithPrototype.prototype.cancelTask)) {
            this._unwrap(ZoneWithPrototype.prototype, 'cancelTask');
          }
        } else {
          var targets = this._getPatchableEventTargets();
          targets.forEach(function (target) {
            if (isWrapped(target.addEventListener)) {
              _this._unwrap(target, 'addEventListener');
            }
            if (isWrapped(target.removeEventListener)) {
              _this._unwrap(target, 'removeEventListener');
            }
          });
        }
        this._unpatchHistoryApi();
      };
      /**
       * returns Zone
       */
      UserInteractionInstrumentation.prototype._getZoneWithPrototype = function () {
        var _window = window;
        return _window.Zone;
      };
      return UserInteractionInstrumentation;
    }(InstrumentationBase);

    /*
     * Copyright The OpenTelemetry Authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      https://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    var TMP_HTTP_METHOD = 'http.method';
    var TMP_HTTP_URL = 'http.url';
    var TMP_HTTP_HOST = 'http.host';
    var TMP_HTTP_SCHEME = 'http.scheme';
    var TMP_HTTP_STATUS_CODE = 'http.status_code';
    var TMP_HTTP_USER_AGENT = 'http.user_agent';
    var TMP_HTTP_REQUEST_CONTENT_LENGTH_UNCOMPRESSED = 'http.request_content_length_uncompressed';
    /**
     * HTTP request method.
     *
     * @deprecated Use ATTR_HTTP_METHOD in [incubating entry-point]({@link https://github.com/open-telemetry/opentelemetry-js/blob/main/semantic-conventions/README.md#unstable-semconv}).
     */
    var SEMATTRS_HTTP_METHOD = TMP_HTTP_METHOD;
    /**
     * Full HTTP request URL in the form `scheme://host[:port]/path?query[#fragment]`. Usually the fragment is not transmitted over HTTP, but if it is known, it should be included nevertheless.
     *
     * Note: `http.url` MUST NOT contain credentials passed via URL in form of `https://username:password@www.example.com/`. In such case the attribute&#39;s value should be `https://www.example.com/`.
     *
     * @deprecated Use ATTR_HTTP_URL in [incubating entry-point]({@link https://github.com/open-telemetry/opentelemetry-js/blob/main/semantic-conventions/README.md#unstable-semconv}).
     */
    var SEMATTRS_HTTP_URL = TMP_HTTP_URL;
    /**
     * The value of the [HTTP host header](https://tools.ietf.org/html/rfc7230#section-5.4). An empty Host header should also be reported, see note.
     *
     * Note: When the header is present but empty the attribute SHOULD be set to the empty string. Note that this is a valid situation that is expected in certain cases, according the aforementioned [section of RFC 7230](https://tools.ietf.org/html/rfc7230#section-5.4). When the header is not set the attribute MUST NOT be set.
     *
     * @deprecated Use ATTR_HTTP_HOST in [incubating entry-point]({@link https://github.com/open-telemetry/opentelemetry-js/blob/main/semantic-conventions/README.md#unstable-semconv}).
     */
    var SEMATTRS_HTTP_HOST = TMP_HTTP_HOST;
    /**
     * The URI scheme identifying the used protocol.
     *
     * @deprecated Use ATTR_HTTP_SCHEME in [incubating entry-point]({@link https://github.com/open-telemetry/opentelemetry-js/blob/main/semantic-conventions/README.md#unstable-semconv}).
     */
    var SEMATTRS_HTTP_SCHEME = TMP_HTTP_SCHEME;
    /**
     * [HTTP response status code](https://tools.ietf.org/html/rfc7231#section-6).
     *
     * @deprecated Use ATTR_HTTP_STATUS_CODE in [incubating entry-point]({@link https://github.com/open-telemetry/opentelemetry-js/blob/main/semantic-conventions/README.md#unstable-semconv}).
     */
    var SEMATTRS_HTTP_STATUS_CODE = TMP_HTTP_STATUS_CODE;
    /**
     * Value of the [HTTP User-Agent](https://tools.ietf.org/html/rfc7231#section-5.5.3) header sent by the client.
     *
     * @deprecated Use ATTR_HTTP_USER_AGENT in [incubating entry-point]({@link https://github.com/open-telemetry/opentelemetry-js/blob/main/semantic-conventions/README.md#unstable-semconv}).
     */
    var SEMATTRS_HTTP_USER_AGENT = TMP_HTTP_USER_AGENT;
    /**
     * The size of the uncompressed request payload body after transport decoding. Not set if transport encoding not used.
     *
     * @deprecated Use ATTR_HTTP_REQUEST_CONTENT_LENGTH_UNCOMPRESSED in [incubating entry-point]({@link https://github.com/open-telemetry/opentelemetry-js/blob/main/semantic-conventions/README.md#unstable-semconv}).
     */
    var SEMATTRS_HTTP_REQUEST_CONTENT_LENGTH_UNCOMPRESSED = TMP_HTTP_REQUEST_CONTENT_LENGTH_UNCOMPRESSED;

    /*
     * Copyright The OpenTelemetry Authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      https://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    var EventNames;
    (function (EventNames) {
      EventNames["METHOD_OPEN"] = "open";
      EventNames["METHOD_SEND"] = "send";
      EventNames["EVENT_ABORT"] = "abort";
      EventNames["EVENT_ERROR"] = "error";
      EventNames["EVENT_LOAD"] = "loaded";
      EventNames["EVENT_TIMEOUT"] = "timeout";
    })(EventNames || (EventNames = {}));

    /*
     * Copyright The OpenTelemetry Authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      https://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    var __values = undefined && undefined.__values || function (o) {
      var s = typeof Symbol === "function" && Symbol.iterator,
        m = s && o[s],
        i = 0;
      if (m) return m.call(o);
      if (o && typeof o.length === "number") return {
        next: function () {
          if (o && i >= o.length) o = void 0;
          return {
            value: o && o[i++],
            done: !o
          };
        }
      };
      throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    };
    var __read = undefined && undefined.__read || function (o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m) return o;
      var i = m.call(o),
        r,
        ar = [],
        e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
      } catch (error) {
        e = {
          error: error
        };
      } finally {
        try {
          if (r && !r.done && (m = i["return"])) m.call(i);
        } finally {
          if (e) throw e.error;
        }
      }
      return ar;
    };
    var DIAG_LOGGER = diag.createComponentLogger({
      namespace: '@opentelemetry/opentelemetry-instrumentation-xml-http-request/utils'
    });
    /**
     * Helper function to determine payload content length for XHR requests
     * @param body
     * @returns content length
     */
    function getXHRBodyLength(body) {
      if (typeof Document !== 'undefined' && body instanceof Document) {
        return new XMLSerializer().serializeToString(document).length;
      }
      // XMLHttpRequestBodyInit expands to the following:
      if (body instanceof Blob) {
        return body.size;
      }
      // ArrayBuffer | ArrayBufferView
      if (body.byteLength !== undefined) {
        return body.byteLength;
      }
      if (body instanceof FormData) {
        return getFormDataSize(body);
      }
      if (body instanceof URLSearchParams) {
        return getByteLength(body.toString());
      }
      if (typeof body === 'string') {
        return getByteLength(body);
      }
      DIAG_LOGGER.warn('unknown body type');
      return undefined;
    }
    var TEXT_ENCODER = new TextEncoder();
    function getByteLength(s) {
      return TEXT_ENCODER.encode(s).byteLength;
    }
    function getFormDataSize(formData) {
      var e_1, _a;
      var size = 0;
      try {
        for (var _b = __values(formData.entries()), _c = _b.next(); !_c.done; _c = _b.next()) {
          var _d = __read(_c.value, 2),
            key = _d[0],
            value = _d[1];
          size += key.length;
          if (value instanceof Blob) {
            size += value.size;
          } else {
            size += value.length;
          }
        }
      } catch (e_1_1) {
        e_1 = {
          error: e_1_1
        };
      } finally {
        try {
          if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
        } finally {
          if (e_1) throw e_1.error;
        }
      }
      return size;
    }

    /*
     * Copyright The OpenTelemetry Authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      https://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    // this is autogenerated file, see scripts/version-update.js
    var VERSION = '0.57.2';

    /*
     * Copyright The OpenTelemetry Authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      https://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    /**
     * https://github.com/open-telemetry/opentelemetry-specification/blob/master/specification/trace/semantic_conventions/http.md
     */
    var AttributeNames;
    (function (AttributeNames) {
      AttributeNames["HTTP_STATUS_TEXT"] = "http.status_text";
    })(AttributeNames || (AttributeNames = {}));

    /*
     * Copyright The OpenTelemetry Authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      https://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    var __extends = undefined && undefined.__extends || function () {
      var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf || {
          __proto__: []
        } instanceof Array && function (d, b) {
          d.__proto__ = b;
        } || function (d, b) {
          for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
        };
        return extendStatics(d, b);
      };
      return function (d, b) {
        if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    // how long to wait for observer to collect information about resources
    // this is needed as event "load" is called before observer
    // hard to say how long it should really wait, seems like 300ms is
    // safe enough
    var OBSERVER_WAIT_TIME_MS = 300;
    /**
     * This class represents a XMLHttpRequest plugin for auto instrumentation
     */
    var XMLHttpRequestInstrumentation = /** @class */function (_super) {
      __extends(XMLHttpRequestInstrumentation, _super);
      function XMLHttpRequestInstrumentation(config) {
        if (config === void 0) {
          config = {};
        }
        var _this = _super.call(this, '@opentelemetry/instrumentation-xml-http-request', VERSION, config) || this;
        _this.component = 'xml-http-request';
        _this.version = VERSION;
        _this.moduleName = _this.component;
        _this._tasksCount = 0;
        _this._xhrMem = new WeakMap();
        _this._usedResources = new WeakSet();
        return _this;
      }
      XMLHttpRequestInstrumentation.prototype.init = function () {};
      /**
       * Adds custom headers to XMLHttpRequest
       * @param xhr
       * @param spanUrl
       * @private
       */
      XMLHttpRequestInstrumentation.prototype._addHeaders = function (xhr, spanUrl) {
        var url = parseUrl(spanUrl).href;
        if (!shouldPropagateTraceHeaders(url, this.getConfig().propagateTraceHeaderCorsUrls)) {
          var headers_1 = {};
          propagation.inject(context.active(), headers_1);
          if (Object.keys(headers_1).length > 0) {
            this._diag.debug('headers inject skipped due to CORS policy');
          }
          return;
        }
        var headers = {};
        propagation.inject(context.active(), headers);
        Object.keys(headers).forEach(function (key) {
          xhr.setRequestHeader(key, String(headers[key]));
        });
      };
      /**
       * Add cors pre flight child span
       * @param span
       * @param corsPreFlightRequest
       * @private
       */
      XMLHttpRequestInstrumentation.prototype._addChildSpan = function (span, corsPreFlightRequest) {
        var _this = this;
        context.with(trace.setSpan(context.active(), span), function () {
          var childSpan = _this.tracer.startSpan('CORS Preflight', {
            startTime: corsPreFlightRequest[PerformanceTimingNames.FETCH_START]
          });
          addSpanNetworkEvents(childSpan, corsPreFlightRequest, _this.getConfig().ignoreNetworkEvents);
          childSpan.end(corsPreFlightRequest[PerformanceTimingNames.RESPONSE_END]);
        });
      };
      /**
       * Add attributes when span is going to end
       * @param span
       * @param xhr
       * @param spanUrl
       * @private
       */
      XMLHttpRequestInstrumentation.prototype._addFinalSpanAttributes = function (span, xhrMem, spanUrl) {
        if (typeof spanUrl === 'string') {
          var parsedUrl = parseUrl(spanUrl);
          if (xhrMem.status !== undefined) {
            span.setAttribute(SEMATTRS_HTTP_STATUS_CODE, xhrMem.status);
          }
          if (xhrMem.statusText !== undefined) {
            span.setAttribute(AttributeNames.HTTP_STATUS_TEXT, xhrMem.statusText);
          }
          span.setAttribute(SEMATTRS_HTTP_HOST, parsedUrl.host);
          span.setAttribute(SEMATTRS_HTTP_SCHEME, parsedUrl.protocol.replace(':', ''));
          // @TODO do we want to collect this or it will be collected earlier once only or
          //    maybe when parent span is not available ?
          span.setAttribute(SEMATTRS_HTTP_USER_AGENT, navigator.userAgent);
        }
      };
      XMLHttpRequestInstrumentation.prototype._applyAttributesAfterXHR = function (span, xhr) {
        var _this = this;
        var applyCustomAttributesOnSpan = this.getConfig().applyCustomAttributesOnSpan;
        if (typeof applyCustomAttributesOnSpan === 'function') {
          safeExecuteInTheMiddle(function () {
            return applyCustomAttributesOnSpan(span, xhr);
          }, function (error) {
            if (!error) {
              return;
            }
            _this._diag.error('applyCustomAttributesOnSpan', error);
          });
        }
      };
      /**
       * will collect information about all resources created
       * between "send" and "end" with additional waiting for main resource
       * @param xhr
       * @param spanUrl
       * @private
       */
      XMLHttpRequestInstrumentation.prototype._addResourceObserver = function (xhr, spanUrl) {
        var xhrMem = this._xhrMem.get(xhr);
        if (!xhrMem || typeof PerformanceObserver !== 'function' || typeof PerformanceResourceTiming !== 'function') {
          return;
        }
        xhrMem.createdResources = {
          observer: new PerformanceObserver(function (list) {
            var entries = list.getEntries();
            var parsedUrl = parseUrl(spanUrl);
            entries.forEach(function (entry) {
              if (entry.initiatorType === 'xmlhttprequest' && entry.name === parsedUrl.href) {
                if (xhrMem.createdResources) {
                  xhrMem.createdResources.entries.push(entry);
                }
              }
            });
          }),
          entries: []
        };
        xhrMem.createdResources.observer.observe({
          entryTypes: ['resource']
        });
      };
      /**
       * Clears the resource timings and all resources assigned with spans
       *     when {@link XMLHttpRequestInstrumentationConfig.clearTimingResources} is
       *     set to true (default false)
       * @private
       */
      XMLHttpRequestInstrumentation.prototype._clearResources = function () {
        if (this._tasksCount === 0 && this.getConfig().clearTimingResources) {
          otperformance.clearResourceTimings();
          this._xhrMem = new WeakMap();
          this._usedResources = new WeakSet();
        }
      };
      /**
       * Finds appropriate resource and add network events to the span
       * @param span
       */
      XMLHttpRequestInstrumentation.prototype._findResourceAndAddNetworkEvents = function (xhrMem, span, spanUrl, startTime, endTime) {
        if (!spanUrl || !startTime || !endTime || !xhrMem.createdResources) {
          return;
        }
        var resources = xhrMem.createdResources.entries;
        if (!resources || !resources.length) {
          // fallback - either Observer is not available or it took longer
          // then OBSERVER_WAIT_TIME_MS and observer didn't collect enough
          // information
          // ts thinks this is the perf_hooks module, but it is the browser performance api
          resources = otperformance.getEntriesByType('resource');
        }
        var resource = getResource(parseUrl(spanUrl).href, startTime, endTime, resources, this._usedResources);
        if (resource.mainRequest) {
          var mainRequest = resource.mainRequest;
          this._markResourceAsUsed(mainRequest);
          var corsPreFlightRequest = resource.corsPreFlightRequest;
          if (corsPreFlightRequest) {
            this._addChildSpan(span, corsPreFlightRequest);
            this._markResourceAsUsed(corsPreFlightRequest);
          }
          addSpanNetworkEvents(span, mainRequest, this.getConfig().ignoreNetworkEvents);
        }
      };
      /**
       * Removes the previous information about span.
       * This might happened when the same xhr is used again.
       * @param xhr
       * @private
       */
      XMLHttpRequestInstrumentation.prototype._cleanPreviousSpanInformation = function (xhr) {
        var xhrMem = this._xhrMem.get(xhr);
        if (xhrMem) {
          var callbackToRemoveEvents = xhrMem.callbackToRemoveEvents;
          if (callbackToRemoveEvents) {
            callbackToRemoveEvents();
          }
          this._xhrMem.delete(xhr);
        }
      };
      /**
       * Creates a new span when method "open" is called
       * @param xhr
       * @param url
       * @param method
       * @private
       */
      XMLHttpRequestInstrumentation.prototype._createSpan = function (xhr, url, method) {
        var _a;
        if (isUrlIgnored(url, this.getConfig().ignoreUrls)) {
          this._diag.debug('ignoring span as url matches ignored url');
          return;
        }
        var spanName = method.toUpperCase();
        var currentSpan = this.tracer.startSpan(spanName, {
          kind: SpanKind.CLIENT,
          attributes: (_a = {}, _a[SEMATTRS_HTTP_METHOD] = method, _a[SEMATTRS_HTTP_URL] = parseUrl(url).toString(), _a)
        });
        currentSpan.addEvent(EventNames.METHOD_OPEN);
        this._cleanPreviousSpanInformation(xhr);
        this._xhrMem.set(xhr, {
          span: currentSpan,
          spanUrl: url
        });
        return currentSpan;
      };
      /**
       * Marks certain [resource]{@link PerformanceResourceTiming} when information
       * from this is used to add events to span.
       * This is done to avoid reusing the same resource again for next span
       * @param resource
       * @private
       */
      XMLHttpRequestInstrumentation.prototype._markResourceAsUsed = function (resource) {
        this._usedResources.add(resource);
      };
      /**
       * Patches the method open
       * @private
       */
      XMLHttpRequestInstrumentation.prototype._patchOpen = function () {
        var _this = this;
        return function (original) {
          var plugin = _this;
          return function patchOpen() {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
              args[_i] = arguments[_i];
            }
            var method = args[0];
            var url = args[1];
            plugin._createSpan(this, url, method);
            return original.apply(this, args);
          };
        };
      };
      /**
       * Patches the method send
       * @private
       */
      XMLHttpRequestInstrumentation.prototype._patchSend = function () {
        var plugin = this;
        function endSpanTimeout(eventName, xhrMem, performanceEndTime, endTime) {
          var callbackToRemoveEvents = xhrMem.callbackToRemoveEvents;
          if (typeof callbackToRemoveEvents === 'function') {
            callbackToRemoveEvents();
          }
          var span = xhrMem.span,
            spanUrl = xhrMem.spanUrl,
            sendStartTime = xhrMem.sendStartTime;
          if (span) {
            plugin._findResourceAndAddNetworkEvents(xhrMem, span, spanUrl, sendStartTime, performanceEndTime);
            span.addEvent(eventName, endTime);
            plugin._addFinalSpanAttributes(span, xhrMem, spanUrl);
            span.end(endTime);
            plugin._tasksCount--;
          }
          plugin._clearResources();
        }
        function endSpan(eventName, xhr) {
          var xhrMem = plugin._xhrMem.get(xhr);
          if (!xhrMem) {
            return;
          }
          xhrMem.status = xhr.status;
          xhrMem.statusText = xhr.statusText;
          plugin._xhrMem.delete(xhr);
          if (xhrMem.span) {
            plugin._applyAttributesAfterXHR(xhrMem.span, xhr);
          }
          var performanceEndTime = hrTime();
          var endTime = Date.now();
          // the timeout is needed as observer doesn't have yet information
          // when event "load" is called. Also the time may differ depends on
          // browser and speed of computer
          setTimeout(function () {
            endSpanTimeout(eventName, xhrMem, performanceEndTime, endTime);
          }, OBSERVER_WAIT_TIME_MS);
        }
        function onError() {
          endSpan(EventNames.EVENT_ERROR, this);
        }
        function onAbort() {
          endSpan(EventNames.EVENT_ABORT, this);
        }
        function onTimeout() {
          endSpan(EventNames.EVENT_TIMEOUT, this);
        }
        function onLoad() {
          if (this.status < 299) {
            endSpan(EventNames.EVENT_LOAD, this);
          } else {
            endSpan(EventNames.EVENT_ERROR, this);
          }
        }
        function unregister(xhr) {
          xhr.removeEventListener('abort', onAbort);
          xhr.removeEventListener('error', onError);
          xhr.removeEventListener('load', onLoad);
          xhr.removeEventListener('timeout', onTimeout);
          var xhrMem = plugin._xhrMem.get(xhr);
          if (xhrMem) {
            xhrMem.callbackToRemoveEvents = undefined;
          }
        }
        return function (original) {
          return function patchSend() {
            var _this = this;
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
              args[_i] = arguments[_i];
            }
            var xhrMem = plugin._xhrMem.get(this);
            if (!xhrMem) {
              return original.apply(this, args);
            }
            var currentSpan = xhrMem.span;
            var spanUrl = xhrMem.spanUrl;
            if (currentSpan && spanUrl) {
              if (plugin.getConfig().measureRequestSize && (args === null || args === void 0 ? void 0 : args[0])) {
                var body = args[0];
                var bodyLength = getXHRBodyLength(body);
                if (bodyLength !== undefined) {
                  currentSpan.setAttribute(SEMATTRS_HTTP_REQUEST_CONTENT_LENGTH_UNCOMPRESSED, bodyLength);
                }
              }
              context.with(trace.setSpan(context.active(), currentSpan), function () {
                plugin._tasksCount++;
                xhrMem.sendStartTime = hrTime();
                currentSpan.addEvent(EventNames.METHOD_SEND);
                _this.addEventListener('abort', onAbort);
                _this.addEventListener('error', onError);
                _this.addEventListener('load', onLoad);
                _this.addEventListener('timeout', onTimeout);
                xhrMem.callbackToRemoveEvents = function () {
                  unregister(_this);
                  if (xhrMem.createdResources) {
                    xhrMem.createdResources.observer.disconnect();
                  }
                };
                plugin._addHeaders(_this, spanUrl);
                plugin._addResourceObserver(_this, spanUrl);
              });
            }
            return original.apply(this, args);
          };
        };
      };
      /**
       * implements enable function
       */
      XMLHttpRequestInstrumentation.prototype.enable = function () {
        this._diag.debug('applying patch to', this.moduleName, this.version);
        if (isWrapped(XMLHttpRequest.prototype.open)) {
          this._unwrap(XMLHttpRequest.prototype, 'open');
          this._diag.debug('removing previous patch from method open');
        }
        if (isWrapped(XMLHttpRequest.prototype.send)) {
          this._unwrap(XMLHttpRequest.prototype, 'send');
          this._diag.debug('removing previous patch from method send');
        }
        this._wrap(XMLHttpRequest.prototype, 'open', this._patchOpen());
        this._wrap(XMLHttpRequest.prototype, 'send', this._patchSend());
      };
      /**
       * implements disable function
       */
      XMLHttpRequestInstrumentation.prototype.disable = function () {
        this._diag.debug('removing patch from', this.moduleName, this.version);
        this._unwrap(XMLHttpRequest.prototype, 'open');
        this._unwrap(XMLHttpRequest.prototype, 'send');
        this._tasksCount = 0;
        this._xhrMem = new WeakMap();
        this._usedResources = new WeakSet();
      };
      return XMLHttpRequestInstrumentation;
    }(InstrumentationBase);

    /*
     * Copyright The OpenTelemetry Authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      https://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    var InstrumentationMap = {
      '@opentelemetry/instrumentation-document-load': DocumentLoadInstrumentation,
      '@opentelemetry/instrumentation-fetch': FetchInstrumentation,
      '@opentelemetry/instrumentation-user-interaction': UserInteractionInstrumentation,
      '@opentelemetry/instrumentation-xml-http-request': XMLHttpRequestInstrumentation
    };
    function getWebAutoInstrumentations(inputConfigs) {
      var _a;
      if (inputConfigs === void 0) {
        inputConfigs = {};
      }
      for (var _i = 0, _b = Object.keys(inputConfigs); _i < _b.length; _i++) {
        var name_1 = _b[_i];
        if (!Object.prototype.hasOwnProperty.call(InstrumentationMap, name_1)) {
          diag.error("Provided instrumentation name \"" + name_1 + "\" not found");
          continue;
        }
      }
      var instrumentations = [];
      for (var _c = 0, _d = Object.keys(InstrumentationMap); _c < _d.length; _c++) {
        var name_2 = _d[_c];
        var Instance = InstrumentationMap[name_2];
        // Defaults are defined by the instrumentation itself
        var userConfig = (_a = inputConfigs[name_2]) !== null && _a !== void 0 ? _a : {};
        if (userConfig.enabled === false) {
          diag.debug("Disabling instrumentation for " + name_2);
          continue;
        }
        try {
          diag.debug("Loading instrumentation for " + name_2);
          instrumentations.push(new Instance(userConfig));
        } catch (e) {
          diag.error(e);
        }
      }
      return instrumentations;
    }

    /**
     * This is a proof of concept for how you might generate a bundle suitable for hosting on a CDN.
     * If you needed to support this in production, you'd want to create a similar file that exposes the functionality you
     * need for you use cases.
     *
     * Here we're making the assumption that we need to be able to:
     * - Initialize the HoneycombWebSDK
     * - We want the auto instrumentation from the meta package
     * - Create a custom span.
     */
    function configureHoneycombSDK(options, instrumentationOptions, tracerName = options.serviceName || 'tracer') {
      options.instrumentations = [...(options.instrumentations || []), getWebAutoInstrumentations(instrumentationOptions)];
      const honeycombWebSDK = new HoneycombWebSDK(Object.assign(Object.assign({}, options), {
        contextManager: new ZoneContextManager()
      }));
      const tracer = trace.getTracer(tracerName);
      return {
        start: () => honeycombWebSDK.start(),
        shutdown: () => honeycombWebSDK.shutdown(),
        startSpan: (name, options, context) => {
          return tracer.startSpan(name, options, context);
        }
      };
    }

    exports.configureHoneycombSDK = configureHoneycombSDK;

}));
